# MDN JavaScript Documentation Documentation

Generated on: 2025-11-22T13:08:50.223Z
Base URL: https://developer.mozilla.org/en-US/docs/Web/JavaScript
URL Pattern: https://developer.mozilla.org/en-US/docs/Web/JavaScript

## Documentation Content

### JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript

JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript

 
 
 

 JavaScript ( JS ) is a lightweight interpreted (or just-in-time compiled ) programming language with first-class functions . While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js , Apache CouchDB and Adobe Acrobat . JavaScript is a prototype-based , garbage-collected , dynamic language, supporting multiple paradigms such as imperative, functional, and object-oriented.

JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via `eval` ), object introspection (via `for...in` and `Object` utilities ), and source-code recovery (JavaScript functions store their source text and can be retrieved through `toString()` ).

This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM .

The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.

Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java" . Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.

JavaScript documentation of core language features (pure ECMAScript , for the most part) includes the following:

- The JavaScript guide 

- The JavaScript reference 

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview .

 
 
 
 
 
 

## Beginner's tutorials 

 
 

Our learn web development core modules contain modern, up-to-date tutorials covering JavaScript fundamentals.

 
 Your first website: Adding interactivity 
 

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

 
 Dynamic scripting with JavaScript 
 

This module focuses on the essentials of the core JavaScript language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.

 
 JavaScript frameworks and libraries 
 

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. This set of articles provides a comfortable starting point to help you begin learning frameworks.

 
 
 
 

## JavaScript guides 

 
 
 
 

### Fundamental language guides 

 
 
 JavaScript Guide 
 

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

 
 
 
 

### Intermediate 

 
 
 Advanced JavaScript objects 
 

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

 
 Asynchronous JavaScript 
 

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

 
 Client-side web APIs 
 

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

 
 JavaScript language overview 
 

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

 
 JavaScript data structures 
 

Overview of available data structures in JavaScript.

 
 Equality comparisons and sameness 
 

JavaScript provides three different value comparison operations: strict equality using `===`, loose equality using `==`, and the `Object.is()` method.

 
 Enumerability and ownership of properties 
 

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

 
 Closures 
 

A closure is the combination of a function and the lexical environment within which that function was declared.

 
 
 
 

### Advanced 

 
 
 Inheritance and the prototype chain 
 

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

 
 Memory Management 
 

Memory life cycle and garbage collection in JavaScript.

 
 
 
 

## Reference 

 
 

Browse the complete JavaScript reference documentation.

 
 Standard objects 
 

Get to know standard built-in objects: `Array` , `Boolean` , `Error` , `Function` , `JSON` , `Math` , `Number` , `Object` , `RegExp` , `String` , `Map` , `Set` , `WeakMap` , `WeakSet` , and others.

 
 Expressions and operators 
 

Learn more about the behavior of JavaScript's operators `instanceof` , `typeof` , `new` , `this` , the operator precedence , and more.

 
 Statements and declarations 
 

Learn how `do-while` , `for-in` , `for-of` , `try-catch` , `let` , `var` , `const` , `if-else` , `switch` , and more JavaScript statements and keywords work.

 
 Functions 
 

Learn how to work with JavaScript's functions to develop your applications.

 
 Classes 
 

JavaScript classes are the most appropriate way to do object-oriented programming.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 2, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript#content

JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript

 
 
 

 JavaScript ( JS ) is a lightweight interpreted (or just-in-time compiled ) programming language with first-class functions . While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js , Apache CouchDB and Adobe Acrobat . JavaScript is a prototype-based , garbage-collected , dynamic language, supporting multiple paradigms such as imperative, functional, and object-oriented.

JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via `eval` ), object introspection (via `for...in` and `Object` utilities ), and source-code recovery (JavaScript functions store their source text and can be retrieved through `toString()` ).

This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM .

The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.

Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java" . Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.

JavaScript documentation of core language features (pure ECMAScript , for the most part) includes the following:

- The JavaScript guide 

- The JavaScript reference 

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview .

 
 
 
 
 
 

## Beginner's tutorials 

 
 

Our learn web development core modules contain modern, up-to-date tutorials covering JavaScript fundamentals.

 
 Your first website: Adding interactivity 
 

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

 
 Dynamic scripting with JavaScript 
 

This module focuses on the essentials of the core JavaScript language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.

 
 JavaScript frameworks and libraries 
 

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. This set of articles provides a comfortable starting point to help you begin learning frameworks.

 
 
 
 

## JavaScript guides 

 
 
 
 

### Fundamental language guides 

 
 
 JavaScript Guide 
 

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

 
 
 
 

### Intermediate 

 
 
 Advanced JavaScript objects 
 

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

 
 Asynchronous JavaScript 
 

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

 
 Client-side web APIs 
 

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

 
 JavaScript language overview 
 

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

 
 JavaScript data structures 
 

Overview of available data structures in JavaScript.

 
 Equality comparisons and sameness 
 

JavaScript provides three different value comparison operations: strict equality using `===`, loose equality using `==`, and the `Object.is()` method.

 
 Enumerability and ownership of properties 
 

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

 
 Closures 
 

A closure is the combination of a function and the lexical environment within which that function was declared.

 
 
 
 

### Advanced 

 
 
 Inheritance and the prototype chain 
 

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

 
 Memory Management 
 

Memory life cycle and garbage collection in JavaScript.

 
 
 
 

## Reference 

 
 

Browse the complete JavaScript reference documentation.

 
 Standard objects 
 

Get to know standard built-in objects: `Array` , `Boolean` , `Error` , `Function` , `JSON` , `Math` , `Number` , `Object` , `RegExp` , `String` , `Map` , `Set` , `WeakMap` , `WeakSet` , and others.

 
 Expressions and operators 
 

Learn more about the behavior of JavaScript's operators `instanceof` , `typeof` , `new` , `this` , the operator precedence , and more.

 
 Statements and declarations 
 

Learn how `do-while` , `for-in` , `for-of` , `try-catch` , `let` , `var` , `const` , `if-else` , `switch` , and more JavaScript statements and keywords work.

 
 Functions 
 

Learn how to work with JavaScript's functions to develop your applications.

 
 Classes 
 

JavaScript classes are the most appropriate way to do object-oriented programming.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 2, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript#search

JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript

 
 
 

 JavaScript ( JS ) is a lightweight interpreted (or just-in-time compiled ) programming language with first-class functions . While it is most well-known as the scripting language for Web pages, many non-browser environments also use it, such as Node.js , Apache CouchDB and Adobe Acrobat . JavaScript is a prototype-based , garbage-collected , dynamic language, supporting multiple paradigms such as imperative, functional, and object-oriented.

JavaScript's dynamic capabilities include runtime object construction, variable parameter lists, function variables, dynamic script creation (via `eval` ), object introspection (via `for...in` and `Object` utilities ), and source-code recovery (JavaScript functions store their source text and can be retrieved through `toString()` ).

This section is dedicated to the JavaScript language itself, and not the parts that are specific to Web pages or other host environments. For information about APIs that are specific to Web pages, please see Web APIs and DOM .

The standards for JavaScript are the ECMAScript Language Specification (ECMA-262) and the ECMAScript Internationalization API specification (ECMA-402). As soon as one browser implements a feature, we try to document it. This means that cases where some proposals for new ECMAScript features have already been implemented in browsers, documentation and examples in MDN articles may use some of those new features. Most of the time, this happens between the stages 3 and 4, and is usually before the spec is officially published.

Do not confuse JavaScript with the Java programming language — JavaScript is not "Interpreted Java" . Both "Java" and "JavaScript" are trademarks or registered trademarks of Oracle in the U.S. and other countries. However, the two programming languages have very different syntax, semantics, and use.

JavaScript documentation of core language features (pure ECMAScript , for the most part) includes the following:

- The JavaScript guide 

- The JavaScript reference 

For more information about JavaScript specifications and related technologies, see JavaScript technologies overview .

 
 
 
 
 
 

## Beginner's tutorials 

 
 

Our learn web development core modules contain modern, up-to-date tutorials covering JavaScript fundamentals.

 
 Your first website: Adding interactivity 
 

This article provides a brief tour of what JavaScript is and how to use it, aimed at people who are completely new to web development.

 
 Dynamic scripting with JavaScript 
 

This module focuses on the essentials of the core JavaScript language, plus some key surrounding topics — learning these topics will give you a solid basis to work from.

 
 JavaScript frameworks and libraries 
 

JavaScript frameworks are an essential part of modern front-end web development, providing developers with tried and tested tools for building scalable, interactive web applications. Many modern companies use frameworks as a standard part of their tooling, so many front-end development jobs now require framework experience. This set of articles provides a comfortable starting point to help you begin learning frameworks.

 
 
 
 

## JavaScript guides 

 
 
 
 

### Fundamental language guides 

 
 
 JavaScript Guide 
 

A much more detailed guide to the JavaScript language, aimed at those with previous programming experience either in JavaScript or another language.

 
 
 
 

### Intermediate 

 
 
 Advanced JavaScript objects 
 

The object-oriented nature of JavaScript is important to understand if you want to go further with your knowledge of the language and write more efficient code, therefore we've provided this module to help you.

 
 Asynchronous JavaScript 
 

In this module, we take a look at asynchronous JavaScript, why it is important, and how it can be used to effectively handle potential blocking operations, such as fetching resources from a server.

 
 Client-side web APIs 
 

Explores what APIs are, and how to use some of the most common APIs you'll come across often in your development work.

 
 JavaScript language overview 
 

An overview of the basic syntax and semantics of JavaScript for those coming from other programming languages to get up to speed.

 
 JavaScript data structures 
 

Overview of available data structures in JavaScript.

 
 Equality comparisons and sameness 
 

JavaScript provides three different value comparison operations: strict equality using `===`, loose equality using `==`, and the `Object.is()` method.

 
 Enumerability and ownership of properties 
 

How different methods that visit a group of object properties one-by-one handle the enumerability and ownership of properties.

 
 Closures 
 

A closure is the combination of a function and the lexical environment within which that function was declared.

 
 
 
 

### Advanced 

 
 
 Inheritance and the prototype chain 
 

Explanation of the widely misunderstood and underestimated prototype-based inheritance.

 
 Memory Management 
 

Memory life cycle and garbage collection in JavaScript.

 
 
 
 

## Reference 

 
 

Browse the complete JavaScript reference documentation.

 
 Standard objects 
 

Get to know standard built-in objects: `Array` , `Boolean` , `Error` , `Function` , `JSON` , `Math` , `Number` , `Object` , `RegExp` , `String` , `Map` , `Set` , `WeakMap` , `WeakSet` , and others.

 
 Expressions and operators 
 

Learn more about the behavior of JavaScript's operators `instanceof` , `typeof` , `new` , `this` , the operator precedence , and more.

 
 Statements and declarations 
 

Learn how `do-while` , `for-in` , `for-of` , `try-catch` , `let` , `var` , `const` , `if-else` , `switch` , and more JavaScript statements and keywords work.

 
 Functions 
 

Learn how to work with JavaScript's functions to develop your applications.

 
 Classes 
 

JavaScript classes are the most appropriate way to do object-oriented programming.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 2, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Standard built-in objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects

Standard built-in objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Standard built-in objects

 
 
 

This chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.

The term "global objects" (or standard built-in objects) here is not to be confused with the global object . Here, "global objects" refer to objects in the global scope .

The global object itself can be accessed using the `this` operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.

Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference .

For more information about the distinction between the DOM and core JavaScript , see JavaScript technologies overview .

 
 
 
 
 
 

## Standard objects by category 

 
 
 
 

### Value properties 

 
 

These global properties return a simple value. They have no properties or methods.

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

These objects represent fundamental language constructs.

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

Error objects are a special type of fundamental object. They include the basic `Error` type, as well as several specialized error types.

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

These are the base objects representing numbers, dates, and mathematical calculations.

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

These objects represent strings and support manipulating them.

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

- `Array` 

- `TypedArray` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

These objects represent collections which use keys. The iterable collections ( `Map` and `Set` ) contain elements which are easily iterated in the order of insertion.

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

These objects interact with the garbage collection mechanism.

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

Additions to the ECMAScript core for language-sensitive functionalities.

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Control flow and error handling - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling

Control flow and error handling - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Control flow and error handling

 
 
 
- Previous 
- Next 

JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.

The JavaScript reference 
contains exhaustive details about the statements in this chapter. The semicolon
(`;`) character is used to separate statements in JavaScript code.

Any JavaScript expression is also a statement.
See Expressions and operators 
for complete information about expressions.

 
 
 
 
 
 

## Block statement 

 
 

The most basic statement is a block statement , which is used to group
statements. The block is delimited by a pair of curly braces:

 js 

```
{
  statement1;
  statement2;
  // …
  statementN;
}
```

 
 
 

### Example 

 
 

Block statements are commonly used with control flow statements (`if`,
`for`, `while`).

 js 

```
while (x < 10) {
  x++;
}
```

 

Here, `{ x++; }` is the block statement.

 

 Note: 
 `var` -declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This outputs `2` because the `var x` statement within the block is in the same scope as the `var x` statement before the block. (In C or Java, the equivalent code would have output `1`.)

This scoping effect can be mitigated by using `let` or `const` .

 
 
 

## Conditional statements 

 
 

A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: `if...else` and
`switch`.

 
 

### if...else statement 

 
 

Use the `if` statement to execute a statement if a logical condition is
`true`. Use the optional `else` clause to execute a statement if
the condition is `false`.

An `if` statement looks like this:

 js 

```
if (condition) {
  statement1;
} else {
  statement2;
}
```

 

Here, the `condition` can be any expression that evaluates to
`true` or `false`. (See Boolean 
for an explanation of what evaluates to `true` and `false`.)

If `condition` evaluates to `true`,
`statement1` is executed. Otherwise,
`statement2` is executed. `statement1` and
`statement2` can be any statement, including further nested
`if` statements.

You can also compound the statements using `else if` to have multiple
conditions tested in sequence, as follows:

 js 

```
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

 

In the case of multiple conditions, only the first logical condition which evaluates to
`true` will be executed. To execute multiple statements, group them within a
block statement (`{ /* … */ }`).

#### Best practice

In general, it's good practice to always use block statements— especially when
nesting `if` statements:

 js 

```
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
```

 

In general it's good practice to not have an `if...else` with an assignment like `x = y` as a condition:

 js 

```
if (x = y) {
  // statements here
}
```

 

However, in the rare case you find yourself wanting to do something like that, the `while` documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.

#### Falsy values

The following values evaluate to `false` (also known as Falsy values):

- `false`

- `undefined`

- `null`

- `0`

- `NaN`

- the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a
conditional statement.

 

 Note: 
Do not confuse the primitive boolean values
`true` and `false` with the true and false values of the
 `Boolean` object!

For example:

 js 

```
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```

 
 

#### Example

In the following example, the function `checkData` returns `true`
if the number of characters in a `Text` object is three. Otherwise, it
displays an alert and returns `false`.

 js 

```
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  }
  alert(
    `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
  );
  return false;
}
```

 
 
 

### switch statement 

 
 

A `switch` statement allows a program to evaluate an expression and attempt
to match the expression's value to a `case` label. If a match is found, the
program executes the associated statement.

A `switch` statement looks like this:

 js 

```
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

 

JavaScript evaluates the above switch statement as follows:

- The program first looks for a `case` clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.

- If no matching label is found, the program looks for the optional
`default` clause:

 If a `default` clause is found, the program transfers control to that
clause, executing the associated statements.

- If no `default` clause is found, the program resumes execution at the
statement following the end of `switch`.

- (By convention, the `default` clause is written as the last clause,
but it does not need to be so.)

 

#### break statements

The optional `break` statement associated with each `case` clause
ensures that the program breaks out of `switch` once the matched statement is
executed, and then continues execution at the statement following `switch`.
If `break` is omitted, the program continues execution inside the
`switch` statement (and will execute statements under the next `case`, and so on).

 Example 

In the following example, if `fruitType` evaluates to
`"Bananas"`, the program matches the value with `case "Bananas"`
and executes the associated statement. When `break` is encountered, the
program exits the `switch` and continues execution from the statement
following `switch`. If `break` were omitted, the statement for
`case "Cherries"` would also be executed.

 js 

```
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
```

 
 
 

## Exception handling statements 

 
 

You can throw exceptions using the `throw` statement and handle them using
the `try...catch` statements.

- `throw` statement 

- `try...catch` statement 

 
 

### Exception types 

 
 

Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

- ECMAScript exceptions 

- `DOMException` 

 
 

### throw statement 

 
 

Use the `throw` statement to throw an exception. A `throw`
statement specifies the value to be thrown:

 js 

```
throw expression;
```

 

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:

 js 

```
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
```

 
 
 

### try...catch statement 

 
 

The `try...catch` statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the `try...catch` statement catches it.

The `try...catch` statement consists of a `try` block, which
contains one or more statements, and a `catch` block, containing statements
that specify what to do if an exception is thrown in the `try` block.

In other words, you want the `try` block to succeed—but if it does not, you
want control to pass to the `catch` block. If any statement within the
`try` block (or in a function called from within the `try` block)
throws an exception, control immediately shifts to the `catch`
block. If no exception is thrown in the `try` block, the `catch`
block is skipped. The `finally` block executes after the `try` and
`catch` blocks execute but before the statements following the
`try...catch` statement.

The following example uses a `try...catch` statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(`1` – `12`), an exception is thrown with the value
`'Invalid month code'` and the statements in the `catch` block set the
`monthName` variable to `'unknown'`.

 js 

```
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  // prettier-ignore
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (!months[mo]) {
    throw new Error("Invalid month code"); // throw keyword is used here
  }
  return months[mo];
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
```

 

#### The catch block

You can use a `catch` block to handle all exceptions that may be generated
in the `try` block.

 js 

```
catch (exception) {
  statements
}
```

 

The `catch` block specifies an identifier (`exception`
in the preceding syntax) that holds the value specified by the `throw`
statement. You can use this identifier to get information about the exception that was
thrown.

JavaScript creates this identifier when the `catch` block is entered. The
identifier lasts only for the duration of the `catch` block. Once the
`catch` block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control
transfers to the `catch` block.

 js 

```
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
```

 
 

 Note: 
When logging errors to the console inside
a `catch` block, using `console.error()` rather than
`console.log()` is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

 

#### The finally block

The `finally` block contains statements to be executed after the
`try` and `catch` blocks execute. Additionally, the
`finally` block executes before the code that follows the
`try...catch...finally` statement.

It is also important to note that the `finally` block will execute
 whether or not an exception is thrown. If an exception is thrown, however, the
statements in the `finally` block execute even if no `catch` block
handles the exception that was thrown.

You can use the `finally` block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.

The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the `finally` block closes the file before the script fails.
Using `finally` here ensures that the file is never left open, even
if an error occurs.

 js 

```
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

 

If the `finally` block returns a value, this value becomes the return value
of the entire `try...catch...finally` production, regardless of any
`return` statements in the `try` and `catch` blocks:

 js 

```
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    // `f` exits here
    console.log(4); // not reachable
  }
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

 

Overwriting of return values by the `finally` block also applies to
exceptions thrown or re-thrown inside of the `catch` block:

 js 

```
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
    // `f` exits here
  }
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

 

#### Nesting try...catch statements

You can nest one or more `try...catch` statements.

If an inner `try` block does not have a corresponding
`catch` block:

- it must contain a `finally` block, and

- the enclosing `try...catch` statement's `catch` block is
checked for a match.

For more information, see nested try-blocks 
on the `try...catch` 
reference page.

 
 

### Utilizing Error objects 

 
 

Depending on the type of error, you may be able to use the `name` and
`message` properties to get a more refined message.

The `name` property provides the general class of `Error` (such
as `DOMException` or `Error`), while `message`
generally provides a more succinct message than one would get by converting the error
object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your `catch` block doesn't discriminate between your own
exceptions and system ones), you can use the `Error` constructor.

For example:

 js 

```
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  }
  doSomethingToGetAJavaScriptError();
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Standard built-in objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#content

Standard built-in objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Standard built-in objects

 
 
 

This chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.

The term "global objects" (or standard built-in objects) here is not to be confused with the global object . Here, "global objects" refer to objects in the global scope .

The global object itself can be accessed using the `this` operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.

Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference .

For more information about the distinction between the DOM and core JavaScript , see JavaScript technologies overview .

 
 
 
 
 
 

## Standard objects by category 

 
 
 
 

### Value properties 

 
 

These global properties return a simple value. They have no properties or methods.

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

These objects represent fundamental language constructs.

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

Error objects are a special type of fundamental object. They include the basic `Error` type, as well as several specialized error types.

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

These are the base objects representing numbers, dates, and mathematical calculations.

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

These objects represent strings and support manipulating them.

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

- `Array` 

- `TypedArray` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

These objects represent collections which use keys. The iterable collections ( `Map` and `Set` ) contain elements which are easily iterated in the order of insertion.

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

These objects interact with the garbage collection mechanism.

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

Additions to the ECMAScript core for language-sensitive functionalities.

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Standard built-in objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#search

Standard built-in objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Standard built-in objects

 
 
 

This chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.

The term "global objects" (or standard built-in objects) here is not to be confused with the global object . Here, "global objects" refer to objects in the global scope .

The global object itself can be accessed using the `this` operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.

Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference .

For more information about the distinction between the DOM and core JavaScript , see JavaScript technologies overview .

 
 
 
 
 
 

## Standard objects by category 

 
 
 
 

### Value properties 

 
 

These global properties return a simple value. They have no properties or methods.

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

These objects represent fundamental language constructs.

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

Error objects are a special type of fundamental object. They include the basic `Error` type, as well as several specialized error types.

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

These are the base objects representing numbers, dates, and mathematical calculations.

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

These objects represent strings and support manipulating them.

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

- `Array` 

- `TypedArray` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

These objects represent collections which use keys. The iterable collections ( `Map` and `Set` ) contain elements which are easily iterated in the order of insertion.

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

These objects interact with the garbage collection mechanism.

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

Additions to the ECMAScript core for language-sensitive functionalities.

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#content

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#search

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#content

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#search

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Using classes - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes

Using classes - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Using classes

 
 
 
- Previous 
- Next 

JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes , the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.

In many other languages, classes , or constructors, are clearly distinguished from objects , or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the `new` operator with a constructor function to create a new object.

We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.

This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.

 
 
 
 
 
 

## Overview of classes 

 
 

If you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you :

 js 

```
const bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}
```

 

On the first line, we created an instance of the class `Date` , and called it `bigDay`. On the second line, we called a method `toLocaleDateString()` on the `bigDay` instance, which returns a string. Then, we compared two numbers: one returned from the `getTime()` method, the other directly called from the `Date` class itself , as `Date.now()` .

`Date` is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

- Classes create objects through the `new` operator.

- Each object has some properties (data or method) added by the class.

- The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

- Constructor;

- Instance methods and instance fields;

- Static methods and static fields.

 
 

## Declaring a class 

 
 

Classes are usually created with class declarations .

 js 

```
class MyClass {
  // class body...
}
```

 

Within a class body, there are a range of features available.

 js 

```
class MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}
```

 

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:

 js 

```
function MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();
```

 
 

 Note: 
Private fields and methods are new features in classes with no trivial equivalent in function constructors.

 
 
 

### Constructing a class 

 
 

After a class has been declared, you can create instances of it using the `new` operator.

 js 

```
const myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();
```

 

Typical function constructors can both be constructed with `new` and called without `new`. However, attempting to "call" a class without `new` will result in an error.

 js 

```
const myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
```

 
 
 

### Class declaration hoisting 

 
 

Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.

 js 

```
new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}
```

 

This behavior is similar to variables declared with `let` and `const` .

 
 

### Class expressions 

 
 

Similar to functions, class declarations also have their expression counterparts.

 js 

```
const MyClass = class {
  // Class body...
};
```

 

Class expressions can have names as well. The expression's name is only visible to the class's body.

 js 

```
const MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
```

 
 
 

## Constructor 

 
 

Perhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the `Date` constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor .

As an example, we would create a class called `Color`, which represents a specific color. Users create colors through passing in an RGB triplet.

 js 

```
class Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}
```

 

Open your browser's devtools, paste the above code into the console, and then create an instance:

 js 

```
const red = new Color(255, 0, 0);
console.log(red);
```

 

You should see some output like this:



```
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]
```



You have successfully created a `Color` instance, and the instance has a `values` property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:

 js 

```
function createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}
```

 

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters :

 js 

```
class Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.
```

 

Each time you call `new`, a different instance is created.

 js 

```
const red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false
```

 

Within a class constructor, the value of `this` points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).

The `this` value will be automatically returned as the result of `new`. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the `new` expression, and the value of `this` is dropped. (You can read more about what `new` does in its description .)

 js 

```
class MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
```

 
 
 

## Instance methods 

 
 

If a class only has a constructor, it is not much different from a `createX` factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.

For example, for `Date` instances, you can use a range of methods to get different information from a single date value, such as the year , month , day of the week , etc. You can also set those values through the `setX` counterparts like `setFullYear` .

For our own `Color` class, we can add a method called `getRed` which returns the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Without methods, you may be tempted to define the function within the constructor:

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}
```

 

This also works. However, a problem is that this creates a new function every time a `Color` instance is created, even when they all do the same thing!

 js 

```
console.log(new Color().getRed === new Color().getRed); // false
```

 

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of `this` is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or `Color.prototype`, which is explained in more detail in Inheritance and the prototype chain .

Similarly, we can create a new method called `setRed`, which sets the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
```

 
 
 

## Private fields 

 
 

You might be wondering: why do we want to go to the trouble of using `getRed` and `setRed` methods, when we can directly access the `values` array on the instance?

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0
```

 

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:

 js 

```
class Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0
```

 

The user assumption that `values` means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields .

A private field is an identifier prefixed with `#` (the hash symbol). The hash is an integral part of the field's name, which means a private field can never have name clash with a public field or method. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private element on the fly). Apart from this, a private field is pretty much equivalent to a normal property.

 js 

```
class Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Accessing private fields outside the class is an early syntax error. The language can guard against this because `#privateField` is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.

 js 

```
console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
```

 
 

 Note: 
Code run in the Chrome console can access private elements outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

 

Private fields in JavaScript are hard private : if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.

After we've made the `values` field private, we can add some more logic in the `getRed` and `setRed` methods, instead of making them simple pass-through methods. For example, we can add a check in `setRed` to see if it's a valid R value:

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value
```

 

If we leave the `values` property exposed, our users can easily circumvent that check by assigning to `values[0]` directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.

A class method can read the private fields of other instances, as long as they belong to the same class.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35
```

 

However, if `anotherColor` is not a Color instance, `#values` won't exist. (Even if another class has an identically named `#values` private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private element throws an error instead of returning `undefined` like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using `try`/`catch` to handle the error, you can use the `in` operator.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}
```

 
 

 Note: 
Keep in mind that the `#` is a special identifier syntax, and you can't use the field name as if it's a string. `"#values" in anotherColor` would look for a property name literally called `"#values"`, instead of a private field.

 

There are some limitations in using private elements: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.

 js 

```
class BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}
```

 

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.

For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.

 js 

```
class Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);
```

 

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of `Counter`.

 
 

## Accessor fields 

 
 

`color.getRed()` and `color.setRed()` allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0
```

 

It looks as if the object has a property called `red` — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with `get` and `set`, which allows them to be manipulated as if they were properties.

If a field only has a getter but no setter, it will be effectively read-only.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255
```

 

In strict mode , the `red.red = 0` line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.

 
 

## Public fields 

 
 

Private fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.

 js 

```
class MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3
```

 

Public fields are almost equivalent to assigning a property to `this`. For example, the above example can also be converted to:

 js 

```
class MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
```

 
 
 

## Static properties 

 
 

With the `Date` example, we have also encountered the `Date.now()` method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the `Date` class instead of being exposed as a global `DateNow()` function, because it's mostly useful when dealing with date instances.

 

 Note: 
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed `parseInt()` method, JavaScript also later added the prefixed `Number.parseInt()` method to indicate that it's for dealing with numbers.

 

 Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

- Static methods

- Static fields

- Static getters and setters

Everything also has private counterparts. For example, for our `Color` class, we can create a static method that checks whether a given triplet is a valid RGB value:

 js 

```
class Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false
```

 

Static properties are very similar to their instance counterparts, except that:

- They are all prefixed with `static`, and

- They are not accessible from instances.

 js 

```
console.log(new Color(0, 0, 0).isValid); // undefined
```

 

There is also a special construct called a static initialization block , which is a block of code that runs when the class is first loaded.

 js 

```
class MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'
```

 

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private elements.

 
 

## Extends and inheritance 

 
 

A key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance , which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.

For example, suppose our `Color` class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:

 js 

```
class Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}
```

 

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our `Color` class will become very bloated and hard to maintain.

Instead, in object-oriented programming, we would create a derived class . The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an `extends` clause, which indicates the class it extends from.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}
```

 

There are a few things that have immediately come to attention. First is that in the constructor, we are calling `super(r, g, b)`. It is a language requirement to call `super()` before accessing `this`. The `super()` call calls the parent class's constructor to initialize `this` — here it's roughly equivalent to `this = new Color(r, g, b)`. You can have code before `super()`, but you cannot access `this` before `super()` — the language prevents you from accessing the uninitialized `this`.

After the parent class is done with modifying `this`, the derived class can do its own logic. Here we added a private field called `#alpha`, and also provided a pair of getter/setters to interact with them.

A derived class inherits all methods from its parent. For example, consider the `get red()` accessor we added to the `Color` in the Accessor fields section—even though we haven't declared one in `ColorWithAlpha`, we can still access `red` because this behavior is specified by the parent class:

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255
```

 

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the `Object` class, which defines some basic methods like `toString()` . However, the base `toString()` method is notoriously useless, because it prints `[object Object]` in most cases:

 js 

```
console.log(red.toString()); // [object Object]
```

 

Instead, our class can override it to print the color's RGB values:

 js 

```
class Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'
```

 

Within derived classes, you can access the parent class's methods by using `super`. This allows you to build enhancement methods and avoid code duplication.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'
```

 

When you use `extends`, the static methods inherit from each other as well, so you can also override or enhance them.

 js 

```
class ColorWithAlpha extends Color {
  // …
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false
```

 

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.

 js 

```
class ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}
```

 

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem . However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins .

Instances of derived classes are also instances of the base class.

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
```

 
 
 

## Why classes? 

 
 

The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.

Classes introduce a paradigm , or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism ). However, many people are philosophically against certain OOP practices and don't use classes as a result.

For example, one thing that makes `Date` objects infamous is that they're mutable .

 js 

```
function incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20
```

 

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.

In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

 

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.

On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the `Color` class, we may need to create a dozen of utility functions:

 js 

```
function isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// …
```

 

But with classes, we can congregate them all under the `Color` namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.

In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

- The `Map` and `Set` classes store a collection of elements and allow you to access them by key using `get()`, `set()`, `has()`, etc.

- The `Date` class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.

- The `Error` class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like `TypeError` and `ReferenceError` that extend `Error`. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with `instanceof` .

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 6, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#content

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#search

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#content

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#search

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#built-ins

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Control flow and error handling - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#content

Control flow and error handling - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Control flow and error handling

 
 
 
- Previous 
- Next 

JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.

The JavaScript reference 
contains exhaustive details about the statements in this chapter. The semicolon
(`;`) character is used to separate statements in JavaScript code.

Any JavaScript expression is also a statement.
See Expressions and operators 
for complete information about expressions.

 
 
 
 
 
 

## Block statement 

 
 

The most basic statement is a block statement , which is used to group
statements. The block is delimited by a pair of curly braces:

 js 

```
{
  statement1;
  statement2;
  // …
  statementN;
}
```

 
 
 

### Example 

 
 

Block statements are commonly used with control flow statements (`if`,
`for`, `while`).

 js 

```
while (x < 10) {
  x++;
}
```

 

Here, `{ x++; }` is the block statement.

 

 Note: 
 `var` -declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This outputs `2` because the `var x` statement within the block is in the same scope as the `var x` statement before the block. (In C or Java, the equivalent code would have output `1`.)

This scoping effect can be mitigated by using `let` or `const` .

 
 
 

## Conditional statements 

 
 

A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: `if...else` and
`switch`.

 
 

### if...else statement 

 
 

Use the `if` statement to execute a statement if a logical condition is
`true`. Use the optional `else` clause to execute a statement if
the condition is `false`.

An `if` statement looks like this:

 js 

```
if (condition) {
  statement1;
} else {
  statement2;
}
```

 

Here, the `condition` can be any expression that evaluates to
`true` or `false`. (See Boolean 
for an explanation of what evaluates to `true` and `false`.)

If `condition` evaluates to `true`,
`statement1` is executed. Otherwise,
`statement2` is executed. `statement1` and
`statement2` can be any statement, including further nested
`if` statements.

You can also compound the statements using `else if` to have multiple
conditions tested in sequence, as follows:

 js 

```
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

 

In the case of multiple conditions, only the first logical condition which evaluates to
`true` will be executed. To execute multiple statements, group them within a
block statement (`{ /* … */ }`).

#### Best practice

In general, it's good practice to always use block statements— especially when
nesting `if` statements:

 js 

```
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
```

 

In general it's good practice to not have an `if...else` with an assignment like `x = y` as a condition:

 js 

```
if (x = y) {
  // statements here
}
```

 

However, in the rare case you find yourself wanting to do something like that, the `while` documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.

#### Falsy values

The following values evaluate to `false` (also known as Falsy values):

- `false`

- `undefined`

- `null`

- `0`

- `NaN`

- the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a
conditional statement.

 

 Note: 
Do not confuse the primitive boolean values
`true` and `false` with the true and false values of the
 `Boolean` object!

For example:

 js 

```
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```

 
 

#### Example

In the following example, the function `checkData` returns `true`
if the number of characters in a `Text` object is three. Otherwise, it
displays an alert and returns `false`.

 js 

```
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  }
  alert(
    `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
  );
  return false;
}
```

 
 
 

### switch statement 

 
 

A `switch` statement allows a program to evaluate an expression and attempt
to match the expression's value to a `case` label. If a match is found, the
program executes the associated statement.

A `switch` statement looks like this:

 js 

```
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

 

JavaScript evaluates the above switch statement as follows:

- The program first looks for a `case` clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.

- If no matching label is found, the program looks for the optional
`default` clause:

 If a `default` clause is found, the program transfers control to that
clause, executing the associated statements.

- If no `default` clause is found, the program resumes execution at the
statement following the end of `switch`.

- (By convention, the `default` clause is written as the last clause,
but it does not need to be so.)

 

#### break statements

The optional `break` statement associated with each `case` clause
ensures that the program breaks out of `switch` once the matched statement is
executed, and then continues execution at the statement following `switch`.
If `break` is omitted, the program continues execution inside the
`switch` statement (and will execute statements under the next `case`, and so on).

 Example 

In the following example, if `fruitType` evaluates to
`"Bananas"`, the program matches the value with `case "Bananas"`
and executes the associated statement. When `break` is encountered, the
program exits the `switch` and continues execution from the statement
following `switch`. If `break` were omitted, the statement for
`case "Cherries"` would also be executed.

 js 

```
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
```

 
 
 

## Exception handling statements 

 
 

You can throw exceptions using the `throw` statement and handle them using
the `try...catch` statements.

- `throw` statement 

- `try...catch` statement 

 
 

### Exception types 

 
 

Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

- ECMAScript exceptions 

- `DOMException` 

 
 

### throw statement 

 
 

Use the `throw` statement to throw an exception. A `throw`
statement specifies the value to be thrown:

 js 

```
throw expression;
```

 

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:

 js 

```
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
```

 
 
 

### try...catch statement 

 
 

The `try...catch` statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the `try...catch` statement catches it.

The `try...catch` statement consists of a `try` block, which
contains one or more statements, and a `catch` block, containing statements
that specify what to do if an exception is thrown in the `try` block.

In other words, you want the `try` block to succeed—but if it does not, you
want control to pass to the `catch` block. If any statement within the
`try` block (or in a function called from within the `try` block)
throws an exception, control immediately shifts to the `catch`
block. If no exception is thrown in the `try` block, the `catch`
block is skipped. The `finally` block executes after the `try` and
`catch` blocks execute but before the statements following the
`try...catch` statement.

The following example uses a `try...catch` statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(`1` – `12`), an exception is thrown with the value
`'Invalid month code'` and the statements in the `catch` block set the
`monthName` variable to `'unknown'`.

 js 

```
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  // prettier-ignore
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (!months[mo]) {
    throw new Error("Invalid month code"); // throw keyword is used here
  }
  return months[mo];
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
```

 

#### The catch block

You can use a `catch` block to handle all exceptions that may be generated
in the `try` block.

 js 

```
catch (exception) {
  statements
}
```

 

The `catch` block specifies an identifier (`exception`
in the preceding syntax) that holds the value specified by the `throw`
statement. You can use this identifier to get information about the exception that was
thrown.

JavaScript creates this identifier when the `catch` block is entered. The
identifier lasts only for the duration of the `catch` block. Once the
`catch` block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control
transfers to the `catch` block.

 js 

```
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
```

 
 

 Note: 
When logging errors to the console inside
a `catch` block, using `console.error()` rather than
`console.log()` is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

 

#### The finally block

The `finally` block contains statements to be executed after the
`try` and `catch` blocks execute. Additionally, the
`finally` block executes before the code that follows the
`try...catch...finally` statement.

It is also important to note that the `finally` block will execute
 whether or not an exception is thrown. If an exception is thrown, however, the
statements in the `finally` block execute even if no `catch` block
handles the exception that was thrown.

You can use the `finally` block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.

The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the `finally` block closes the file before the script fails.
Using `finally` here ensures that the file is never left open, even
if an error occurs.

 js 

```
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

 

If the `finally` block returns a value, this value becomes the return value
of the entire `try...catch...finally` production, regardless of any
`return` statements in the `try` and `catch` blocks:

 js 

```
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    // `f` exits here
    console.log(4); // not reachable
  }
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

 

Overwriting of return values by the `finally` block also applies to
exceptions thrown or re-thrown inside of the `catch` block:

 js 

```
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
    // `f` exits here
  }
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

 

#### Nesting try...catch statements

You can nest one or more `try...catch` statements.

If an inner `try` block does not have a corresponding
`catch` block:

- it must contain a `finally` block, and

- the enclosing `try...catch` statement's `catch` block is
checked for a match.

For more information, see nested try-blocks 
on the `try...catch` 
reference page.

 
 

### Utilizing Error objects 

 
 

Depending on the type of error, you may be able to use the `name` and
`message` properties to get a more refined message.

The `name` property provides the general class of `Error` (such
as `DOMException` or `Error`), while `message`
generally provides a more succinct message than one would get by converting the error
object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your `catch` block doesn't discriminate between your own
exceptions and system ones), you can use the `Error` constructor.

For example:

 js 

```
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  }
  doSomethingToGetAJavaScriptError();
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Control flow and error handling - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#search

Control flow and error handling - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Control flow and error handling

 
 
 
- Previous 
- Next 

JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.

The JavaScript reference 
contains exhaustive details about the statements in this chapter. The semicolon
(`;`) character is used to separate statements in JavaScript code.

Any JavaScript expression is also a statement.
See Expressions and operators 
for complete information about expressions.

 
 
 
 
 
 

## Block statement 

 
 

The most basic statement is a block statement , which is used to group
statements. The block is delimited by a pair of curly braces:

 js 

```
{
  statement1;
  statement2;
  // …
  statementN;
}
```

 
 
 

### Example 

 
 

Block statements are commonly used with control flow statements (`if`,
`for`, `while`).

 js 

```
while (x < 10) {
  x++;
}
```

 

Here, `{ x++; }` is the block statement.

 

 Note: 
 `var` -declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This outputs `2` because the `var x` statement within the block is in the same scope as the `var x` statement before the block. (In C or Java, the equivalent code would have output `1`.)

This scoping effect can be mitigated by using `let` or `const` .

 
 
 

## Conditional statements 

 
 

A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: `if...else` and
`switch`.

 
 

### if...else statement 

 
 

Use the `if` statement to execute a statement if a logical condition is
`true`. Use the optional `else` clause to execute a statement if
the condition is `false`.

An `if` statement looks like this:

 js 

```
if (condition) {
  statement1;
} else {
  statement2;
}
```

 

Here, the `condition` can be any expression that evaluates to
`true` or `false`. (See Boolean 
for an explanation of what evaluates to `true` and `false`.)

If `condition` evaluates to `true`,
`statement1` is executed. Otherwise,
`statement2` is executed. `statement1` and
`statement2` can be any statement, including further nested
`if` statements.

You can also compound the statements using `else if` to have multiple
conditions tested in sequence, as follows:

 js 

```
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

 

In the case of multiple conditions, only the first logical condition which evaluates to
`true` will be executed. To execute multiple statements, group them within a
block statement (`{ /* … */ }`).

#### Best practice

In general, it's good practice to always use block statements— especially when
nesting `if` statements:

 js 

```
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
```

 

In general it's good practice to not have an `if...else` with an assignment like `x = y` as a condition:

 js 

```
if (x = y) {
  // statements here
}
```

 

However, in the rare case you find yourself wanting to do something like that, the `while` documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.

#### Falsy values

The following values evaluate to `false` (also known as Falsy values):

- `false`

- `undefined`

- `null`

- `0`

- `NaN`

- the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a
conditional statement.

 

 Note: 
Do not confuse the primitive boolean values
`true` and `false` with the true and false values of the
 `Boolean` object!

For example:

 js 

```
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```

 
 

#### Example

In the following example, the function `checkData` returns `true`
if the number of characters in a `Text` object is three. Otherwise, it
displays an alert and returns `false`.

 js 

```
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  }
  alert(
    `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
  );
  return false;
}
```

 
 
 

### switch statement 

 
 

A `switch` statement allows a program to evaluate an expression and attempt
to match the expression's value to a `case` label. If a match is found, the
program executes the associated statement.

A `switch` statement looks like this:

 js 

```
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

 

JavaScript evaluates the above switch statement as follows:

- The program first looks for a `case` clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.

- If no matching label is found, the program looks for the optional
`default` clause:

 If a `default` clause is found, the program transfers control to that
clause, executing the associated statements.

- If no `default` clause is found, the program resumes execution at the
statement following the end of `switch`.

- (By convention, the `default` clause is written as the last clause,
but it does not need to be so.)

 

#### break statements

The optional `break` statement associated with each `case` clause
ensures that the program breaks out of `switch` once the matched statement is
executed, and then continues execution at the statement following `switch`.
If `break` is omitted, the program continues execution inside the
`switch` statement (and will execute statements under the next `case`, and so on).

 Example 

In the following example, if `fruitType` evaluates to
`"Bananas"`, the program matches the value with `case "Bananas"`
and executes the associated statement. When `break` is encountered, the
program exits the `switch` and continues execution from the statement
following `switch`. If `break` were omitted, the statement for
`case "Cherries"` would also be executed.

 js 

```
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
```

 
 
 

## Exception handling statements 

 
 

You can throw exceptions using the `throw` statement and handle them using
the `try...catch` statements.

- `throw` statement 

- `try...catch` statement 

 
 

### Exception types 

 
 

Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

- ECMAScript exceptions 

- `DOMException` 

 
 

### throw statement 

 
 

Use the `throw` statement to throw an exception. A `throw`
statement specifies the value to be thrown:

 js 

```
throw expression;
```

 

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:

 js 

```
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
```

 
 
 

### try...catch statement 

 
 

The `try...catch` statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the `try...catch` statement catches it.

The `try...catch` statement consists of a `try` block, which
contains one or more statements, and a `catch` block, containing statements
that specify what to do if an exception is thrown in the `try` block.

In other words, you want the `try` block to succeed—but if it does not, you
want control to pass to the `catch` block. If any statement within the
`try` block (or in a function called from within the `try` block)
throws an exception, control immediately shifts to the `catch`
block. If no exception is thrown in the `try` block, the `catch`
block is skipped. The `finally` block executes after the `try` and
`catch` blocks execute but before the statements following the
`try...catch` statement.

The following example uses a `try...catch` statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(`1` – `12`), an exception is thrown with the value
`'Invalid month code'` and the statements in the `catch` block set the
`monthName` variable to `'unknown'`.

 js 

```
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  // prettier-ignore
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (!months[mo]) {
    throw new Error("Invalid month code"); // throw keyword is used here
  }
  return months[mo];
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
```

 

#### The catch block

You can use a `catch` block to handle all exceptions that may be generated
in the `try` block.

 js 

```
catch (exception) {
  statements
}
```

 

The `catch` block specifies an identifier (`exception`
in the preceding syntax) that holds the value specified by the `throw`
statement. You can use this identifier to get information about the exception that was
thrown.

JavaScript creates this identifier when the `catch` block is entered. The
identifier lasts only for the duration of the `catch` block. Once the
`catch` block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control
transfers to the `catch` block.

 js 

```
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
```

 
 

 Note: 
When logging errors to the console inside
a `catch` block, using `console.error()` rather than
`console.log()` is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

 

#### The finally block

The `finally` block contains statements to be executed after the
`try` and `catch` blocks execute. Additionally, the
`finally` block executes before the code that follows the
`try...catch...finally` statement.

It is also important to note that the `finally` block will execute
 whether or not an exception is thrown. If an exception is thrown, however, the
statements in the `finally` block execute even if no `catch` block
handles the exception that was thrown.

You can use the `finally` block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.

The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the `finally` block closes the file before the script fails.
Using `finally` here ensures that the file is never left open, even
if an error occurs.

 js 

```
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

 

If the `finally` block returns a value, this value becomes the return value
of the entire `try...catch...finally` production, regardless of any
`return` statements in the `try` and `catch` blocks:

 js 

```
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    // `f` exits here
    console.log(4); // not reachable
  }
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

 

Overwriting of return values by the `finally` block also applies to
exceptions thrown or re-thrown inside of the `catch` block:

 js 

```
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
    // `f` exits here
  }
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

 

#### Nesting try...catch statements

You can nest one or more `try...catch` statements.

If an inner `try` block does not have a corresponding
`catch` block:

- it must contain a `finally` block, and

- the enclosing `try...catch` statement's `catch` block is
checked for a match.

For more information, see nested try-blocks 
on the `try...catch` 
reference page.

 
 

### Utilizing Error objects 

 
 

Depending on the type of error, you may be able to use the `name` and
`message` properties to get a more refined message.

The `name` property provides the general class of `Error` (such
as `DOMException` or `Error`), while `message`
generally provides a more succinct message than one would get by converting the error
object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your `catch` block doesn't discriminate between your own
exceptions and system ones), you can use the `Error` constructor.

For example:

 js 

```
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  }
  doSomethingToGetAJavaScriptError();
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 
- Previous 
- Next 

This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.

At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate .

The expression `x = 7` is an example of the first type. This expression uses the `=` operator to assign the value seven to the variable `x`. The expression itself evaluates to `7`.

The expression `3 + 4` is an example of the second type. This expression uses the `+` operator to add `3` and `4` together and produces a value, `7`. However, if it's not eventually part of a bigger construct (for example, a variable declaration like `const z = 3 + 4`), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.

As the examples above also illustrate, all complex expressions are joined by operators , such as `=` and `+`. In this section, we will introduce the following operators:

- Assignment operators 

- Comparison operators 

- Arithmetic operators 

- Bitwise operators 

- Logical operators 

- BigInt operators 

- String operators 

- Conditional (ternary) operator 

- Comma operator 

- Unary operators 

- Relational operators 

These operators join operands either formed by higher-precedence operators or one of the basic expressions . A complete and detailed list of operators and expressions is also available in the reference .

The precedence of operators determines the order they are applied when evaluating an expression. For example:

 js 

```
const x = 1 + 2 * 3;
const y = 2 * 3 + 1;
```

 

Despite `*` and `+` coming in different orders, both expressions would result in `7` because `*` has precedence over `+`, so the `*`-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.

JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:



```
operand1 operator operand2
```



For example, `3 + 4` or `x * y`. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.

A unary operator requires a single operand, either before or after the operator:



```
operator operand
operand operator
```



For example, `x++` or `++x`. The `operator operand` form is called a prefix unary operator, and the `operand operator` form is called a postfix unary operator. `++` and `--` are the only postfix operators in JavaScript — all other operators, like `!`, `typeof`, etc. are prefix.

 
 
 
 
 
 

## Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (`=`), which assigns the value of its right operand to its left operand.
That is, `x = f()` is an assignment expression that assigns the value of `f()` to `x`.

There are also compound assignment operators that are shorthand for the operations listed in the following table:

 
 
 
 Name 
 Shorthand operator 
 Meaning 
 
 
 
 
 Assignment 
 `x = f()` 
 `x = f()` 
 
 
 Addition assignment 
 `x += f()` 
 `x = x + f()` 
 
 
 Subtraction assignment 
 `x -= f()` 
 `x = x - f()` 
 
 
 Multiplication assignment 
 `x *= f()` 
 `x = x * f()` 
 
 
 Division assignment 
 `x /= f()` 
 `x = x / f()` 
 
 
 Remainder assignment 
 `x %= f()` 
 `x = x % f()` 
 
 
 Exponentiation assignment 
 `x **= f()` 
 `x = x ** f()` 
 
 
 Left shift assignment 
 `x 
 `x = x 
 
 
 Right shift assignment 
 `x >>= f()` 
 `x = x >> f()` 
 
 
 Unsigned right shift assignment 
 `x >>>= f()` 
 `x = x >>> f()` 
 
 
 Bitwise AND assignment 
 `x &= f()` 
 `x = x & f()` 
 
 
 Bitwise XOR assignment 
 `x ^= f()` 
 `x = x ^ f()` 
 
 
 Bitwise OR assignment 
 `x |= f()` 
 `x = x | f()` 
 
 
 Logical AND assignment 
 `x &&= f()` 
 `x && (x = f())` 
 
 
 Logical OR assignment 
 `x ||= f()` 
 `x || (x = f())` 
 
 
 Nullish coalescing assignment 
 `x ??= f()` 
 `x ?? (x = f())` 
 
 
 
 
 

### Assigning to properties 

 
 

If an expression evaluates to an object , then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:

 js 

```
const obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.
```

 

For more information about objects, read Working with Objects .

If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:

 js 

```
const val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.
```

 

In strict mode , the code above throws, because one cannot assign properties to primitives.

It is an error to assign values to unmodifiable properties or to properties of an expression without properties (`null` or `undefined`).

 
 

### Destructuring 

 
 

For more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.

Without destructuring, it takes multiple statements to extract values from arrays and objects:

 js 

```
const foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];
```

 

With destructuring, you can extract multiple values into distinct variables using a single statement:

 js 

```
const [one, two, three] = foo;
```

 
 
 

### Evaluation and nesting 

 
 

In general, assignments are used within a variable declaration (i.e., with `const` , `let` , or `var` ) or as standalone statements.

 js 

```
// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().
```

 

However, like other expressions, assignment expressions like `x = f()` evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.

Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments .
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.

By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.

 js 

```
let x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

 

The evaluation result matches the expression to the right of the `=` sign in the
"Meaning" column of the table above. That means that `x = f()` evaluates into
whatever `f()`'s result is, `x += f()` evaluates into the resulting sum `x + f()`,
`x **= f()` evaluates into the resulting power `x ** f()`, and so on.

In the case of logical assignments, `x &&= f()`,
`x ||= f()`, and `x ??= f()`, the return value is that of the
logical operation without the assignment, so `x && f()`,
`x || f()`, and `x ?? f()`, respectively.

When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left 
(they are right-associative ), but they are evaluated left to right .

Note that, for all assignment operators other than `=` itself,
the resulting values are always based on the operands' values before 
the operation.

For example, assume that the following functions `f` and `g`
and the variables `x` and `y` have been declared:

 js 

```
function f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;
```

 

Consider these three examples:

 js 

```
y = x = f();
y = [f(), x = g()];
x[f()] = g();
```

 

#### Evaluation example 1

`y = x = f()` is equivalent to `y = (x = f())`,
because the assignment operator `=` is right-associative .
However, it evaluates from left to right:

- The assignment expression `y = x = f()` starts to evaluate.

 The `y` on this assignment's left-hand side evaluates
into a reference to the variable named `y`.

- The assignment expression `x = f()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- That `2` result from `f()` is assigned to `x`.

 
- The assignment expression `x = f()` has now finished evaluating;
its result is the new value of `x`, which is `2`.

- That `2` result in turn is also assigned to `y`.

 
- The assignment expression `y = x = f()` has now finished evaluating;
its result is the new value of `y` – which happens to be `2`.
`x` and `y` are assigned to `2`,
and the console has printed "F!".

#### Evaluation example 2

`y = [ f(), x = g() ]` also evaluates from left to right:

- The assignment expression `y = [ f(), x = g() ]` starts to evaluate.

 The `y` on this assignment's left-hand evaluates
into a reference to the variable named `y`.

- The inner array literal `[ f(), x = g() ]` starts to evaluate.

 The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- The assignment expression `x = g()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` result from `g()` is assigned to `x`.

 
- The assignment expression `x = g()` has now finished evaluating;
its result is the new value of `x`, which is `3`.
That `3` result becomes the next element
in the inner array literal (after the `2` from the `f()`).

 
- The inner array literal `[ f(), x = g() ]`
has now finished evaluating;
its result is an array with two values: `[ 2, 3 ]`.

- That `[ 2, 3 ]` array is now assigned to `y`.

 
- The assignment expression `y = [ f(), x = g() ]` has
now finished evaluating;
its result is the new value of `y` – which happens to be `[ 2, 3 ]`.
`x` is now assigned to `3`,
`y` is now assigned to `[ 2, 3 ]`,
and the console has printed "F!" then "G!".

#### Evaluation example 3

`x[f()] = g()` also evaluates from left to right.
(This example assumes that `x` is already assigned to some object.
For more information about objects, read Working with Objects .)

- The assignment expression `x[f()] = g()` starts to evaluate.

 The `x[f()]` property access on this assignment's left-hand
starts to evaluate.

 The `x` in this property access evaluates
into a reference to the variable named `x`.

- Then the function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

 
- The `x[f()]` property access on this assignment
has now finished evaluating;
its result is a variable property reference: `x[2]`.

- Then the function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` is now assigned to `x[2]`.
(This step will succeed only if `x` is assigned to an object .)

 
- The assignment expression `x[f()] = g()` has now finished evaluating;
its result is the new value of `x[2]` – which happens to be `3`.
`x[2]` is now assigned to `3`,
and the console has printed "F!" then "G!".

 
 

### Avoid assignment chains 

 
 

Chaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
 chaining assignments in the same statement is discouraged .

In particular, putting a variable chain in a `const` , `let` , or `var` statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the `const`/`let`/`var` statement.
For example:

 js 

```
const z = y = x = f();
```

 

This statement seemingly declares the variables `x`, `y`, and `z`.
However, it only actually declares the variable `z`.
`y` and `x` are either invalid references to nonexistent variables (in strict mode ) or, worse, would implicitly create global variables for `x` and `y` in sloppy mode .

 
 

## Comparison operators 

 
 

A comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the `===` and `!==` operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:

 js 

```
const var1 = 3;
const var2 = 4;
```

 
 
 
 Comparison operators
 
 
 
 Operator 
 Description 
 Examples returning true 
 
 
 
 
 
 Equal (`==`)
 
 Returns `true` if the operands are equal. 
 
 `3 == var1`
 

`"3" == var1`

 `3 == '3'`
 
 
 
 
 Not equal (`!=`)
 
 Returns `true` if the operands are not equal. 
 
 `var1 != 4var2 != "3"`
 
 
 
 
 Strict equal (`===`)
 
 
 Returns `true` if the operands are equal and of the same
 type. See also `Object.is` and
 sameness in JS .
 
 `3 === var1` 
 
 
 
 Strict not equal (`!==`)
 
 
 Returns `true` if the operands are of the same type but not equal, or are of different type.
 
 
 `var1 !== "3"3 !== '3'`
 
 
 
 
 Greater than (`>`)
 
 
 Returns `true` if the left operand is greater than the right operand.
 
 
 `var2 > var1"12" > 2`
 
 
 
 
 Greater than or equal 
 (`>=`)
 
 
 Returns `true` if the left operand is greater than or equal to the right operand.
 
 
 `var2 >= var1var1 >= 3`
 
 
 
 
 Less than 
 (` 
 
 Returns `true` if the left operand is less than the right operand.
 
 
 `var1 
 
 
 
 Less than or equal 
 (` 
 
 Returns `true` if the left operand is less than or equal to the right operand.
 
 
 `var1 
 
 
 
 

 Note: 
`=>` is not a comparison operator but rather is the notation
for Arrow functions .

 
 
 

## Arithmetic operators 

 
 

An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces `Infinity` ). For example:

 js 

```
1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true
```

 

In addition to the standard arithmetic operations (`+`, `-`, `*`, `/`), JavaScript provides the arithmetic operators listed in the following table:

 
 
 Arithmetic operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Remainder (`%`)
 
 
 Binary operator. Returns the integer remainder of dividing the two operands.
 
 12 % 5 returns 2. 
 
 
 
 Increment (`++`)
 
 
 Unary operator. Adds one to its operand. If used as a prefix operator
 (`++x`), returns the value of its operand after adding one;
 if used as a postfix operator (`x++`), returns the value of
 its operand before adding one.
 
 
 If `x` is 3, then `++x` sets `x` to 4
 and returns 4, whereas `x++` returns 3 and, only then, sets `x` to 4.
 
 
 
 
 Decrement (`--`)
 
 
 Unary operator. Subtracts one from its operand.
 The return value is analogous to that for the increment operator.
 
 
 If `x` is 3, then `--x` sets `x` to 2
 and returns 2, whereas `x--` returns 3 and, only then, sets `x` to 2.
 
 
 
 
 Unary negation (`-`)
 
 Unary operator. Returns the negation of its operand. 
 If `x` is 3, then `-x` returns -3. 
 
 
 
 Unary plus (`+`)
 
 
 Unary operator. Attempts to convert the operand to a number , if it is not already.
 
 
 

`+"3"` returns `3`.

 

`+true` returns `1`.

 
 
 
 
 Exponentiation operator (`**`)
 
 
 Calculates the `base` to the `exponent` power,
 that is, `base^exponent`
 
 
 `2 ** 3` returns `8`.
`10 ** -1`
 returns `0.1`.
 
 
 
 
 
 

## Bitwise operators 

 
 

A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.

The following table summarizes JavaScript's bitwise operators.

 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 Bitwise AND 
 `a & b` 
 Returns a one in each bit position for which the corresponding bits of both operands are ones. 
 
 
 Bitwise OR 
 `a | b` 
 Returns a zero in each bit position for which the corresponding bits of both operands are zeros. 
 
 
 Bitwise XOR 
 `a ^ b` 
 Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.] 
 
 
 Bitwise NOT 
 `~ a` 
 Inverts the bits of its operand. 
 
 
 Left shift 
 `a 
 Shifts `a` in binary representation `b` bits to the left, shifting in zeros from the right. 
 
 
 Sign-propagating right shift 
 `a >> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off. 
 
 
 Zero-fill right shift 
 `a >>> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off, and shifting in zeros from the left. 
 
 
 
 
 

### Bitwise logical operators 

 
 

Conceptually, the bitwise logical operators work as follows:

- 

The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:



```
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001
```



- 

Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.

- 

The operator is applied to each pair of bits, and the result is constructed bitwise.

For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:

 
 
 
 Expression 
 Result 
 Binary Description 
 
 
 
 
 `15 & 9` 
 `9` 
 `1111 & 1001 = 1001` 
 
 
 `15 | 9` 
 `15` 
 `1111 | 1001 = 1111` 
 
 
 `15 ^ 9` 
 `6` 
 `1111 ^ 1001 = 0110` 
 
 
 `~15` 
 `-16` 
 `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` 
 
 
 `~9` 
 `-10` 
 `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` 
 
 
 

Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). `~x` evaluates to the same value that
`-x - 1` evaluates to.

 
 

### Bitwise shift operators 

 
 

The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.

Shift operators convert their operands to thirty-two-bit integers and return a result of either type `Number` or `BigInt` : specifically, if the type
of the left operand is `BigInt` , they return `BigInt` ;
otherwise, they return `Number` .

The shift operators are listed in the following table.

 
 
 Bitwise shift operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Left shift 
(` 
 
 This operator shifts the first operand the specified number of bits to
 the left. Excess bits shifted off to the left are discarded. Zero bits
 are shifted in from the right.
 
 
 `9 
 
 
 
 Sign-propagating right shift (`>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Copies of
 the leftmost bit are shifted in from the left.
 
 
 `9>>2` yields 2, because 1001 shifted 2 bits to the right
 becomes 10, which is 2. Likewise, `-9>>2` yields -3, because the sign is preserved.
 
 
 
 
 Zero-fill right shift (`>>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Zero bits
 are shifted in from the left.
 
 
 `19>>>2` yields 4, because 10011 shifted 2 bits to the right
 becomes 100, which is 4. For non-negative numbers, zero-fill right shift
 and sign-propagating right shift yield the same result.
 
 
 
 
 
 

## Logical operators 

 
 

Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the `&&`, `||`, and `??` operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

 
 
 Logical operators
 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 
 Logical AND (`&&`)
 
 `expr1 && expr2` 
 
 Returns `expr1` if it can be converted to `false`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `&&` returns `true` if both
 operands are true; otherwise, returns `false`.
 
 
 
 
 Logical OR (`||`)
 
 `expr1 || expr2` 
 
 Returns `expr1` if it can be converted to `true`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `||` returns `true` if either operand is
 true; if both are false, returns `false`.
 
 
 
 
 Nullish coalescing operator (`??`)
 
 `expr1 ?? expr2` 
 
 Returns `expr1` if it is neither `null` nor
 `undefined`; otherwise, returns `expr2`.
 
 
 
 
 Logical NOT (`!`)
 
 `!expr` 
 
 Returns `false` if its single operand can be converted
 to `true`; otherwise, returns `true`.
 
 
 
 

Examples of expressions that can be converted to `false` are those that evaluate to `null`, `0`, `0n`, `NaN`, the empty string (`""`), or `undefined`.

The following code shows examples of the `&&` (logical AND) operator.

 js 

```
const a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false
```

 

The following code shows examples of the `||` (logical OR) operator.

 js 

```
const o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat
```

 

The following code shows examples of the `??` (nullish coalescing) operator.

 js 

```
const n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0
```

 

Note how `??` works like `||`, but it only returns the second expression when the first one is " nullish ", i.e., `null` or `undefined` . `??` is a better alternative than `||` for setting defaults for values that might be `null` or `undefined`, in particular when values like `''` or `0` are valid values and the default should not apply.

The following code shows examples of the `!` (logical NOT) operator.

 js 

```
const n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
```

 
 
 

### Short-circuit evaluation 

 
 

As logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

- `falsy && anything` is short-circuit evaluated to the falsy value.

- `truthy || anything` is short-circuit evaluated to the truthy value.

- `nonNullish ?? anything` is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
 anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.

 
 

## BigInt operators 

 
 

Most operators that can be used between numbers can be used between `BigInt` values as well.

 js 

```
// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n
```

 

One exception is unsigned right shift (`>>>`) , which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".

 js 

```
const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

 

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.

 js 

```
const a = 1n + 2; // TypeError: Cannot mix BigInt and other types
```

 

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.

 js 

```
const a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n
```

 

You can compare BigInts with numbers.

 js 

```
const a = 1n > 2; // false
const b = 3 > 2n; // true
```

 
 
 

## String operators 

 
 

In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.

For example,

 js 

```
console.log("my " + "string"); // console logs the string "my string".
```

 

The shorthand assignment operator `+=` can also be used to concatenate strings.

For example,

 js 

```
let myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
```

 
 
 

## Conditional (ternary) operator 

 
 

The conditional operator 
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:

 js 

```
condition ? val1 : val2
```

 

If `condition` is true, the operator has the value of `val1`.
Otherwise it has the value of `val2`. You can use the conditional operator anywhere you would use a standard operator.

For example,

 js 

```
const status = age >= 18 ? "adult" : "minor";
```

 

This statement assigns the value "adult" to the variable `status` if
`age` is eighteen or more. Otherwise, it assigns the value "minor" to
`status`.

 
 

## Comma operator 

 
 

The comma operator (`,`)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a `for` loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.

For example, if `a` is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:

 js 

```
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

 
 
 

## Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 

### delete 

 
 

The `delete` operator deletes an object's property.
The syntax is:

 js 

```
delete object.property;
delete object[propertyKey];
delete objectName[index];
```

 

where `object` is the name of an object, `property` is an existing property, and `propertyKey` is a string or symbol referring to an existing property.

If the `delete` operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield `undefined`.
The `delete` operator returns `true` if the operation is possible; it returns `false` if the operation is not possible.

 js 

```
delete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)
```

 

#### Deleting array elements

Since arrays are just objects, it's technically possible to `delete` elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value `undefined`.
To actually manipulate the array, use the various array methods such as `splice` .

 
 

### typeof 

 
 

The `typeof` operator returns a string indicating the type of the unevaluated operand.
`operand` is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.

Suppose you define the following variables:

 js 

```
const myFun = () => 5 + 2;
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();
```

 

The `typeof` operator returns the following results for these variables:

 js 

```
typeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"
```

 

For the keywords `true` and `null`, the `typeof`
operator returns the following results:

 js 

```
typeof true; // returns "boolean"
typeof null; // returns "object"
```

 

For a number or string, the `typeof` operator returns the following results:

 js 

```
typeof 62; // returns "number"
typeof "Hello world"; // returns "string"
```

 

For property values, the `typeof` operator returns the type of value the
property contains:

 js 

```
typeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"
```

 

For methods and functions, the `typeof` operator returns results as follows:

 js 

```
typeof blur; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"
```

 

For predefined objects, the `typeof` operator returns results as follows:

 js 

```
typeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
```

 
 
 

### void 

 
 

The `void` operator specifies an expression to be evaluated without returning a value. `expression` is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.

 
 

## Relational operators 

 
 

A relational operator compares its operands and returns a Boolean value based on whether the comparison is true.

 
 

### in 

 
 

The `in` operator returns `true` if the specified property is in the specified object.
The syntax is:

 js 

```
propNameOrNumber in objectName
```

 

where `propNameOrNumber` is a string, numeric, or symbol expression representing a property name or array index, and `objectName` is the name of an object.

The following examples show some uses of the `in` operator.

 js 

```
// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
```

 
 
 

### instanceof 

 
 

The `instanceof` operator returns `true`
if the specified object is of the specified object type. The syntax is:

 js 

```
object instanceof objectType
```

 

where `object` is the object to test against `objectType`, and `objectType` is a constructor representing a type, such as `Map` or `Array` .

Use `instanceof` when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.

For example, the following code uses `instanceof` to determine whether `obj` is a `Map` object. Because `obj` is a `Map` object, the statements inside the `if` block execute.

 js 

```
const obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
```

 
 
 

## Basic expressions 

 
 

All operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals , but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.

 
 

### this 

 
 

The `this` keyword is usually used within a function. In general, when the function is attached to an object as a method, `this` refers to the object that the method is called on. It functions like a hidden parameter that is passed to the function. `this` is an expression that evaluates to the object, so you can use all the object operations we introduced.

 js 

```
this["propertyName"];
this.propertyName;
doSomething(this);
```

 

For example, suppose a function is defined as follows:

 js 

```
function getFullName() {
  return `${this.firstName} ${this.lastName}`;
}
```

 

We can now attach this function to an object, and it will use the properties of that object when called:

 js 

```
const person1 = {
  firstName: "Chris",
  lastName: "Martin",
};

const person2 = {
  firstName: "Chester",
  lastName: "Bennington",
};

// Attach the same function
person1.getFullName = getFullName;
person2.getFullName = getFullName;

console.log(person1.getFullName()); // "Chris Martin"
console.log(person2.getFullName()); // "Chester Bennington"
```

 
 
 

### Grouping operator 

 
 

The grouping operator `( )` controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.

 js 

```
const a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7

// now overriding precedence
// addition before multiplication
(a + b) * c; // 9

// which is equivalent to
a * c + b * c; // 9
```

 
 
 

### Property accessor 

 
 

The property accessor syntax gets property values on objects, using either dot notation or bracket notation.

 js 

```
object.property;
object["property"];
```

 

The working with objects guide goes into more details about object properties.

 
 

### Optional chaining 

 
 

The optional chaining syntax (`?.`) performs the chained operation on an object if it is defined and non-`null`, and otherwise short-circuits the operation and returns `undefined`.
This allows you to operate on a value that may be `null` or `undefined` without causing a `TypeError`.

 js 

```
maybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
```

 
 
 

### new 

 
 

You can use the `new` operator to create an instance of a user-defined object type or of one of the built-in object types. Use `new` as follows:

 js 

```
const objectName = new ObjectType(param1, param2, /* …, */ paramN);
```

 
 
 

### super 

 
 

The `super` keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.

 js 

```
super(args); // calls the parent constructor.
super.functionOnParent(args);
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#content

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#search

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#do...while_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#content

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#search

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Keyed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections

Keyed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Keyed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are indexed by a key; `Map` and `Set` objects contain elements which are iterable in the order of insertion.

 
 
 
 
 
 

## Maps 

 
 
 
 

### Map object 

 
 

A `Map` object is a key/value map that can iterate its elements in insertion order.

The following code shows some basic operations with a `Map`. See also the `Map` reference page for more examples and the complete API. You can use a `for...of` loop to return an array of `[key, value]` for each iteration.

 js 

```
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
```

 
 
 

### Object and Map compared 

 
 

Traditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. `Map` objects, however, have a few more advantages that make them better maps.

- The keys of an `Object` are strings or symbols , whereas they can be of any value for a `Map`.

- You can get the `size` of a `Map` easily, while you have to manually keep track of size for an `Object`.

- The iteration of maps is in insertion order of the elements.

- An `Object` has a prototype, so there are default keys in the map. (This can be bypassed using `map = Object.create(null)`.)

These three tips can help you to decide whether to use a `Map` or an `Object`:

- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.

- Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.

- Use objects when there is logic that operates on individual elements.

 
 

### WeakMap object 

 
 

A `WeakMap` is a collection of key/value pairs whose keys must be objects or non-registered symbols , with values of any arbitrary JavaScript type , and which does not create strong references to its keys. That is, an object's presence as a key in a `WeakMap` does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any `WeakMap` become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a `WeakMap` key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.

The `WeakMap` API is essentially the same as the `Map` API. However, a `WeakMap` doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a `WeakMap`. If there were, the list would depend on the state of garbage collection, introducing non-determinism.

For more information and example code, see also "Why WeakMap?" on the `WeakMap` reference page.

One use case of `WeakMap` objects is to store private data for an object, or to hide implementation details. In the following example, the private data and methods belong inside the object and are stored in the `privates` object, which is a `WeakMap`. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because `privates` is not exported from the module.

 js 

```
const privates = new WeakMap();

export default function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};
```

 
 

 Note: 
This use case can now be implemented with classes and private fields .

 
 
 

## Sets 

 
 
 
 

### Set object 

 
 

 `Set` objects are collections of unique values. You can iterate its elements in insertion order. A value in a `Set` may only occur once; it is unique in the `Set`'s collection.

The following code shows some basic operations with a `Set`. See also the `Set` reference page for more examples and the complete API.

 js 

```
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
```

 
 
 

### Converting between Array and Set 

 
 

You can create an `Array` from a Set using `Array.from` or the spread syntax . Also, the `Set` constructor accepts an `Array` to convert in the other direction.

 

 Note: 
`Set` objects store unique values —so any duplicate elements from an Array are deleted when converting!

 
 js 

```
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
```

 
 
 

### Array and Set compared 

 
 

Traditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The `Set` object, however, has some advantages:

- Deleting Array elements by value (`arr.splice(arr.indexOf(val), 1)`) is very slow.

- `Set` objects let you delete elements by their value. With an array, you would have to `splice` based on an element's index.

- The value `NaN` cannot be found with `indexOf` in an array.

- `Set` objects store unique values. You don't have to manually keep track of duplicates.

 
 

### WeakSet object 

 
 

 `WeakSet` objects are collections of garbage-collectable values, including objects and non-registered symbols . A value in the `WeakSet` may only occur once. It is unique in the `WeakSet`'s collection.

The main differences to the `Set` object are:

- In contrast to `Sets`, `WeakSets` are collections of objects or symbols only , and not of arbitrary values of any type.

- The `WeakSet` is weak : References to objects in the collection are held weakly. If there is no other reference to an object stored in the `WeakSet`, they can be garbage collected. That also means that there is no list of current objects stored in the collection.

- `WeakSets` are not enumerable.

The use cases of `WeakSet` objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.

 
 

## Key and value equality of Map and Set 

 
 

Both the key equality of `Map` objects and the value equality of `Set` objects are based on the SameValueZero algorithm :

- Equality works like the identity comparison operator `===`.

- `-0` and `+0` are considered equal.

- `NaN` is considered equal to itself (contrary to `===`).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#creating_new_objects

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#objects_and_properties

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#inheritance

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### this - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this

this - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# this

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `this` keyword refers to the context where a piece of code, such as a function's body, is supposed to run. Most typically, it is used in object methods, where `this` refers to the object that the method is attached to, thus allowing the same method to be reused on different objects.

The value of `this` in JavaScript depends on how a function is invoked (runtime binding ), not how it is defined. When a regular function is invoked as a method of an object (`obj.method()`), `this` points to that object. When invoked as a standalone function (not attached to an object: `func()`), `this` typically refers to the global object (in non-strict mode) or `undefined` (in strict mode ). The `Function.prototype.bind()` method can create a function whose `this` binding doesn't change, and methods `Function.prototype.apply()` and `Function.prototype.call()` can also set the `this` value for a particular call.

 Arrow functions differ in their handling of `this`: they inherit `this` from the parent scope at the time they are defined. This behavior makes arrow functions particularly useful for callbacks and preserving context. However, arrow functions do not have their own `this` binding. Therefore, their `this` value cannot be set by `bind()`, `apply()` or `call()` methods, nor does it point to the current object in object methods.

 
 
 
 
 
 

## Try it 

 
 
 

```
const test = {
  prop: 42,
  func() {
    return this.prop;
  },
};

console.log(test.func());
// Expected output: 42
```

 
 
 

## Syntax 

 
 js 

```
this
```

 
 
 

### Value 

 
 

In non–strict mode, `this` is always a reference to an object. In strict mode, it can be any value. For more information on how the value is determined, see the description below.

 
 

## Description 

 
 

The value of `this` depends on in which context it appears: function, class, or global.

 
 

### Function context 

 
 

Inside a function, the value of `this` depends on how the function is called. Think about `this` as a hidden parameter of a function — just like the parameters declared in the function definition, `this` is a binding that the language creates for you when the function body is evaluated.

For a regular function (not an arrow function, bound function, etc.), the value of `this` is the object that the function is accessed on. In other words, if the function call is in the form `obj.f()`, then `this` refers to `obj`. For example:

 js 

```
function getThis() {
  return this;
}

const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

obj1.getThis = getThis;
obj2.getThis = getThis;

console.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }
console.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }
```

 

Note how the function is the same, but based on how it's invoked, the value of `this` is different. This is analogous to how function parameters work.

The value of `this` is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the prototype chain .

 js 

```
const obj3 = {
  __proto__: obj1,
  name: "obj3",
};

console.log(obj3.getThis()); // { name: 'obj3' }
```

 

The value of `this` always changes based on how a function is called, even when the function was defined on an object at creation:

 js 

```
const obj4 = {
  name: "obj4",
  getThis() {
    return this;
  },
};

const obj5 = { name: "obj5" };

obj5.getThis = obj4.getThis;
console.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }
```

 

If the value that the method is accessed on is a primitive, `this` will be a primitive value as well — but only if the function is in strict mode.

 js 

```
function getThisStrict() {
  "use strict"; // Enter strict mode
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThisStrict = getThisStrict;
console.log(typeof (1).getThisStrict()); // "number"
```

 

If the function is called without being accessed on anything, `this` will be `undefined` — but only if the function is in strict mode.

 js 

```
console.log(typeof getThisStrict()); // "undefined"
```

 

In non-strict mode, a special process called `this` substitution ensures that the value of `this` is always an object. This means:

- If a function is called with `this` set to `undefined` or `null`, `this` gets substituted with `globalThis` .

- If the function is called with `this` set to a primitive value, `this` gets substituted with the primitive value's wrapper object.

 js 

```
function getThis() {
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThis = getThis;
console.log(typeof (1).getThis()); // "object"
console.log(getThis() === globalThis); // true
```

 

In typical function calls, `this` is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of `this` using the `Function.prototype.call()` , `Function.prototype.apply()` , or `Reflect.apply()` methods. Using `Function.prototype.bind()` , you can create a new function with a specific value of `this` that doesn't change regardless of how the function is called. When using these methods, the `this` substitution rules above still apply if the function is non-strict.

#### Callbacks

When a function is passed as a callback, the value of `this` depends on how the callback is called, which is determined by the implementor of the API. Callbacks are typically called with a `this` value of `undefined` (calling it directly without attaching it to any object), which means if the function is non–strict, the value of `this` is the global object ( `globalThis` ). This is the case for iterative array methods , the `Promise()` constructor, etc.

 js 

```
function logThis() {
  "use strict";
  console.log(this);
}

[1, 2, 3].forEach(logThis); // undefined, undefined, undefined
```

 

Some APIs allow you to set a `this` value for invocations of the callback. For example, all iterative array methods and related ones like `Set.prototype.forEach()` accept an optional `thisArg` parameter.

 js 

```
[1, 2, 3].forEach(logThis, { name: "obj" });
// { name: 'obj' }, { name: 'obj' }, { name: 'obj' }
```

 

Occasionally, a callback is called with a `this` value other than `undefined`. For example, the `reviver` parameter of `JSON.parse()` and the `replacer` parameter of `JSON.stringify()` are both called with `this` set to the object that the property being parsed/serialized belongs to.

#### Arrow functions

In arrow functions , `this` retains the value of the enclosing lexical context's `this`. In other words, when evaluating an arrow function's body, the language does not create a new `this` binding.

For example, in global code, `this` is always `globalThis` regardless of strictness, because of the global context binding:

 js 

```
const globalObject = this;
const foo = () => this;
console.log(foo() === globalObject); // true
```

 

Arrow functions create a closure over the `this` value of its surrounding scope, which means arrow functions behave as if they are "auto-bound" — no matter how it's invoked, `this` is bound to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their `this` remains that of the enclosing lexical context. See example below .

Furthermore, when invoking arrow functions using `call()`, `bind()`, or `apply()`, the `thisArg` parameter is ignored. You can still pass other arguments using these methods, though.

 js 

```
const obj = { name: "obj" };

// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true

// Attempt to set this using bind
const boundFoo = foo.bind(obj);
console.log(boundFoo() === globalObject); // true
```

 

#### Constructors

When a function is used as a constructor (with the `new` keyword), its `this` is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of `this` becomes the value of the `new` expression unless the constructor returns another non–primitive value.

 js 

```
function C() {
  this.a = 37;
}

let o = new C();
console.log(o.a); // 37

function C2() {
  this.a = 37;
  return { a: 38 };
}

o = new C2();
console.log(o.a); // 38
```

 

In the second example (`C2`), because an object was returned during construction, the new object that `this` was bound to gets discarded. (This essentially makes the statement `this.a = 37;` dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)

#### super

When a function is invoked in the `super.method()` form, the `this` inside the `method` function is the same value as the `this` value around the `super.method()` call, and is generally not equal to the object that `super` refers to. This is because `super.method` is not an object member access like the ones above — it's a special syntax with different binding rules. For examples, see the `super` reference .

 
 

### Class context 

 
 

A class can be split into two contexts: static and instance. Constructors , methods, and instance field initializers ( public or private ) belong to the instance context. Static methods, static field initializers, and static initialization blocks belong to the static context. The `this` value is different in each context.

Class constructors are always called with `new`, so their behavior is the same as function constructors : the `this` value is the new instance being created. Class methods behave like methods in object literals — the `this` value is the object that the method was accessed on. If the method is not transferred to another object, `this` is generally an instance of the class.

Static methods are not properties of `this`. They are properties of the class itself. Therefore, they are generally accessed on the class, and `this` is the value of the class (or a subclass). Static initialization blocks are also evaluated with `this` set to the current class.

Field initializers are also evaluated in the context of the class. Instance fields are evaluated with `this` set to the instance being constructed. Static fields are evaluated with `this` set to the current class. This is why arrow functions in field initializers are bound to the instance for instance fields and to the class for static fields .

 js 

```
class C {
  instanceField = this;
  static staticField = this;
}

const c = new C();
console.log(c.instanceField === c); // true
console.log(C.staticField === C); // true
```

 

#### Derived class constructors

Unlike base class constructors, derived constructors have no initial `this` binding. Calling `super()` creates a `this` binding within the constructor and essentially has the effect of evaluating the following line of code, where `Base` is the base class:

 js 

```
this = new Base();
```

 
 

 Warning: 
Referring to `this` before calling `super()` will throw an error.

 

Derived classes must not return before calling `super()`, unless the constructor returns an object (so the `this` value is overridden) or the class has no constructor at all.

 js 

```
class Base {}
class Good extends Base {}
class AlsoGood extends Base {
  constructor() {
    return { a: 5 };
  }
}
class Bad extends Base {
  constructor() {}
}

new Good();
new AlsoGood();
new Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

 
 
 

### Global context 

 
 

In the global execution context (outside of any functions or classes; may be inside blocks or arrow functions defined in the global scope), the `this` value depends on what execution context the script runs in. Like callbacks , the `this` value is determined by the runtime environment (the caller).

At the top level of a script, `this` refers to `globalThis` whether in strict mode or not. This is generally the same as the global object — for example, if the source is put inside an HTML ` ` element and executed as a script, `this === window`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 js 

```
// In web browsers, the window object is also the global object:
console.log(this === window); // true

this.b = "MDN";
console.log(window.b); // "MDN"
console.log(b); // "MDN"
```

 

If the source is loaded as a module (for HTML, this means adding `type="module"` to the ` ` tag), `this` is always `undefined` at the top level.

If the source is executed with `eval()` , `this` is the same as the enclosing context for direct eval , or `globalThis` (as if it's run in a separate global script) for indirect eval.

 js 

```
function test() {
  // Direct eval
  console.log(eval("this") === this);
  // Indirect eval, non-strict
  console.log(eval?.("this") === globalThis);
  // Indirect eval, strict
  console.log(eval?.("'use strict'; this") === globalThis);
}

test.call({ name: "obj" }); // Logs 3 "true"
```

 

Note that some source code, while looking like the global scope, is actually wrapped in a function when executed. For example, Node.js CommonJS modules are wrapped in a function and executed with the `this` value set to `module.exports`. Event handler attributes are executed with `this` set to the element they are attached to.

Object literals don't create a `this` scope — only functions (methods) defined within the object do. Using `this` in an object literal inherits the value from the surrounding scope.

 js 

```
const obj = {
  a: this,
};

console.log(obj.a === window); // true
```

 
 
 

## Examples 

 
 
 
 

### this in function contexts 

 
 

The value of the `this` parameter depends on how the function is called, not on how it's defined.

 js 

```
// An object can be passed as the first argument to 'call'
// or 'apply' and 'this' will be bound to it.
const obj = { a: "Custom" };

// Variables declared with var become properties of 'globalThis'.
var a = "Global";

function whatsThis() {
  return this.a; // 'this' depends on how the function is called
}

whatsThis(); // 'Global'; the 'this' parameter defaults to 'globalThis' in non–strict mode
obj.whatsThis = whatsThis;
obj.whatsThis(); // 'Custom'; the 'this' parameter is bound to obj
```

 

Using `call()` and `apply()`, you can pass the value of `this` as if it's an explicit parameter.

 js 

```
function add(c, d) {
  return this.a + this.b + c + d;
}

const o = { a: 1, b: 3 };

// The first argument is bound to the implicit 'this' parameter; the remaining
// arguments are bound to the named parameters.
add.call(o, 5, 7); // 16

// The first argument is bound to the implicit 'this' parameter; the second
// argument is an array whose members are bound to the named parameters.
add.apply(o, [10, 20]); // 34
```

 
 
 

### this and object conversion 

 
 

In non–strict mode, if a function is called with a `this` value that's not an object, the `this` value is substituted with an object. `null` and `undefined` become `globalThis`. Primitives like `7` or `'foo'` are converted to an object using the related constructor, so the primitive number `7` is converted to a `Number` wrapper class and the string `'foo'` to a `String` wrapper class.

 js 

```
function bar() {
  console.log(Object.prototype.toString.call(this));
}

bar.call(7); // [object Number]
bar.call("foo"); // [object String]
bar.call(undefined); // [object Window]
```

 
 
 

### The bind() method 

 
 

Calling `f.bind(someObject)` creates a new function with the same body and scope as `f`, but the value of `this` is permanently bound to the first argument of `bind`, regardless of how the function is being called.

 js 

```
function f() {
  return this.a;
}

const g = f.bind({ a: "azerty" });
console.log(g()); // azerty

const h = g.bind({ a: "yoo" }); // bind only works once!
console.log(h()); // azerty

const o = { a: 37, f, g, h };
console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty
```

 
 
 

### this in arrow functions 

 
 

Arrow functions create closures over the `this` value of the enclosing execution context. In the following example, we create `obj` with a method `getThisGetter` that returns a function that returns the value of `this`. The returned function is created as an arrow function, so its `this` is permanently bound to the `this` of its enclosing function. The value of `this` inside `getThisGetter` can be set in the call, which in turn sets the return value of the returned function. We will assume that `getThisGetter` is a non-strict function, which means it's contained in a non-strict script and not further nested in a class or strict function.

 js 

```
const obj = {
  getThisGetter() {
    const getter = () => this;
    return getter;
  },
};
```

 

We can call `getThisGetter` as a method of `obj`, which binds `this` to `obj` inside its body. The returned function is assigned to a variable `fn`. Now, when calling `fn`, the value of `this` returned is still the one set by the call to `getThisGetter`, which is `obj`. If the returned function was not an arrow function, such calls would cause the `this` value to be `globalThis`, because `getThisGetter` is non-strict.

 js 

```
const fn = obj.getThisGetter();
console.log(fn() === obj); // true
```

 

But be careful if you unbind the method of `obj` without calling it, because `getThisGetter` is still a method that has a varying `this` value. Calling `fn2()()` in the following example returns `globalThis`, because it follows the `this` from `fn2()`, which is `globalThis` since it's called without being attached to any object.

 js 

```
const fn2 = obj.getThisGetter;
console.log(fn2()() === globalThis); // true in non-strict mode
```

 

This behavior is very useful when defining callbacks. Usually, each function expression creates its own `this` binding, which shadows the `this` value of the upper scope. Now, you can define functions as arrow functions if you don't care about the `this` value, and only create `this` bindings where you do (e.g., in class methods). See example with `setTimeout()` .

 
 

### this with a getter or setter 

 
 

`this` in getters and setters is based on which object the property is accessed on, not which object the property is defined on. A function used as getter or setter has its `this` bound to the object from which the property is being set or gotten.

 js 

```
function sum() {
  return this.a + this.b + this.c;
}

const o = {
  a: 1,
  b: 2,
  c: 3,
  get average() {
    return (this.a + this.b + this.c) / 3;
  },
};

Object.defineProperty(o, "sum", {
  get: sum,
  enumerable: true,
  configurable: true,
});

console.log(o.average, o.sum); // 2 6
```

 
 
 

### this in DOM event handlers 

 
 

When a function is used as an event handler, its `this` parameter is bound to the DOM element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than `addEventListener()` ).

 js 

```
// When called as a listener, turns the related element blue
function bluify(e) {
  // Always true
  console.log(this === e.currentTarget);
  // true when currentTarget and target are the same object
  console.log(this === e.target);
  this.style.backgroundColor = "#A5D9F3";
}

// Get a list of every element in the document
const elements = document.getElementsByTagName("*");

// Add bluify as a click listener so when the
// element is clicked on, it turns blue
for (const element of elements) {
  element.addEventListener("click", bluify);
}
```

 
 
 

### this in inline event handlers 

 
 

When the code is called from an inline event handler attribute , its `this` is bound to the DOM element on which the listener is placed:

 html 

```
<button onclick="alert(this.tagName.toLowerCase());">Show this</button>
```

 

The above alert shows `button`. Note, however, that only the outer scope has its `this` bound this way:

 html 

```
<button onclick="alert((function () { return this; })());">
  Show inner this
</button>
```

 

In this case, the `this` parameter of the inner function is bound to `globalThis` (i.e., the default object in non–strict mode where `this` isn't passed in the call).

 
 

### Bound methods in classes 

 
 

Just like with regular functions, the value of `this` within methods depends on how they are called. Sometimes it is useful to override this behavior so that `this` within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:

 js 

```
class Car {
  constructor() {
    // Bind sayBye but not sayHi to show the difference
    this.sayBye = this.sayBye.bind(this);
  }

  sayHi() {
    console.log(`Hello from ${this.name}`);
  }

  sayBye() {
    console.log(`Bye from ${this.name}`);
  }

  get name() {
    return "Ferrari";
  }
}

class Bird {
  get name() {
    return "Tweety";
  }
}

const car = new Car();
const bird = new Bird();

// The value of 'this' in methods depends on their caller
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// For bound methods, 'this' doesn't depend on the caller
bird.sayBye = car.sayBye;
bird.sayBye(); // Bye from Ferrari
```

 
 

 Note: 
Classes are always in strict mode. Calling methods with an undefined `this` will throw an error if the method tries to access properties on `this`.

 js 

```
const carSayHi = car.sayHi;
carSayHi(); // TypeError because the 'sayHi' method tries to access 'this.name', but 'this' is undefined in strict mode.
```

 
 

Note, however, that auto-bound methods suffer from the same problem as using arrow functions for class properties : each instance of the class will have its own copy of the method, which increases memory usage. Only use it where absolutely necessary. You can also mimic the implementation of `Intl.NumberFormat.prototype.format()` : define the property as a getter that returns a bound function when accessed and saves it, so that the function is only created once and only created when necessary.

 
 

### this in with statements 

 
 

Although `with` statements are deprecated and not available in strict mode, they still serve as an exception to the normal `this` binding rules. If a function is called within a `with` statement and that function is a property of the scope object, the `this` value is bound to the scope object, as if the `obj.` prefix exists.

 js 

```
const obj = {
  foo() {
    return this;
  },
};

with (obj) {
  console.log(foo() === obj); // true
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Strict mode 

- `globalThis` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 18, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Standard built-in objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#standard_objects_by_category

Standard built-in objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Standard built-in objects

 
 
 

This chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.

The term "global objects" (or standard built-in objects) here is not to be confused with the global object . Here, "global objects" refer to objects in the global scope .

The global object itself can be accessed using the `this` operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.

Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference .

For more information about the distinction between the DOM and core JavaScript , see JavaScript technologies overview .

 
 
 
 
 
 

## Standard objects by category 

 
 
 
 

### Value properties 

 
 

These global properties return a simple value. They have no properties or methods.

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

These objects represent fundamental language constructs.

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

Error objects are a special type of fundamental object. They include the basic `Error` type, as well as several specialized error types.

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

These are the base objects representing numbers, dates, and mathematical calculations.

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

These objects represent strings and support manipulating them.

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

- `Array` 

- `TypedArray` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

These objects represent collections which use keys. The iterable collections ( `Map` and `Set` ) contain elements which are easily iterated in the order of insertion.

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

These objects interact with the garbage collection mechanism.

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

Additions to the ECMAScript core for language-sensitive functionalities.

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Standard built-in objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#value_properties

Standard built-in objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Standard built-in objects

 
 
 

This chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.

The term "global objects" (or standard built-in objects) here is not to be confused with the global object . Here, "global objects" refer to objects in the global scope .

The global object itself can be accessed using the `this` operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.

Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference .

For more information about the distinction between the DOM and core JavaScript , see JavaScript technologies overview .

 
 
 
 
 
 

## Standard objects by category 

 
 
 
 

### Value properties 

 
 

These global properties return a simple value. They have no properties or methods.

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

These objects represent fundamental language constructs.

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

Error objects are a special type of fundamental object. They include the basic `Error` type, as well as several specialized error types.

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

These are the base objects representing numbers, dates, and mathematical calculations.

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

These objects represent strings and support manipulating them.

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

- `Array` 

- `TypedArray` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

These objects represent collections which use keys. The iterable collections ( `Map` and `Set` ) contain elements which are easily iterated in the order of insertion.

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

These objects interact with the garbage collection mechanism.

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

Additions to the ECMAScript core for language-sensitive functionalities.

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#expressions_and_operators_by_category

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#specifications

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#browser_compatibility

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#see_also

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators#primary_expressions

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 

This chapter documents all the JavaScript language operators, expressions and keywords.

 
 
 
 
 
 

## Expressions and operators by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Primary expressions 

 
 

Basic keywords and general expressions in JavaScript. These expressions have the highest precedence (higher than operators ).

 
 `this` 
 

The `this` keyword refers to a special property of an execution context.

 
 Literals 
 

Basic `null`, boolean, number, and string literals.

 
 `[]` 
 

Array initializer/literal syntax.

 
 `{}` 
 

Object initializer/literal syntax.

 
 `function` 
 

The `function` keyword defines a function expression.

 
 `class` 
 

The `class` keyword defines a class expression.

 
 `function*` 
 

The `function*` keyword defines a generator function expression.

 
 `async function` 
 

The `async function` defines an async function expression.

 
 `async function*` 
 

The `async function*` keywords define an async generator function expression.

 
 `/ab+c/i` 
 

Regular expression literal syntax.

 
 ``string`` 
 

Template literal syntax.

 
 `( )` 
 

Grouping operator.

 
 
 
 

### Left-hand-side expressions 

 
 

Left values are the destination of an assignment.

 
 Property accessors 
 

Member operators provide access to a property or method of an object (`object.property` and `object["property"]`).

 
 `?.` 
 

The optional chaining operator returns `undefined` instead of causing an error if a reference is nullish ( `null` or `undefined` ).

 
 `new` 
 

The `new` operator creates an instance of a constructor.

 
 `new.target` 
 

In constructors, `new.target` refers to the constructor that was invoked by `new` .

 
 `import.meta` 
 

An object exposing context-specific metadata to a JavaScript module.

 
 `super` 
 

The `super` keyword calls the parent constructor or allows accessing properties of the parent object.

 
 `import()` 
 

The `import()` syntax allows loading a module asynchronously and dynamically into a potentially non-module environment.

 
 
 
 

### Increment and decrement 

 
 

Postfix/prefix increment and postfix/prefix decrement operators.

 
 `A++` 
 

Postfix increment operator.

 
 `A--` 
 

Postfix decrement operator.

 
 `++A` 
 

Prefix increment operator.

 
 `--A` 
 

Prefix decrement operator.

 
 
 
 

### Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 `delete` 
 

The `delete` operator deletes a property from an object.

 
 `void` 
 

The `void` operator evaluates an expression and discards its return value.

 
 `typeof` 
 

The `typeof` operator determines the type of a given object.

 
 `+` 
 

The unary plus operator converts its operand to Number type.

 
 `-` 
 

The unary negation operator converts its operand to Number type and then negates it.

 
 `~` 
 

Bitwise NOT operator.

 
 `!` 
 

Logical NOT operator.

 
 `await` 
 

Pause and resume an async function and wait for the promise's fulfillment/rejection.

 
 
 
 

### Arithmetic operators 

 
 

Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value.

 
 `**` 
 

Exponentiation operator.

 
 `*` 
 

Multiplication operator.

 
 `/` 
 

Division operator.

 
 `%` 
 

Remainder operator.

 
 `+` (Plus) 
 

Addition operator.

 
 `-` 
 

Subtraction operator.

 
 
 
 

### Relational operators 

 
 

A comparison operator compares its operands and returns a boolean value based on whether the comparison is true.

 
 ` (Less than) 
 

Less than operator.

 
 `>` (Greater than) 
 

Greater than operator.

 
 ` 
 

Less than or equal operator.

 
 `>=` 
 

Greater than or equal operator.

 
 `instanceof` 
 

The `instanceof` operator determines whether an object is an instance of another object.

 
 `in` 
 

The `in` operator determines whether an object has a given property.

 
 
 

 Note: 
`=>` is not an operator, but the notation for Arrow functions .

 
 
 

### Equality operators 

 
 

The result of evaluating an equality operator is always of type boolean based on whether the comparison is true.

 
 `==` 
 

Equality operator.

 
 `!=` 
 

Inequality operator.

 
 `===` 
 

Strict equality operator.

 
 `!==` 
 

Strict inequality operator.

 
 
 
 

### Bitwise shift operators 

 
 

Operations to shift all bits of the operand.

 
 ` 
 

Bitwise left shift operator.

 
 `>>` 
 

Bitwise right shift operator.

 
 `>>>` 
 

Bitwise unsigned right shift operator.

 
 
 
 

### Binary bitwise operators 

 
 

Bitwise operators treat their operands as a set of 32 bits (zeros and ones) and return standard JavaScript numerical values.

 
 `&` 
 

Bitwise AND.

 
 `|` 
 

Bitwise OR.

 
 `^` 
 

Bitwise XOR.

 
 
 
 

### Binary logical operators 

 
 

Logical operators implement boolean (logical) values and have short-circuiting behavior.

 
 `&&` 
 

Logical AND.

 
 `||` 
 

Logical OR.

 
 `??` 
 

Nullish Coalescing Operator.

 
 
 
 

### Conditional (ternary) operator 

 
 
 `(condition ? ifTrue : ifFalse)` 
 

The conditional operator returns one of two values based on the logical value of the condition.

 
 
 
 

### Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.

 
 `=` 
 

Assignment operator.

 
 `*=` 
 

Multiplication assignment.

 
 `/=` 
 

Division assignment.

 
 `%=` 
 

Remainder assignment.

 
 `+=` 
 

Addition assignment.

 
 `-=` 
 

Subtraction assignment

 
 ` 
 

Left shift assignment.

 
 `>>=` 
 

Right shift assignment.

 
 `>>>=` 
 

Unsigned right shift assignment.

 
 `&=` 
 

Bitwise AND assignment.

 
 `^=` 
 

Bitwise XOR assignment.

 
 `|=` 
 

Bitwise OR assignment.

 
 `**=` 
 

Exponentiation assignment.

 
 `&&=` 
 

Logical AND assignment.

 
 `||=` 
 

Logical OR assignment.

 
 `??=` 
 

Nullish coalescing assignment.

 
 `[a, b] = arr`, `{ a, b } = obj` 
 

Destructuring allows you to assign the properties of an array or object to variables using syntax that looks similar to array or object literals.

 
 
 
 

### Yield operators 

 
 
 `yield` 
 

Pause and resume a generator function.

 
 `yield*` 
 

Delegate to another generator function or iterable object.

 
 
 
 

### Spread syntax 

 
 
 `...obj` 
 

Spread syntax allows an iterable, such as an array or string, to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected. In an object literal, the spread syntax enumerates the properties of an object and adds the key-value pairs to the object being created.

 
 
 
 

### Comma operator 

 
 
 `,` 
 

The comma operator allows multiple expressions to be evaluated in a single statement and returns the result of the last expression.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-assignment-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-relational-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-property-accessors 
 
 ECMAScript® 2026 Language Specification 
 # prod-ImportMeta 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-equality-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-multiplicative-operators 
 
 ECMAScript® 2026 Language Specification 
 # sec-new-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-bitwise-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unsigned-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-conditional-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 ECMAScript® 2026 Language Specification 
 # prod-SpreadElement 
 
 ECMAScript® 2026 Language Specification 
 # prod-LogicalANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-CoalesceExpression 
 
 ECMAScript® 2026 Language Specification 
 # prod-ArgumentList 
 
 ECMAScript® 2026 Language Specification 
 # prod-PropertyDefinition 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseORExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 ECMAScript® 2026 Language Specification 
 # sec-grouping-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-left-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-super-keyword 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-decrement-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-signed-right-shift-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-OptionalExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-delete-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-async-generator-function-definitions 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-assignment 
 
 ECMAScript® 2026 Language Specification 
 # sec-destructuring-binding-patterns 
 
 ECMAScript® 2026 Language Specification 
 # sec-exp-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-addition-operator-plus 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions-runtime-semantics-evaluation 
 
 ECMAScript® 2026 Language Specification 
 # sec-import-calls 
 
 ECMAScript® 2026 Language Specification 
 # sec-null-value 
 
 ECMAScript® 2026 Language Specification 
 # sec-comma-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-built-in-function-objects 
 
 ECMAScript® 2026 Language Specification 
 # sec-postfix-increment-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-typeof-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 ECMAScript® 2026 Language Specification 
 # prod-YieldExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-subtraction-operator-minus 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseANDExpression 
 
 ECMAScript® 2026 Language Specification 
 # sec-void-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-plus-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-logical-not-operator 
 
 ECMAScript® 2026 Language Specification 
 # sec-unary-minus-operator 
 
 ECMAScript® 2026 Language Specification 
 # prod-BitwiseXORExpression 
 
 HTML 
 # import-meta-resolve 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Operator precedence 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Operator precedence - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence

Operator precedence - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Operator precedence

 
 
 

 Operator precedence determines how operators are parsed concerning each other. Operators with higher precedence become the operands of operators with lower precedence.

 
 
 
 
 
 

## Try it 

 
 
 

```
console.log(3 + 4 * 5); // 3 + 20
// Expected output: 23

console.log(4 * 3 ** 2); // 4 * 9
// Expected output: 36

let a;
let b;

console.log((a = b = 5));
// Expected output: 5
```

 
 
 

## Precedence and associativity 

 
 

Consider an expression describable by the representation below, where both `OP1` and `OP2` are fill-in-the-blanks for OPerators.



```
a OP1 b OP2 c
```



The combination above has two possible interpretations:



```
(a OP1 b) OP2 c
a OP1 (b OP2 c)
```



Which one the language decides to adopt depends on the identity of `OP1` and `OP2`.

If `OP1` and `OP2` have different precedence levels (see the table below), the operator with the higher precedence goes first and associativity does not matter. Observe how multiplication has higher precedence than addition and executed first, even though addition is written first in the code.

 js 

```
console.log(3 + 10 * 2); // 23
console.log(3 + (10 * 2)); // 23, because parentheses here are superfluous
console.log((3 + 10) * 2); // 26, because the parentheses change the order
```

 

Within operators of the same precedence, the language groups them by associativity . Left-associativity (left-to-right) means that it is interpreted as `(a OP1 b) OP2 c`, while right-associativity (right-to-left) means it is interpreted as `a OP1 (b OP2 c)`. Assignment operators are right-associative, so you can write:

 js 

```
a = b = 5; // same as writing a = (b = 5);
```

 

with the expected result that `a` and `b` get the value 5. This is because the assignment operator returns the value that is assigned. First, `b` is set to 5. Then the `a` is also set to 5 — the return value of `b = 5`, a.k.a. right operand of the assignment.

As another example, the unique exponentiation operator has right-associativity, whereas other arithmetic operators have left-associativity.

 js 

```
const a = 4 ** 3 ** 2; // Same as 4 ** (3 ** 2); evaluates to 262144
const b = 4 / 3 / 2; // Same as (4 / 3) / 2; evaluates to 0.6666...
```

 

Operators are first grouped by precedence, and then, for adjacent operators that have the same precedence, by associativity. So, when mixing division and exponentiation, the exponentiation always comes before the division. For example, `2 ** 3 / 3 ** 2` results in 0.8888888888888888 because it is the same as `(2 ** 3) / (3 ** 2)`.

For prefix unary operators, suppose we have the following pattern:



```
OP1 a OP2 b
```



where `OP1` is a prefix unary operator and `OP2` is a binary operator. If `OP1` has higher precedence than `OP2`, then it would be grouped as `(OP1 a) OP2 b`; otherwise, it would be `OP1 (a OP2 b)`.

 js 

```
const a = 1;
const b = 2;
typeof a + b; // Equivalent to (typeof a) + b; result is "number2"
```

 

If the unary operator is on the second operand:



```
a OP2 OP1 b
```



Then the binary operator `OP2` must have lower precedence than the unary operator `OP1` for it to be grouped as `a OP2 (OP1 b)`. For example, the following is invalid:

 js 

```
function* foo() {
  a + yield 1;
}
```

 

Because `+` has higher precedence than `yield` , this would become `(a + yield) 1` — but because `yield` is a reserved word in generator functions, this would be a syntax error. Luckily, most unary operators have higher precedence than binary operators and do not suffer from this pitfall.

If we have two prefix unary operators:



```
OP1 OP2 a
```



Then the unary operator closer to the operand, `OP2`, must have higher precedence than `OP1` for it to be grouped as `OP1 (OP2 a)`. It's possible to get it the other way and end up with `(OP1 OP2) a`:

 js 

```
async function* foo() {
  await yield 1;
}
```

 

Because `await` has higher precedence than `yield` , this would become `(await yield) 1`, which is awaiting an identifier called `yield`, and a syntax error. Similarly, if you have `new !A;`, because `!` has lower precedence than `new`, this would become `(new !) A`, which is obviously invalid. (This code looks nonsensical to write anyway, since `!A` always produces a boolean, not a constructor function.)

For postfix unary operators (namely, `++` and `--`), the same rules apply. Luckily, both operators have higher precedence than any binary operator, so the grouping is always what you would expect. Moreover, because `++` evaluates to a value , not a reference , you can't chain multiple increments together either, as you may do in C.

 js 

```
let a = 1;
a++++; // SyntaxError: Invalid left-hand side in postfix operation.
```

 

Operator precedence will be handled recursively . For example, consider this expression:

 js 

```
1 + 2 ** 3 * 4 / 5 >> 6
```

 

First, we group operators with different precedence by decreasing levels of precedence.

- The `**` operator has the highest precedence, so it's grouped first.

- Looking around the `**` expression, it has `*` on the right and `+` on the left. `*` has higher precedence, so it's grouped first. `*` and `/` have the same precedence, so we group them together for now.

- Looking around the `*`/`/` expression grouped in 2, because `+` has higher precedence than `>>`, the former is grouped.

 js 

```
   (1 + ( (2 ** 3) * 4 / 5) ) >> 6
// │    │ └─ 1. ─┘        │ │
// │    └────── 2. ───────┘ │
// └────────── 3. ──────────┘
```

 

Within the `*`/`/` group, because they are both left-associative, the left operand would be grouped.

 js 

```
   (1 + ( ( (2 ** 3) * 4 ) / 5) ) >> 6
// │    │ │ └─ 1. ─┘     │    │ │
// │    └─│─────── 2. ───│────┘ │
// └──────│───── 3. ─────│──────┘
//        └───── 4. ─────┘
```

 

Note that operator precedence and associativity only affect the order of evaluation of operators (the implicit grouping), but not the order of evaluation of operands . The operands are always evaluated from left-to-right. The higher-precedence expressions are always evaluated first, and their results are then composed according to the order of operator precedence.

 js 

```
function echo(name, num) {
  console.log(`Evaluating the ${name} side`);
  return num;
}
// Exponentiation operator (**) is right-associative,
// but all call expressions (echo()), which have higher precedence,
// will be evaluated before ** does
console.log(echo("left", 4) ** echo("middle", 3) ** echo("right", 2));
// Evaluating the left side
// Evaluating the middle side
// Evaluating the right side
// 262144

// Exponentiation operator (**) has higher precedence than division (/),
// but evaluation always starts with the left operand
console.log(echo("left", 4) / echo("middle", 3) ** echo("right", 2));
// Evaluating the left side
// Evaluating the middle side
// Evaluating the right side
// 0.4444444444444444
```

 

If you are familiar with binary trees, think about it as a post-order traversal .



```
                /
       ┌────────┴────────┐
echo("left", 4)         **
                ┌────────┴────────┐
        echo("middle", 3)  echo("right", 2)
```



After all operators have been properly grouped, the binary operators would form a binary tree. Evaluation starts from the outermost group — which is the operator with the lowest precedence (`/` in this case). The left operand of this operator is first evaluated, which may be composed of higher-precedence operators (such as a call expression `echo("left", 4)`). After the left operand has been evaluated, the right operand is evaluated in the same fashion. Therefore, all leaf nodes — the `echo()` calls — would be visited left-to-right, regardless of the precedence of operators joining them.

 
 

## Short-circuiting 

 
 

In the previous section, we said "the higher-precedence expressions are always evaluated first" — this is generally true, but it has to be amended with the acknowledgement of short-circuiting , in which case an operand may not be evaluated at all.

Short-circuiting is jargon for conditional evaluation. For example, in the expression `a && (b + c)`, if `a` is falsy , then the sub-expression `(b + c)` will not even get evaluated, even if it is grouped and therefore has higher precedence than `&&`. We could say that the logical AND operator (`&&`) is "short-circuited". Along with logical AND, other short-circuited operators include logical OR (`||`), nullish coalescing (`??`), and optional chaining (`?.`).

 js 

```
a || (b * c); // evaluate `a` first, then produce `a` if `a` is "truthy"
a && (b < c); // evaluate `a` first, then produce `a` if `a` is "falsy"
a ?? (b || c); // evaluate `a` first, then produce `a` if `a` is not `null` and not `undefined`
a?.b.c; // evaluate `a` first, then produce `undefined` if `a` is `null` or `undefined`
```

 

When evaluating a short-circuited operator, the left operand is always evaluated. The right operand will only be evaluated if the left operand cannot determine the result of the operation.

 

 Note: 
The behavior of short-circuiting is baked in these operators. Other operators would always evaluate both operands, regardless if that's actually useful — for example, `NaN * foo()` will always call `foo`, even when the result would never be something other than `NaN`.

 

The previous model of a post-order traversal still stands. However, after the left subtree of a short-circuiting operator has been visited, the language will decide if the right operand needs to be evaluated. If not (for example, because the left operand of `||` is already truthy), the result is directly returned without visiting the right subtree.

Consider this case:

 js 

```
function A() { console.log('called A'); return false; }
function B() { console.log('called B'); return false; }
function C() { console.log('called C'); return true; }

console.log(C() || B() && A());

// Logs:
// called C
// true
```

 

Only `C()` is evaluated, despite `&&` having higher precedence. This does not mean that `||` has higher precedence in this case — it's exactly because `(B() && A())` has higher precedence that causes it to be neglected as a whole. If it's re-arranged as:

 js 

```
console.log(A() && B() || C());
// Logs:
// called A
// called C
// true
```

 

Then the short-circuiting effect of `&&` would only prevent `B()` from being evaluated, but because `A() && B()` as a whole is `false`, `C()` would still be evaluated.

However, note that short-circuiting does not change the final evaluation outcome. It only affects the evaluation of operands , not how operators are grouped — if evaluation of operands doesn't have side effects (for example, logging to the console, assigning to variables, throwing an error), short-circuiting would not be observable at all.

The assignment counterparts of these operators ( `&&=` , `||=` , `??=` ) are short-circuited as well. They are short-circuited in a way that the assignment does not happen at all.

 
 

## Table 

 
 

The following table lists operators in order from highest precedence (18) to lowest precedence (1).

Several general notes about the table:

- Not all syntax included here are "operators" in the strict sense. For example, spread `...` and arrow `=>` are typically not regarded as operators. However, we still included them to show how tightly they bind compared to other operators/expressions.

- Some operators have certain operands that require expressions narrower than those produced by higher-precedence operators. For example, the right-hand side of member access `.` (precedence 17) must be an identifier instead of a grouped expression. The left-hand side of arrow `=>` (precedence 2) must be an arguments list or a single identifier instead of some random expression.

- Some operators have certain operands that accept expressions wider than those produced by higher-precedence operators. For example, the bracket-enclosed expression of bracket notation `[ … ]` (precedence 17) can be any expression, even comma (precedence 1) joined ones. These operators act as if that operand is "automatically grouped". In this case we will omit the associativity.

 
 
 
 Precedence 
 Associativity 
 Individual operators 
 Notes 
 
 
 18: grouping 
 n/a 
 Grouping 
`(x)` 
 [1] 
 
 
 17: access and call 
 
 left-to-right
 
 Member access 
`x.y` 
 [2] 
 
 
 Optional chaining 
`x?.y` 
 
 
 n/a 
 
 Computed member access 
`x[y]`
 
 [3] 
 
 
 `new` with argument list
`new x(y)` 
 [4] 
 
 
 
 Function call 
`x(y)`
 
 
 
 `import(x)` 
 
 
 16: new 
 n/a 
 `new` without argument list
`new x` 
 
 
 15: postfix operators 
 n/a 
 
 Postfix increment 
`x++`
 
 [5] 
 
 
 
 Postfix decrement 
`x--`
 
 
 
 14: prefix operators 
 n/a 
 
 Prefix increment 
`++x`
 
 [6] 
 
 
 
 Prefix decrement 
`--x`
 
 
 
 
 Logical NOT 
`!x`
 
 
 
 
 Bitwise NOT 
`~x`
 
 
 
 
 Unary plus 
`+x`
 
 
 
 
 Unary negation 
`-x`
 
 
 
 `typeof x` 
 
 
 `void x` 
 
 
 `delete x` 
 [7] 
 
 
 `await x` 
 
 
 13: exponentiation 
 right-to-left 
 
 Exponentiation 
`x ** y`
 
 [8] 
 
 
 12: multiplicative operators 
 left-to-right 
 
 Multiplication 
`x * y`
 
 
 
 
 Division 
`x / y`
 
 
 
 
 Remainder 
`x % y`
 
 
 
 11: additive operators 
 left-to-right 
 
 Addition 
`x + y`
 
 
 
 
 Subtraction 
`x - y`
 
 
 
 10: bitwise shift 
 left-to-right 
 
 Left shift 
`x 
 
 
 
 Right shift 
`x >> y`
 
 
 
 
 Unsigned right shift 
`x >>> y`
 
 
 
 9: relational operators 
 left-to-right 
 
 Less than 
`x 
 
 
 
 Less than or equal 
`x 
 
 
 
 Greater than 
`x > y`
 
 
 
 
 Greater than or equal 
`x >= y`
 
 
 
 `x in y` 
 
 
 `x instanceof y` 
 
 
 8: equality operators 
 left-to-right 
 
 Equality 
`x == y`
 
 
 
 
 Inequality 
`x != y`
 
 
 
 
 Strict equality 
`x === y`
 
 
 
 
 Strict inequality 
`x !== y`
 
 
 
 7: bitwise AND 
 left-to-right 
 
 Bitwise AND 
`x & y`
 
 
 
 6: bitwise XOR 
 left-to-right 
 
 Bitwise XOR 
`x ^ y`
 
 
 
 5: bitwise OR 
 left-to-right 
 
 Bitwise OR 
`x | y`
 
 
 
 4: logical AND 
 left-to-right 
 
 Logical AND 
`x && y`
 
 
 
 3: logical OR, nullish coalescing 
 left-to-right 
 
 Logical OR 
`x || y`
 
 
 
 
 Nullish coalescing operator 
`x ?? y`
 
 [9] 
 
 
 2: assignment and miscellaneous 
 right-to-left 
 
 Assignment 
`x = y`
 
 [10] 
 
 
 
 Addition assignment 
`x += y`
 
 
 
 
 Subtraction assignment 
`x -= y`
 
 
 
 
 Exponentiation assignment 
`x **= y`
 
 
 
 
 Multiplication assignment 
`x *= y`
 
 
 
 
 Division assignment 
`x /= y`
 
 
 
 
 Remainder assignment 
`x %= y`
 
 
 
 
 Left shift assignment 
`x 
 
 
 
 Right shift assignment 
`x >>= y`
 
 
 
 
 Unsigned right shift assignment 
`x >>>= y`
 
 
 
 
 Bitwise AND assignment 
`x &= y`
 
 
 
 
 Bitwise XOR assignment 
`x ^= y`
 
 
 
 
 Bitwise OR assignment 
`x |= y`
 
 
 
 
 Logical AND assignment 
`x &&= y`
 
 
 
 
 Logical OR assignment 
`x ||= y`
 
 
 
 
 Nullish coalescing assignment 
`x ??= y`
 
 
 
 right-to-left 
 
 Conditional (ternary) operator 
`x ? y : z`
 
 [11] 
 
 
 right-to-left 
 
 Arrow 
`x => y`
 
 [12] 
 
 
 n/a 
 `yield x` 
 
 
 `yield* x` 
 
 
 
 Spread 
`...x`
 
 [13] 
 
 
 1: comma 
 left-to-right 
 
 Comma operator 
`x, y`
 
 
 
 

Notes:

- The operand can be any expression.

- The "right-hand side" must be an identifier.

- The "right-hand side" can be any expression.

- The "right-hand side" is a comma-separated list of any expression with precedence > 1 (i.e., not comma expressions). The constructor of a `new` expression cannot be an optional chain.

- The operand must be a valid assignment target (identifier or property access). Its precedence means `new Foo++` is `(new Foo)++` (a syntax error) and not `new (Foo++)` (a TypeError: (Foo++) is not a constructor).

- The operand must be a valid assignment target (identifier or property access).

- The operand cannot be an identifier or a private element access.

- The left-hand side cannot have precedence 14.

- The operands cannot be a logical OR `||` or logical AND `&&` operator without grouping.

- The "left-hand side" must be a valid assignment target (identifier or property access).

- The associativity means the two expressions after `?` are implicitly grouped.

- The "left-hand side" is a single identifier or a parenthesized parameter list.

- Only valid inside object literals, array literals, or argument lists.

The precedence of groups 17 and 16 may be a bit ambiguous. Here are a few examples to clarify.

- Optional chaining is always substitutable for its respective syntax without optionality (barring a few special cases where optional chaining is forbidden). For example, any place that accepts `a?.b` also accepts `a.b` and vice versa, and similarly for `a?.()`, `a()`, etc.

- Member expressions and computed member expressions are always substitutable for each other.

- Call expressions and `import()` expressions are always substitutable for each other.

- This leaves four classes of expressions: member access, `new` with arguments, function call, and `new` without arguments.

 The "left-hand side" of a member access can be: a member access (`a.b.c`), `new` with arguments (`new a().b`), and function call (`a().b`).

- The "left-hand side" of `new` with arguments can be: a member access (`new a.b()`) and `new` with arguments (`new new a()()`).

- The "left-hand side" of a function call can be: a member access (`a.b()`), `new` with arguments (`new a()()`), and function call (`a()()`).

- The operand of `new` without arguments can be: a member access (`new a.b`), `new` with arguments (`new new a()`), and `new` without arguments (`new new a`).

 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 22, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#statements_and_declarations_by_category

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#difference_between_statements_and_declarations

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#browser_compatibility

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#see_also

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Statements and declarations - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements#control_flow

Statements and declarations - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Statements and declarations

 
 
 

JavaScript applications consist of statements with an appropriate syntax. A single statement may span multiple lines. Multiple statements may occur on a single line if each statement is separated by a semicolon. This isn't a keyword, but a group of keywords.

 
 
 
 
 
 

## Statements and declarations by category 

 
 

For an alphabetical listing see the sidebar on the left.

 
 

### Control flow 

 
 
 `return` 
 

Specifies the value to be returned by a function.

 
 `break` 
 

Terminates the current loop, switch, or label statement and transfers program control to the statement following the terminated statement.

 
 `continue` 
 

Terminates execution of the statements in the current iteration of the current or labeled loop, and continues execution of the loop with the next iteration.

 
 `throw` 
 

Throws a user-defined exception.

 
 `if...else` 
 

Executes a statement if a specified condition is true. If the condition is false, another statement can be executed.

 
 `switch` 
 

Evaluates an expression, matching the expression's value to a case clause, and executes statements associated with that case.

 
 `try...catch` 
 

Marks a block of statements to try, and specifies a response, should an exception be thrown.

 
 
 
 

### Declaring variables 

 
 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block scope local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a read-only named constant.

 
 `using` 
 

Declares local variables that are synchronously disposed .

 
 `await using` 
 

Declares local variables that are asynchronously disposed .

 
 
 
 

### Functions and classes 

 
 
 `function` 
 

Declares a function with the specified parameters.

 
 `function*` 
 

Generator Functions enable writing iterators more easily.

 
 `async function` 
 

Declares an async function with the specified parameters.

 
 `async function*` 
 

Asynchronous Generator Functions enable writing async iterators more easily.

 
 `class` 
 

Declares a class.

 
 
 
 

### Iterations 

 
 
 `do...while` 
 

Creates a loop that executes a specified statement until the test condition evaluates to false. The condition is evaluated after executing the statement, resulting in the specified statement executing at least once.

 
 `for` 
 

Creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement executed in the loop.

 
 `for...in` 
 

Iterates over the enumerable properties of an object, in arbitrary order. For each distinct property, statements can be executed.

 
 `for...of` 
 

Iterates over iterable objects (including arrays , array-like objects, iterators and generators ), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `for await...of` 
 

Iterates over async iterable objects, array-like objects, iterators and generators , invoking a custom iteration hook with statements to be executed for the value of each distinct property.

 
 `while` 
 

Creates a loop that executes a specified statement as long as the test condition evaluates to true. The condition is evaluated before executing the statement.

 
 
 
 

### Others 

 
 
 Empty 
 

An empty statement is used to provide no statement, although the JavaScript syntax would expect one.

 
 Block 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of curly braces.

 
 Expression statement 
 

An expression statement evaluates an expression and discards its result. It allows the expression to perform side effects, such as executing a function or updating a variable.

 
 `debugger` 
 

Invokes any available debugging functionality. If no debugging functionality is available, this statement has no effect.

 
 `export` 
 

Used to export functions to make them available for imports in external modules, and other scripts.

 
 `import` 
 

Used to import functions exported from an external module, another script.

 
 label 
 

Provides a statement with an identifier that you can refer to using a `break` or `continue` statement.

 
 `with` 
 Deprecated 
 
 

Extends the scope chain for a statement.

 
 
 
 

## Difference between statements and declarations 

 
 

In this section, we will be mixing two kinds of constructs: statements and declarations . They are two disjoint sets of grammars. The following are declarations:

- `let` 

- `const` 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

- `export` (Note: it can only appear at the top-level of a module )

- `import` (Note: it can only appear at the top-level of a module )

Everything else in the list above is a statement.

The terms "statement" and "declaration" have a precise meaning in the formal syntax of JavaScript that affects where they may be placed in code. For example, in most control-flow structures, the body only accepts statements — such as the two arms of an `if...else` :

 js 

```
if (condition)
  statement1;
else
  statement2;
```

 

If you use a declaration instead of a statement, it would be a `SyntaxError` . For example, a `let` declaration is not a statement, so you can't use it in its bare form as the body of an `if` statement.

 js 

```
if (condition)
  let i = 0; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

On the other hand, `var` is a statement, so you can use it on its own as the `if` body.

 js 

```
if (condition)
  var i = 0;
```

 

You can see declarations as " binding identifiers to values", and statements as "carrying out actions". The fact that `var` is a statement instead of a declaration is a special case, because it doesn't follow normal lexical scoping rules and may create side effects — in the form of creating global variables, mutating existing `var`-defined variables, and defining variables that are visible outside of its block (because `var`-defined variables aren't block-scoped).

As another example, labels can only be attached to statements.

 js 

```
label: const a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 
 

 Note: 
There's a legacy grammar that allows function declarations to have labels , but it's only standardized for compatibility with web reality.

 

To get around this, you can wrap the declaration in braces — this makes it part of a block statement .

 js 

```
label: {
  const a = 1;
}

if (condition) {
  let i = 0;
}
```

 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Expressions and operators 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### return - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return

return - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# return

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `return` statement ends function execution and specifies a value to be returned to the function caller.

 
 
 
 
 
 

## Try it 

 
 
 

```
function getRectArea(width, height) {
  if (width > 0 && height > 0) {
    return width * height;
  }
  return 0;
}

console.log(getRectArea(3, 4));
// Expected output: 12

console.log(getRectArea(-3, 4));
// Expected output: 0
```

 
 
 

## Syntax 

 
 js 

```
return;
return expression;
```

 
 
 `expression` Optional 
 

The expression whose value is to be returned. If omitted, `undefined` is returned.

 
 
 
 

## Description 

 
 

The `return` statement can only be used within function bodies. When a `return` statement is used in a function body, the execution of the function is stopped. The `return` statement has different effects when placed in different functions:

- In a plain function, the call to that function evaluates to the return value.

- In an async function, the produced promise is resolved with the returned value.

- In a generator function, the produced generator object's `next()` method returns `{ done: true, value: returnedValue }`.

- In an async generator function, the produced async generator object's `next()` method returns a promise fulfilled with `{ done: true, value: returnedValue }`.

If a `return` statement is executed within a `try` block, its `finally` block, if present, is first executed, before the value is actually returned.

 
 

### Automatic semicolon insertion 

 
 

The syntax forbids line terminators between the `return` keyword and the expression to be returned.

 js 

```
return
a + b;
```

 

The code above is transformed by automatic semicolon insertion (ASI) into:

 js 

```
return;
a + b;
```

 

This makes the function return `undefined` and the `a + b` expression is never evaluated. This may generate a warning in the console .

To avoid this problem (to prevent ASI), you could use parentheses:

 js 

```
return (
  a + b
);
```

 
 
 

## Examples 

 
 
 
 

### Interrupt a function 

 
 

A function immediately stops at the point where `return` is called.

 js 

```
function counter() {
  // Infinite loop
  for (let count = 1; ; count++) {
    console.log(`${count}A`); // Until 5
    if (count === 5) {
      return;
    }
    console.log(`${count}B`); // Until 4
  }
  console.log(`${count}C`); // Never appears
}

counter();

// Logs:
// 1A
// 1B
// 2A
// 2B
// 3A
// 3B
// 4A
// 4B
// 5A
```

 
 
 

### Returning a function 

 
 

See also the article about Closures .

 js 

```
function magic() {
  return function calc(x) {
    return x * 42;
  };
}

const answer = magic();
answer(1337); // 56154
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-return-statement 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions 

- Closures 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Using classes - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes#content

Using classes - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Using classes

 
 
 
- Previous 
- Next 

JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes , the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.

In many other languages, classes , or constructors, are clearly distinguished from objects , or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the `new` operator with a constructor function to create a new object.

We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.

This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.

 
 
 
 
 
 

## Overview of classes 

 
 

If you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you :

 js 

```
const bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}
```

 

On the first line, we created an instance of the class `Date` , and called it `bigDay`. On the second line, we called a method `toLocaleDateString()` on the `bigDay` instance, which returns a string. Then, we compared two numbers: one returned from the `getTime()` method, the other directly called from the `Date` class itself , as `Date.now()` .

`Date` is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

- Classes create objects through the `new` operator.

- Each object has some properties (data or method) added by the class.

- The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

- Constructor;

- Instance methods and instance fields;

- Static methods and static fields.

 
 

## Declaring a class 

 
 

Classes are usually created with class declarations .

 js 

```
class MyClass {
  // class body...
}
```

 

Within a class body, there are a range of features available.

 js 

```
class MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}
```

 

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:

 js 

```
function MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();
```

 
 

 Note: 
Private fields and methods are new features in classes with no trivial equivalent in function constructors.

 
 
 

### Constructing a class 

 
 

After a class has been declared, you can create instances of it using the `new` operator.

 js 

```
const myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();
```

 

Typical function constructors can both be constructed with `new` and called without `new`. However, attempting to "call" a class without `new` will result in an error.

 js 

```
const myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
```

 
 
 

### Class declaration hoisting 

 
 

Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.

 js 

```
new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}
```

 

This behavior is similar to variables declared with `let` and `const` .

 
 

### Class expressions 

 
 

Similar to functions, class declarations also have their expression counterparts.

 js 

```
const MyClass = class {
  // Class body...
};
```

 

Class expressions can have names as well. The expression's name is only visible to the class's body.

 js 

```
const MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
```

 
 
 

## Constructor 

 
 

Perhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the `Date` constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor .

As an example, we would create a class called `Color`, which represents a specific color. Users create colors through passing in an RGB triplet.

 js 

```
class Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}
```

 

Open your browser's devtools, paste the above code into the console, and then create an instance:

 js 

```
const red = new Color(255, 0, 0);
console.log(red);
```

 

You should see some output like this:



```
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]
```



You have successfully created a `Color` instance, and the instance has a `values` property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:

 js 

```
function createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}
```

 

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters :

 js 

```
class Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.
```

 

Each time you call `new`, a different instance is created.

 js 

```
const red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false
```

 

Within a class constructor, the value of `this` points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).

The `this` value will be automatically returned as the result of `new`. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the `new` expression, and the value of `this` is dropped. (You can read more about what `new` does in its description .)

 js 

```
class MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
```

 
 
 

## Instance methods 

 
 

If a class only has a constructor, it is not much different from a `createX` factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.

For example, for `Date` instances, you can use a range of methods to get different information from a single date value, such as the year , month , day of the week , etc. You can also set those values through the `setX` counterparts like `setFullYear` .

For our own `Color` class, we can add a method called `getRed` which returns the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Without methods, you may be tempted to define the function within the constructor:

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}
```

 

This also works. However, a problem is that this creates a new function every time a `Color` instance is created, even when they all do the same thing!

 js 

```
console.log(new Color().getRed === new Color().getRed); // false
```

 

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of `this` is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or `Color.prototype`, which is explained in more detail in Inheritance and the prototype chain .

Similarly, we can create a new method called `setRed`, which sets the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
```

 
 
 

## Private fields 

 
 

You might be wondering: why do we want to go to the trouble of using `getRed` and `setRed` methods, when we can directly access the `values` array on the instance?

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0
```

 

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:

 js 

```
class Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0
```

 

The user assumption that `values` means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields .

A private field is an identifier prefixed with `#` (the hash symbol). The hash is an integral part of the field's name, which means a private field can never have name clash with a public field or method. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private element on the fly). Apart from this, a private field is pretty much equivalent to a normal property.

 js 

```
class Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Accessing private fields outside the class is an early syntax error. The language can guard against this because `#privateField` is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.

 js 

```
console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
```

 
 

 Note: 
Code run in the Chrome console can access private elements outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

 

Private fields in JavaScript are hard private : if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.

After we've made the `values` field private, we can add some more logic in the `getRed` and `setRed` methods, instead of making them simple pass-through methods. For example, we can add a check in `setRed` to see if it's a valid R value:

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value
```

 

If we leave the `values` property exposed, our users can easily circumvent that check by assigning to `values[0]` directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.

A class method can read the private fields of other instances, as long as they belong to the same class.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35
```

 

However, if `anotherColor` is not a Color instance, `#values` won't exist. (Even if another class has an identically named `#values` private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private element throws an error instead of returning `undefined` like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using `try`/`catch` to handle the error, you can use the `in` operator.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}
```

 
 

 Note: 
Keep in mind that the `#` is a special identifier syntax, and you can't use the field name as if it's a string. `"#values" in anotherColor` would look for a property name literally called `"#values"`, instead of a private field.

 

There are some limitations in using private elements: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.

 js 

```
class BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}
```

 

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.

For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.

 js 

```
class Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);
```

 

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of `Counter`.

 
 

## Accessor fields 

 
 

`color.getRed()` and `color.setRed()` allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0
```

 

It looks as if the object has a property called `red` — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with `get` and `set`, which allows them to be manipulated as if they were properties.

If a field only has a getter but no setter, it will be effectively read-only.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255
```

 

In strict mode , the `red.red = 0` line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.

 
 

## Public fields 

 
 

Private fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.

 js 

```
class MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3
```

 

Public fields are almost equivalent to assigning a property to `this`. For example, the above example can also be converted to:

 js 

```
class MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
```

 
 
 

## Static properties 

 
 

With the `Date` example, we have also encountered the `Date.now()` method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the `Date` class instead of being exposed as a global `DateNow()` function, because it's mostly useful when dealing with date instances.

 

 Note: 
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed `parseInt()` method, JavaScript also later added the prefixed `Number.parseInt()` method to indicate that it's for dealing with numbers.

 

 Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

- Static methods

- Static fields

- Static getters and setters

Everything also has private counterparts. For example, for our `Color` class, we can create a static method that checks whether a given triplet is a valid RGB value:

 js 

```
class Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false
```

 

Static properties are very similar to their instance counterparts, except that:

- They are all prefixed with `static`, and

- They are not accessible from instances.

 js 

```
console.log(new Color(0, 0, 0).isValid); // undefined
```

 

There is also a special construct called a static initialization block , which is a block of code that runs when the class is first loaded.

 js 

```
class MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'
```

 

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private elements.

 
 

## Extends and inheritance 

 
 

A key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance , which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.

For example, suppose our `Color` class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:

 js 

```
class Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}
```

 

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our `Color` class will become very bloated and hard to maintain.

Instead, in object-oriented programming, we would create a derived class . The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an `extends` clause, which indicates the class it extends from.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}
```

 

There are a few things that have immediately come to attention. First is that in the constructor, we are calling `super(r, g, b)`. It is a language requirement to call `super()` before accessing `this`. The `super()` call calls the parent class's constructor to initialize `this` — here it's roughly equivalent to `this = new Color(r, g, b)`. You can have code before `super()`, but you cannot access `this` before `super()` — the language prevents you from accessing the uninitialized `this`.

After the parent class is done with modifying `this`, the derived class can do its own logic. Here we added a private field called `#alpha`, and also provided a pair of getter/setters to interact with them.

A derived class inherits all methods from its parent. For example, consider the `get red()` accessor we added to the `Color` in the Accessor fields section—even though we haven't declared one in `ColorWithAlpha`, we can still access `red` because this behavior is specified by the parent class:

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255
```

 

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the `Object` class, which defines some basic methods like `toString()` . However, the base `toString()` method is notoriously useless, because it prints `[object Object]` in most cases:

 js 

```
console.log(red.toString()); // [object Object]
```

 

Instead, our class can override it to print the color's RGB values:

 js 

```
class Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'
```

 

Within derived classes, you can access the parent class's methods by using `super`. This allows you to build enhancement methods and avoid code duplication.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'
```

 

When you use `extends`, the static methods inherit from each other as well, so you can also override or enhance them.

 js 

```
class ColorWithAlpha extends Color {
  // …
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false
```

 

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.

 js 

```
class ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}
```

 

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem . However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins .

Instances of derived classes are also instances of the base class.

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
```

 
 
 

## Why classes? 

 
 

The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.

Classes introduce a paradigm , or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism ). However, many people are philosophically against certain OOP practices and don't use classes as a result.

For example, one thing that makes `Date` objects infamous is that they're mutable .

 js 

```
function incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20
```

 

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.

In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

 

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.

On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the `Color` class, we may need to create a dozen of utility functions:

 js 

```
function isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// …
```

 

But with classes, we can congregate them all under the `Color` namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.

In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

- The `Map` and `Set` classes store a collection of elements and allow you to access them by key using `get()`, `set()`, `has()`, etc.

- The `Date` class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.

- The `Error` class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like `TypeError` and `ReferenceError` that extend `Error`. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with `instanceof` .

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 6, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Using classes - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes#search

Using classes - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Using classes

 
 
 
- Previous 
- Next 

JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes , the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.

In many other languages, classes , or constructors, are clearly distinguished from objects , or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the `new` operator with a constructor function to create a new object.

We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.

This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.

 
 
 
 
 
 

## Overview of classes 

 
 

If you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you :

 js 

```
const bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}
```

 

On the first line, we created an instance of the class `Date` , and called it `bigDay`. On the second line, we called a method `toLocaleDateString()` on the `bigDay` instance, which returns a string. Then, we compared two numbers: one returned from the `getTime()` method, the other directly called from the `Date` class itself , as `Date.now()` .

`Date` is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

- Classes create objects through the `new` operator.

- Each object has some properties (data or method) added by the class.

- The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

- Constructor;

- Instance methods and instance fields;

- Static methods and static fields.

 
 

## Declaring a class 

 
 

Classes are usually created with class declarations .

 js 

```
class MyClass {
  // class body...
}
```

 

Within a class body, there are a range of features available.

 js 

```
class MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}
```

 

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:

 js 

```
function MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();
```

 
 

 Note: 
Private fields and methods are new features in classes with no trivial equivalent in function constructors.

 
 
 

### Constructing a class 

 
 

After a class has been declared, you can create instances of it using the `new` operator.

 js 

```
const myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();
```

 

Typical function constructors can both be constructed with `new` and called without `new`. However, attempting to "call" a class without `new` will result in an error.

 js 

```
const myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
```

 
 
 

### Class declaration hoisting 

 
 

Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.

 js 

```
new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}
```

 

This behavior is similar to variables declared with `let` and `const` .

 
 

### Class expressions 

 
 

Similar to functions, class declarations also have their expression counterparts.

 js 

```
const MyClass = class {
  // Class body...
};
```

 

Class expressions can have names as well. The expression's name is only visible to the class's body.

 js 

```
const MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
```

 
 
 

## Constructor 

 
 

Perhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the `Date` constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor .

As an example, we would create a class called `Color`, which represents a specific color. Users create colors through passing in an RGB triplet.

 js 

```
class Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}
```

 

Open your browser's devtools, paste the above code into the console, and then create an instance:

 js 

```
const red = new Color(255, 0, 0);
console.log(red);
```

 

You should see some output like this:



```
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]
```



You have successfully created a `Color` instance, and the instance has a `values` property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:

 js 

```
function createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}
```

 

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters :

 js 

```
class Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.
```

 

Each time you call `new`, a different instance is created.

 js 

```
const red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false
```

 

Within a class constructor, the value of `this` points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).

The `this` value will be automatically returned as the result of `new`. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the `new` expression, and the value of `this` is dropped. (You can read more about what `new` does in its description .)

 js 

```
class MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
```

 
 
 

## Instance methods 

 
 

If a class only has a constructor, it is not much different from a `createX` factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.

For example, for `Date` instances, you can use a range of methods to get different information from a single date value, such as the year , month , day of the week , etc. You can also set those values through the `setX` counterparts like `setFullYear` .

For our own `Color` class, we can add a method called `getRed` which returns the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Without methods, you may be tempted to define the function within the constructor:

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}
```

 

This also works. However, a problem is that this creates a new function every time a `Color` instance is created, even when they all do the same thing!

 js 

```
console.log(new Color().getRed === new Color().getRed); // false
```

 

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of `this` is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or `Color.prototype`, which is explained in more detail in Inheritance and the prototype chain .

Similarly, we can create a new method called `setRed`, which sets the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
```

 
 
 

## Private fields 

 
 

You might be wondering: why do we want to go to the trouble of using `getRed` and `setRed` methods, when we can directly access the `values` array on the instance?

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0
```

 

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:

 js 

```
class Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0
```

 

The user assumption that `values` means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields .

A private field is an identifier prefixed with `#` (the hash symbol). The hash is an integral part of the field's name, which means a private field can never have name clash with a public field or method. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private element on the fly). Apart from this, a private field is pretty much equivalent to a normal property.

 js 

```
class Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Accessing private fields outside the class is an early syntax error. The language can guard against this because `#privateField` is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.

 js 

```
console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
```

 
 

 Note: 
Code run in the Chrome console can access private elements outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

 

Private fields in JavaScript are hard private : if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.

After we've made the `values` field private, we can add some more logic in the `getRed` and `setRed` methods, instead of making them simple pass-through methods. For example, we can add a check in `setRed` to see if it's a valid R value:

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value
```

 

If we leave the `values` property exposed, our users can easily circumvent that check by assigning to `values[0]` directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.

A class method can read the private fields of other instances, as long as they belong to the same class.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35
```

 

However, if `anotherColor` is not a Color instance, `#values` won't exist. (Even if another class has an identically named `#values` private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private element throws an error instead of returning `undefined` like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using `try`/`catch` to handle the error, you can use the `in` operator.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}
```

 
 

 Note: 
Keep in mind that the `#` is a special identifier syntax, and you can't use the field name as if it's a string. `"#values" in anotherColor` would look for a property name literally called `"#values"`, instead of a private field.

 

There are some limitations in using private elements: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.

 js 

```
class BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}
```

 

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.

For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.

 js 

```
class Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);
```

 

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of `Counter`.

 
 

## Accessor fields 

 
 

`color.getRed()` and `color.setRed()` allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0
```

 

It looks as if the object has a property called `red` — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with `get` and `set`, which allows them to be manipulated as if they were properties.

If a field only has a getter but no setter, it will be effectively read-only.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255
```

 

In strict mode , the `red.red = 0` line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.

 
 

## Public fields 

 
 

Private fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.

 js 

```
class MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3
```

 

Public fields are almost equivalent to assigning a property to `this`. For example, the above example can also be converted to:

 js 

```
class MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
```

 
 
 

## Static properties 

 
 

With the `Date` example, we have also encountered the `Date.now()` method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the `Date` class instead of being exposed as a global `DateNow()` function, because it's mostly useful when dealing with date instances.

 

 Note: 
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed `parseInt()` method, JavaScript also later added the prefixed `Number.parseInt()` method to indicate that it's for dealing with numbers.

 

 Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

- Static methods

- Static fields

- Static getters and setters

Everything also has private counterparts. For example, for our `Color` class, we can create a static method that checks whether a given triplet is a valid RGB value:

 js 

```
class Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false
```

 

Static properties are very similar to their instance counterparts, except that:

- They are all prefixed with `static`, and

- They are not accessible from instances.

 js 

```
console.log(new Color(0, 0, 0).isValid); // undefined
```

 

There is also a special construct called a static initialization block , which is a block of code that runs when the class is first loaded.

 js 

```
class MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'
```

 

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private elements.

 
 

## Extends and inheritance 

 
 

A key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance , which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.

For example, suppose our `Color` class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:

 js 

```
class Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}
```

 

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our `Color` class will become very bloated and hard to maintain.

Instead, in object-oriented programming, we would create a derived class . The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an `extends` clause, which indicates the class it extends from.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}
```

 

There are a few things that have immediately come to attention. First is that in the constructor, we are calling `super(r, g, b)`. It is a language requirement to call `super()` before accessing `this`. The `super()` call calls the parent class's constructor to initialize `this` — here it's roughly equivalent to `this = new Color(r, g, b)`. You can have code before `super()`, but you cannot access `this` before `super()` — the language prevents you from accessing the uninitialized `this`.

After the parent class is done with modifying `this`, the derived class can do its own logic. Here we added a private field called `#alpha`, and also provided a pair of getter/setters to interact with them.

A derived class inherits all methods from its parent. For example, consider the `get red()` accessor we added to the `Color` in the Accessor fields section—even though we haven't declared one in `ColorWithAlpha`, we can still access `red` because this behavior is specified by the parent class:

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255
```

 

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the `Object` class, which defines some basic methods like `toString()` . However, the base `toString()` method is notoriously useless, because it prints `[object Object]` in most cases:

 js 

```
console.log(red.toString()); // [object Object]
```

 

Instead, our class can override it to print the color's RGB values:

 js 

```
class Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'
```

 

Within derived classes, you can access the parent class's methods by using `super`. This allows you to build enhancement methods and avoid code duplication.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'
```

 

When you use `extends`, the static methods inherit from each other as well, so you can also override or enhance them.

 js 

```
class ColorWithAlpha extends Color {
  // …
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false
```

 

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.

 js 

```
class ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}
```

 

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem . However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins .

Instances of derived classes are also instances of the base class.

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
```

 
 
 

## Why classes? 

 
 

The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.

Classes introduce a paradigm , or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism ). However, many people are philosophically against certain OOP practices and don't use classes as a result.

For example, one thing that makes `Date` objects infamous is that they're mutable .

 js 

```
function incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20
```

 

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.

In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

 

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.

On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the `Color` class, we may need to create a dozen of utility functions:

 js 

```
function isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// …
```

 

But with classes, we can congregate them all under the `Color` namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.

In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

- The `Map` and `Set` classes store a collection of elements and allow you to access them by key using `get()`, `set()`, `has()`, etc.

- The `Date` class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.

- The `Error` class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like `TypeError` and `ReferenceError` that extend `Error`. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with `instanceof` .

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 6, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Using promises - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises

Using promises - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Using promises

 
 
 
- Previous 
- Next 

A `Promise` is an object representing the eventual completion or failure of an asynchronous operation. Since most people are consumers of already-created promises, this guide will explain consumption of returned promises before explaining how to create them.

Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function. Imagine a function, `createAudioFileAsync()`, which asynchronously generates a sound file given a configuration record and two callback functions: one called if the audio file is successfully created, and the other called if an error occurs.

Here's some code that uses `createAudioFileAsync()`:

 js 

```
function successCallback(result) {
  console.log(`Audio file ready at URL: ${result}`);
}

function failureCallback(error) {
  console.error(`Error generating audio file: ${error}`);
}

createAudioFileAsync(audioSettings, successCallback, failureCallback);
```

 

If `createAudioFileAsync()` were rewritten to return a promise, you would attach your callbacks to it instead:

 js 

```
createAudioFileAsync(audioSettings).then(successCallback, failureCallback);
```

 

This convention has several advantages. We will explore each one.

 
 
 
 
 
 

## Chaining 

 
 

A common need is to execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step. In the old days, doing several asynchronous operations in a row would lead to the classic callback hell :

 js 

```
doSomething(function (result) {
  doSomethingElse(result, function (newResult) {
    doThirdThing(newResult, function (finalResult) {
      console.log(`Got the final result: ${finalResult}`);
    }, failureCallback);
  }, failureCallback);
}, failureCallback);
```

 

With promises, we accomplish this by creating a promise chain. The API design of promises makes this great, because callbacks are attached to the returned promise object, instead of being passed into a function.

Here's the magic: the `then()` function returns a new promise , different from the original:

 js 

```
const promise = doSomething();
const promise2 = promise.then(successCallback, failureCallback);
```

 

This second promise (`promise2`) represents the completion not just of `doSomething()`, but also of the `successCallback` or `failureCallback` you passed in — which can be other asynchronous functions returning a promise. When that's the case, any callbacks added to `promise2` get queued behind the promise returned by either `successCallback` or `failureCallback`.

 

 Note: 
If you want a working example to play with, you can use the following template to create any function returning a promise:

 js 

```
function doSomething() {
  return new Promise((resolve) => {
    setTimeout(() => {
      // Other things to do before completion of the promise
      console.log("Did something");
      // The fulfillment value of the promise
      resolve("https://example.com/");
    }, 200);
  });
}
```

 

The implementation is discussed in the Creating a Promise around an old callback API section below.

 

With this pattern, you can create longer chains of processing, where each promise represents the completion of one asynchronous step in the chain. In addition, the arguments to `then` are optional, and `catch(failureCallback)` is short for `then(null, failureCallback)` — so if your error handling code is the same for all steps, you can attach it to the end of the chain:

 js 

```
doSomething()
  .then(function (result) {
    return doSomethingElse(result);
  })
  .then(function (newResult) {
    return doThirdThing(newResult);
  })
  .then(function (finalResult) {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);
```

 

You might see this expressed with arrow functions instead:

 js 

```
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => {
    console.log(`Got the final result: ${finalResult}`);
  })
  .catch(failureCallback);
```

 
 

 Note: 
Arrow function expressions can have an implicit return ; so, `() => x` is short for `() => { return x; }`.

 

`doSomethingElse` and `doThirdThing` can return any value — if they return promises, that promise is first waited until it settles, and the next callback receives the fulfillment value, not the promise itself. It is important to always return promises from `then` callbacks, even if the promise always resolves to `undefined`. If the previous handler started a promise but did not return it, there's no way to track its settlement anymore, and the promise is said to be "floating".

 js 

```
doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url);
  })
  .then((result) => {
    // result is undefined, because nothing is returned from the previous
    // handler. There's no way to know the return value of the fetch()
    // call anymore, or whether it succeeded at all.
  });
```

 

By returning the result of the `fetch` call (which is a promise), we can both track its completion and receive its value when it completes.

 js 

```
doSomething()
  .then((url) => {
    // `return` keyword added
    return fetch(url);
  })
  .then((result) => {
    // result is a Response object
  });
```

 

Floating promises could be worse if you have race conditions — if the promise from the last handler is not returned, the next `then` handler will be called early, and any value it reads may be incomplete.

 js 

```
const listOfIngredients = [];

doSomething()
  .then((url) => {
    // Missing `return` keyword in front of fetch(url).
    fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will always be [], because the fetch request hasn't completed yet.
  });
```

 

Therefore, as a rule of thumb, whenever your operation encounters a promise, return it and defer its handling to the next `then` handler.

 js 

```
const listOfIngredients = [];

doSomething()
  .then((url) => {
    // `return` keyword now included in front of fetch call.
    return fetch(url)
      .then((res) => res.json())
      .then((data) => {
        listOfIngredients.push(data);
      });
  })
  .then(() => {
    console.log(listOfIngredients);
    // listOfIngredients will now contain data from fetch call.
  });
```

 

Even better, you can flatten the nested chain into a single chain, which is simpler and makes error handling easier. The details are discussed in the Nesting section below.

 js 

```
doSomething()
  .then((url) => fetch(url))
  .then((res) => res.json())
  .then((data) => {
    listOfIngredients.push(data);
  })
  .then(() => {
    console.log(listOfIngredients);
  });
```

 

Using `async`/`await` can help you write code that's more intuitive and resembles synchronous code. Below is the same example using `async`/`await`:

 js 

```
async function logIngredients() {
  const url = await doSomething();
  const res = await fetch(url);
  const data = await res.json();
  listOfIngredients.push(data);
  console.log(listOfIngredients);
}
```

 

Note how the code looks exactly like synchronous code, except for the `await` keywords in front of promises. One of the only tradeoffs is that it may be easy to forget the `await` keyword, which can only be fixed when there's a type mismatch (e.g., trying to use a promise as a value).

`async`/`await` builds on promises — for example, `doSomething()` is the same function as before, so there's minimal refactoring needed to change from promises to `async`/`await`. You can read more about the `async`/`await` syntax in the async functions and `await` references.

 

 Note: 
`async`/`await` has the same concurrency semantics as normal promise chains. `await` within one async function does not stop the entire program, only the parts that depend on its value, so other async jobs can still run while the `await` is pending.

 
 
 

## Error handling 

 
 

You might recall seeing `failureCallback` three times in the pyramid of doom earlier, compared to only once at the end of the promise chain:

 js 

```
doSomething()
  .then((result) => doSomethingElse(result))
  .then((newResult) => doThirdThing(newResult))
  .then((finalResult) => console.log(`Got the final result: ${finalResult}`))
  .catch(failureCallback);
```

 

If there's an exception, the browser will look down the chain for `.catch()` handlers or `onRejected`. This is very much modeled after how synchronous code works:

 js 

```
try {
  const result = syncDoSomething();
  const newResult = syncDoSomethingElse(result);
  const finalResult = syncDoThirdThing(newResult);
  console.log(`Got the final result: ${finalResult}`);
} catch (error) {
  failureCallback(error);
}
```

 

This symmetry with asynchronous code culminates in the `async`/`await` syntax:

 js 

```
async function foo() {
  try {
    const result = await doSomething();
    const newResult = await doSomethingElse(result);
    const finalResult = await doThirdThing(newResult);
    console.log(`Got the final result: ${finalResult}`);
  } catch (error) {
    failureCallback(error);
  }
}
```

 

Promises solve a fundamental flaw with the callback pyramid of doom, by catching all errors, even thrown exceptions and programming errors. This is essential for functional composition of asynchronous operations. All errors are now handled by the `catch()` method at the end of the chain, and you should almost never need to use `try`/`catch` without using `async`/`await`.

 
 

### Nesting 

 
 

In the examples above involving `listOfIngredients`, the first one has one promise chain nested in the return value of another `then()` handler, while the second one uses an entirely flat chain. Simple promise chains are best kept flat without nesting, as nesting can be a result of careless composition.

Nesting is a control structure to limit the scope of `catch` statements. Specifically, a nested `catch` only catches failures in its scope and below, not errors higher up in the chain outside the nested scope. When used correctly, this gives greater precision in error recovery:

 js 

```
doSomethingCritical()
  .then((result) =>
    doSomethingOptional(result)
      .then((optionalResult) => doSomethingExtraNice(optionalResult))
      .catch((e) => {}),
  ) // Ignore if optional stuff fails; proceed.
  .then(() => moreCriticalStuff())
  .catch((e) => console.error(`Critical failure: ${e.message}`));
```

 

Note that the optional steps here are nested — with the nesting caused not by the indentation, but by the placement of the outer `(` and `)` parentheses around the steps.

The inner error-silencing `catch` handler only catches failures from `doSomethingOptional()` and `doSomethingExtraNice()`, after which the code resumes with `moreCriticalStuff()`. Importantly, if `doSomethingCritical()` fails, its error is caught by the final (outer) `catch` only, and does not get swallowed by the inner `catch` handler.

In `async`/`await`, this code looks like:

 js 

```
async function main() {
  try {
    const result = await doSomethingCritical();
    try {
      const optionalResult = await doSomethingOptional(result);
      await doSomethingExtraNice(optionalResult);
    } catch (e) {
      // Ignore failures in optional steps and proceed.
    }
    await moreCriticalStuff();
  } catch (e) {
    console.error(`Critical failure: ${e.message}`);
  }
}
```

 
 

 Note: 
If you don't have sophisticated error handling, you very likely don't need nested `then` handlers. Instead, use a flat chain and put the error handling logic at the end.

 
 
 

### Chaining after a catch 

 
 

It's possible to chain after a failure, i.e., a `catch`, which is useful to accomplish new actions even after an action failed in the chain. Read the following example:

 js 

```
doSomething()
  .then(() => {
    throw new Error("Something failed");

    console.log("Do this");
  })
  .catch(() => {
    console.error("Do that");
  })
  .then(() => {
    console.log("Do this, no matter what happened before");
  });
```

 

This will output the following text:



```
Do that
Do this, no matter what happened before
```


 

 Note: 
The text "Do this" is not displayed because the "Something failed" error caused a rejection.

 

In `async`/`await`, this code looks like:

 js 

```
async function main() {
  try {
    await doSomething();
    throw new Error("Something failed");
    console.log("Do this");
  } catch (e) {
    console.error("Do that");
  }
  console.log("Do this, no matter what happened before");
}
```

 
 
 

### Promise rejection events 

 
 

If a promise rejection event is not handled by any handler, it bubbles to the top of the call stack, and the host needs to surface it. On the web, whenever a promise is rejected, one of two events is sent to the global scope (generally, this is either the `window` or, if being used in a web worker, it's the `Worker` or other worker-based interface). The two events are:

 
 `unhandledrejection` 
 

Sent when a promise is rejected but there is no rejection handler available.

 
 `rejectionhandled` 
 

Sent when a handler is attached to a rejected promise that has already caused an `unhandledrejection` event.

 
 

In both cases, the event (of type `PromiseRejectionEvent` ) has as members a `promise` property indicating the promise that was rejected, and a `reason` property that provides the reason given for the promise to be rejected.

These make it possible to offer fallback error handling for promises, as well as to help debug issues with your promise management. These handlers are global per context, so all errors will go to the same event handlers, regardless of source.

In Node.js , handling promise rejection is slightly different. You capture unhandled rejections by adding a handler for the Node.js `unhandledRejection` event (notice the difference in capitalization of the name), like this:

 js 

```
process.on("unhandledRejection", (reason, promise) => {
  // Add code here to examine the "promise" and "reason" values
});
```

 

For Node.js, to prevent the error from being logged to the console (the default action that would otherwise occur), adding that `process.on()` listener is all that's necessary; there's no need for an equivalent of the browser runtime's `preventDefault()` method.

However, if you add that `process.on` listener but don't also have code within it to handle rejected promises, they will just be dropped on the floor and silently ignored. So ideally, you should add code within that listener to examine each rejected promise and make sure it was not caused by an actual code bug.

 
 

## Composition 

 
 

There are four composition tools for running asynchronous operations concurrently: `Promise.all()` , `Promise.allSettled()` , `Promise.any()` , and `Promise.race()` .

We can start operations at the same time and wait for them all to finish like this:

 js 

```
Promise.all([func1(), func2(), func3()]).then(([result1, result2, result3]) => {
  // use result1, result2 and result3
});
```

 

If one of the promises in the array rejects, `Promise.all()` immediately rejects the returned promise. The other operations continue to run, but their outcomes are not available via the return value of `Promise.all()`. This may cause unexpected state or behavior. `Promise.allSettled()` is another composition tool that ensures all operations are complete before resolving.

These methods all run promises concurrently — a sequence of promises are started simultaneously and do not wait for each other. Sequential composition is possible using some clever JavaScript:

 js 

```
[func1, func2, func3]
  .reduce((p, f) => p.then(f), Promise.resolve())
  .then((result3) => {
    /* use result3 */
  });
```

 

In this example, we reduce an array of asynchronous functions down to a promise chain. The code above is equivalent to:

 js 

```
Promise.resolve()
  .then(func1)
  .then(func2)
  .then(func3)
  .then((result3) => {
    /* use result3 */
  });
```

 

This can be made into a reusable compose function, which is common in functional programming:

 js 

```
const applyAsync = (acc, val) => acc.then(val);
const composeAsync =
  (...funcs) =>
  (x) =>
    funcs.reduce(applyAsync, Promise.resolve(x));
```

 

The `composeAsync()` function accepts any number of functions as arguments and returns a new function that accepts an initial value to be passed through the composition pipeline:

 js 

```
const transformData = composeAsync(func1, func2, func3);
const result3 = transformData(data);
```

 

Sequential composition can also be done more succinctly with async/await:

 js 

```
let result;
for (const f of [func1, func2, func3]) {
  result = await f(result);
}
/* use last result (i.e. result3) */
```

 

However, before you compose promises sequentially, consider if it's really necessary — it's always better to run promises concurrently so that they don't unnecessarily block each other unless one promise's execution depends on another's result.

 
 

## Cancellation 

 
 

`Promise` itself has no first-class protocol for cancellation, but you may be able to directly cancel the underlying asynchronous operation, typically using `AbortController` .

 
 

## Creating a Promise around an old callback API 

 
 

A `Promise` can be created from scratch using its constructor . This should be needed only to wrap old APIs.

In an ideal world, all asynchronous functions would already return promises. Unfortunately, some APIs still expect success and/or failure callbacks to be passed in the old way. The most obvious example is the `setTimeout()` function:

 js 

```
setTimeout(() => saySomething("10 seconds passed"), 10 * 1000);
```

 

Mixing old-style callbacks and promises is problematic. If `saySomething()` fails or contains a programming error, nothing catches it. This is intrinsic to the design of `setTimeout()`.

Luckily we can wrap `setTimeout()` in a promise. The best practice is to wrap the callback-accepting functions at the lowest possible level, and then never call them directly again:

 js 

```
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(10 * 1000)
  .then(() => saySomething("10 seconds"))
  .catch(failureCallback);
```

 

The promise constructor takes an executor function that lets us resolve or reject a promise manually. Since `setTimeout()` doesn't really fail, we left out reject in this case. For more information on how the executor function works, see the `Promise()` reference.

 
 

## Timing 

 
 

Lastly, we will look into the more technical details, about when the registered callbacks get called.

 
 

### Guarantees 

 
 

In the callback-based API, when and how the callback gets called depends on the API implementor. For example, the callback may be called synchronously or asynchronously:

 js 

```
function doSomething(callback) {
  if (Math.random() > 0.5) {
    callback();
  } else {
    setTimeout(() => callback(), 1000);
  }
}
```

 

The above design is strongly discouraged because it leads to the so-called "state of Zalgo". In the context of designing asynchronous APIs, this means a callback is called synchronously in some cases but asynchronously in other cases, creating ambiguity for the caller. For further background, see the article Designing APIs for Asynchrony , where the term was first formally presented. This API design makes side effects hard to analyze:

 js 

```
let value = 1;
doSomething(() => {
  value = 2;
});
console.log(value); // 1 or 2?
```

 

On the other hand, promises are a form of inversion of control — the API implementor does not control when the callback gets called. Instead, the job of maintaining the callback queue and deciding when to call the callbacks is delegated to the promise implementation, and both the API user and API developer automatically gets strong semantic guarantees, including:

- Callbacks added with `then()` will never be invoked before the completion of the current run of the JavaScript event loop.

- These callbacks will be invoked even if they were added after the success or failure of the asynchronous operation that the promise represents.

- Multiple callbacks may be added by calling `then()` several times. They will be invoked one after another, in the order in which they were inserted.

To avoid surprises, functions passed to `then()` will never be called synchronously, even with an already-resolved promise:

 js 

```
Promise.resolve().then(() => console.log(2));
console.log(1);
// Logs: 1, 2
```

 

Instead of running immediately, the passed-in function is put on a microtask queue, which means it runs later (only after the function which created it exits, and when the JavaScript execution stack is empty), just before control is returned to the event loop; i.e., pretty soon:

 js 

```
const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

wait(0).then(() => console.log(4));
Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
console.log(1); // 1, 2, 3, 4
```

 
 
 

### Task queues vs. microtasks 

 
 

Promise callbacks are handled as a microtask whereas `setTimeout()` callbacks are handled as task queues.

 js 

```
const promise = new Promise((resolve, reject) => {
  console.log("Promise callback");
  resolve();
}).then((result) => {
  console.log("Promise callback (.then)");
});

setTimeout(() => {
  console.log("event-loop cycle: Promise (fulfilled)", promise);
}, 0);

console.log("Promise (pending)", promise);
```

 

The code above will output:



```
Promise callback
Promise (pending) Promise {<pending>}
Promise callback (.then)
event-loop cycle: Promise (fulfilled) Promise {<fulfilled>}
```



For more details, refer to Tasks vs. microtasks .

 
 

### When promises and tasks collide 

 
 

If you run into situations in which you have promises and tasks (such as events or callbacks) which are firing in unpredictable orders, it's possible you may benefit from using a microtask to check status or balance out your promises when promises are created conditionally.

If you think microtasks may help solve this problem, see the microtask guide to learn more about how to use `queueMicrotask()` to enqueue a function as a microtask.

 
 

## See also 

 
 

- `Promise` 

- `async function` 

- `await` 

- Promises/A+ specification 

- We have a problem with promises on pouchdb.com (2015)

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 15, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Classes - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes

Classes - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Classes

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨March 2016⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Classes are a template for creating objects. They encapsulate data with code to work on that data. Classes in JS are built on prototypes but also have some syntax and semantics that are unique to classes.

For more examples and explanations, see the Using classes guide.

 
 
 
 
 
 

## Description 

 
 
 
 

### Defining classes 

 
 

Classes are in fact "special functions ", and just as you can define function expressions and function declarations , a class can be defined in two ways: a class expression or a class declaration .

 js 

```
// Declaration
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

// Expression; the class is anonymous but assigned to a variable
const Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};

// Expression; the class has its own name
const Rectangle = class Rectangle2 {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
};
```

 

Like function expressions, class expressions may be anonymous, or have a name that's different from the variable that it's assigned to. However, unlike function declarations, class declarations have the same temporal dead zone restrictions as `let` or `const` and behave as if they are not hoisted .

 
 

### Class body 

 
 

The body of a class is the part that is in curly braces `{}`. This is where you define class members, such as methods or constructor.

The body of a class is executed in strict mode even without the `"use strict"` directive.

A class element can be characterized by three aspects:

- Kind: Getter, setter, method, or field

- Location: Static or instance

- Visibility: Public or private

Together, they add up to 16 possible combinations. To divide the reference more logically and avoid overlapping content, the different elements are introduced in detail in different pages:

 
 Method definitions 
 

Public instance method

 
 getter 
 

Public instance getter

 
 setter 
 

Public instance setter

 
 Public class fields 
 

Public instance field

 
 `static` 
 

Public static method, getter, setter, and field

 
 Private elements 
 

Everything that's private

 
 
 

 Note: 
Private elements have the restriction that all private names declared in the same class must be unique. All other public properties do not have this restriction — you can have multiple public properties with the same name, and the last one overwrites the others. This is the same behavior as in object initializers .

 

In addition, there are two special class element syntaxes: `constructor` and static initialization blocks , with their own references.

#### Constructor

The `constructor` method is a special method for creating and initializing an object created with a class. There can only be one special method with the name "constructor" in a class — a `SyntaxError` is thrown if the class contains more than one occurrence of a `constructor` method.

A constructor can use the `super` keyword to call the constructor of the super class.

You can create instance properties inside the constructor:

 js 

```
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

 

Alternatively, if your instance properties' values do not depend on the constructor's arguments, you can define them as class fields .

#### Static initialization blocks

 Static initialization blocks allow flexible initialization of static properties , including the evaluation of statements during initialization, while granting access to the private scope.

Multiple static blocks can be declared, and these can be interleaved with the declaration of static fields and methods (all static items are evaluated in declaration order).

#### Methods

Methods are defined on the prototype of each class instance and are shared by all instances. Methods can be plain functions, async functions, generator functions, or async generator functions. For more information, see method definitions .

 js 

```
class Rectangle {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  // Getter
  get area() {
    return this.calcArea();
  }
  // Method
  calcArea() {
    return this.height * this.width;
  }
  *getSides() {
    yield this.height;
    yield this.width;
    yield this.height;
    yield this.width;
  }
}

const square = new Rectangle(10, 10);

console.log(square.area); // 100
console.log([...square.getSides()]); // [10, 10, 10, 10]
```

 

#### Static methods and fields

The `static` keyword defines a static method or field for a class. Static properties (fields and methods) are defined on the class itself instead of each instance. Static methods are often used to create utility functions for an application, whereas static fields are useful for caches, fixed-configuration, or any other data that doesn't need to be replicated across instances.

 js 

```
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  static displayName = "Point";
  static distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;

    return Math.hypot(dx, dy);
  }
}

const p1 = new Point(5, 5);
const p2 = new Point(10, 10);
p1.displayName; // undefined
p1.distance; // undefined
p2.displayName; // undefined
p2.distance; // undefined

console.log(Point.displayName); // "Point"
console.log(Point.distance(p1, p2)); // 7.0710678118654755
```

 

#### Field declarations

With the class field declaration syntax, the constructor example can be written as:

 js 

```
class Rectangle {
  height = 0;
  width;
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}
```

 

Class fields are similar to object properties, not variables, so we don't use keywords such as `const` to declare them. In JavaScript, private elements use a special identifier syntax, so modifier keywords like `public` and `private` should not be used either.

As seen above, the fields can be declared with or without a default value. Fields without default values default to `undefined`. By declaring fields up-front, class definitions become more self-documenting, and the fields are always present, which help with optimizations.

See public class fields for more information.

#### Private elements

Using private fields, the definition can be refined as below.

 js 

```
class Rectangle {
  #height = 0;
  #width;
  constructor(height, width) {
    this.#height = height;
    this.#width = width;
  }
}
```

 

It's an error to reference private fields from outside of the class; they can only be read or written within the class body.
By defining things that are not visible outside of the class, you ensure that your classes' users can't depend on internals, which may change from version to version.

Private fields can only be declared up-front in a field declaration. They cannot be created later through assigning to them, the way that normal properties can.

Private methods and accessors can also be defined using the same syntax as their public counterparts, but with the identifier starting with `#`.

For more information, see private elements .

 
 

### Inheritance 

 
 

The `extends` keyword is used in class declarations or class expressions to create a class as a child of another constructor (either a class or a function).

 js 

```
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  constructor(name) {
    super(name); // call the super class constructor and pass in the name parameter
  }

  speak() {
    console.log(`${this.name} barks.`);
  }
}

const d = new Dog("Mitzie");
d.speak(); // Mitzie barks.
```

 

If there is a constructor present in the subclass, it needs to first call `super()` before using `this`. The `super` keyword can also be used to call corresponding methods of super class.

 js 

```
class Cat {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Lion extends Cat {
  speak() {
    super.speak();
    console.log(`${this.name} roars.`);
  }
}

const l = new Lion("Fuzzy");
l.speak();
// Fuzzy makes a noise.
// Fuzzy roars.
```

 
 
 

### Evaluation order 

 
 

When a `class` declaration or `class` expression is evaluated, its various components are evaluated in the following order:

- The `extends` clause, if present, is first evaluated. It must evaluate to a valid constructor function or `null`, or a `TypeError` is thrown.

- The `constructor` method is extracted, substituted with a default implementation if `constructor` is not present. However, because the `constructor` definition is only a method definition, this step is not observable.

- The class elements' property keys are evaluated in the order of declaration. If the property key is computed, the computed expression is evaluated, with the `this` value set to the `this` value surrounding the class (not the class itself). None of the property values are evaluated yet.

- Methods and accessors are installed in the order of declaration. Instance methods and accessors are installed on the `prototype` property of the current class, and static methods and accessors are installed on the class itself. Private instance methods and accessors are saved to be installed on the instance directly later. This step is not observable.

- The class is now initialized with the prototype specified by `extends` and implementation specified by `constructor`. For all steps above, if an evaluated expression tries to access the name of the class, a `ReferenceError` is thrown because the class is not initialized yet.

- The class elements' values are evaluated in the order of declaration:

 For each instance field (public or private), its initializer expression is saved. The initializer is evaluated during instance creation, at the start of the constructor (for base classes) or immediately before the `super()` call returns (for derived classes).

- For each static field (public or private), its initializer is evaluated with `this` set to the class itself, and the property is created on the class.

- Static initialization blocks are evaluated with `this` set to the class itself.

 
- The class is now fully initialized and can be used as a constructor function.

For how instances are created, see the `constructor` reference.

 
 

## Examples 

 
 
 
 

### Binding this with instance and static methods 

 
 

When a static or instance method is called without a value for `this` , such as by assigning the method to a variable and then calling it, the `this` value will be `undefined` inside the method. This behavior is the same even if the `"use strict"` directive isn't present, because code within the `class` body is always executed in strict mode.

 js 

```
class Animal {
  speak() {
    return this;
  }
  static eat() {
    return this;
  }
}

const obj = new Animal();
obj.speak(); // the Animal object
const speak = obj.speak;
speak(); // undefined

Animal.eat(); // class Animal
const eat = Animal.eat;
eat(); // undefined
```

 

If we rewrite the above using traditional function-based syntax in non–strict mode, then `this` method calls are automatically bound to `globalThis` . In strict mode, the value of `this` remains as `undefined`.

 js 

```
function Animal() {}

Animal.prototype.speak = function () {
  return this;
};

Animal.eat = function () {
  return this;
};

const obj = new Animal();
const speak = obj.speak;
speak(); // global object (in non–strict mode)

const eat = Animal.eat;
eat(); // global object (in non-strict mode)
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Using classes guide

- `class` 

- `class` expression 

- Functions 

- ES6 In Depth: Classes on hacks.mozilla.org (2015)

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Inheritance and the prototype chain - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain

Inheritance and the prototype chain - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Inheritance and the prototype chain

 
 
 

In programming, inheritance refers to passing down characteristics from a parent to a child so that a new piece of code can reuse and build upon the features of an existing one. JavaScript implements inheritance by using objects . Each object has an internal link to another object called its prototype . That prototype object has a prototype of its own, and so on until an object is reached with `null` as its prototype. By definition, `null` has no prototype and acts as the final link in this prototype chain . It is possible to mutate any member of the prototype chain or even swap out the prototype at runtime, so concepts like static dispatching do not exist in JavaScript.

JavaScript is a bit confusing for developers experienced in class-based languages (like Java or C++), as it is dynamic and does not have static types. While this confusion is often considered to be one of JavaScript's weaknesses, the prototypal inheritance model itself is, in fact, more powerful than the classic model. It is, for example, fairly trivial to build a classic model on top of a prototypal model — which is how classes are implemented.

Although classes are now widely adopted and have become a new paradigm in JavaScript, classes do not bring a new inheritance pattern. While classes abstract most of the prototypal mechanism away, understanding how prototypes work under the hood is still useful.

 
 
 
 
 
 

## Inheritance with the prototype chain 

 
 
 
 

### Inheriting properties 

 
 

JavaScript objects are dynamic "bags" of properties (referred to as own properties ). JavaScript objects have a link to a prototype object. When trying to access a property of an object, the property will not only be sought on the object but on the prototype of the object, the prototype of the prototype, and so on until either a property with a matching name is found or the end of the prototype chain is reached.

 

 Note: 
Following the ECMAScript standard, the notation `someObject.[[Prototype]]` is used to designate the prototype of `someObject`. The `[[Prototype]]` internal slot can be accessed and modified with the `Object.getPrototypeOf()` and `Object.setPrototypeOf()` functions respectively. This is equivalent to the JavaScript accessor `__proto__` which is non-standard but de-facto implemented by many JavaScript engines. To prevent confusion while keeping it succinct, in our notation we will avoid using `obj.__proto__` but use `obj.[[Prototype]]` instead. This corresponds to `Object.getPrototypeOf(obj)`.

It should not be confused with the `func.prototype` property of functions, which instead specifies the `[[Prototype]]` to be assigned to all instances of objects created by the given function when used as a constructor. We will discuss the `prototype` property of constructor functions in a later section .

 

There are several ways to specify the `[[Prototype]]` of an object, which are listed in a later section . For now, we will use the `__proto__` syntax for illustration. It's worth noting that the `{ __proto__: ... }` syntax is different from the `obj.__proto__` accessor: the former is standard and not deprecated.

In an object literal like `{ a: 1, b: 2, __proto__: c }`, the value `c` (which has to be either `null` or another object) will become the `[[Prototype]]` of the object represented by the literal, while the other keys like `a` and `b` will become the own properties of the object. This syntax reads very naturally, since `[[Prototype]]` is just an "internal property" of the object.

Here is what happens when trying to access a property:

 js 

```
const o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
  },
};

// o.[[Prototype]] has properties b and c.
// o.[[Prototype]].[[Prototype]] is Object.prototype (we will explain
// what that means later).
// Finally, o.[[Prototype]].[[Prototype]].[[Prototype]] is null.
// This is the end of the prototype chain, as null,
// by definition, has no [[Prototype]].
// Thus, the full prototype chain looks like:
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null

console.log(o.a); // 1
// Is there an 'a' own property on o? Yes, and its value is 1.

console.log(o.b); // 2
// Is there a 'b' own property on o? Yes, and its value is 2.
// The prototype also has a 'b' property, but it's not visited.
// This is called Property Shadowing

console.log(o.c); // 4
// Is there a 'c' own property on o? No, check its prototype.
// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.

console.log(o.d); // undefined
// Is there a 'd' own property on o? No, check its prototype.
// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.
// o.[[Prototype]].[[Prototype]] is Object.prototype and
// there is no 'd' property by default, check its prototype.
// o.[[Prototype]].[[Prototype]].[[Prototype]] is null, stop searching,
// no property found, return undefined.
```

 

Setting a property to an object creates an own property. The only exception to the getting and setting behavior rules is when it's intercepted by a getter or setter .

Similarly, you can create longer prototype chains, and a property will be sought on all of them.

 js 

```
const o = {
  a: 1,
  b: 2,
  // __proto__ sets the [[Prototype]]. It's specified here
  // as another object literal.
  __proto__: {
    b: 3,
    c: 4,
    __proto__: {
      d: 5,
    },
  },
};

// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> { d: 5 } ---> Object.prototype ---> null

console.log(o.d); // 5
```

 
 
 

### Inheriting "methods" 

 
 

JavaScript does not have " methods " in the form that class-based languages define them. In JavaScript, any function can be added to an object in the form of a property. An inherited function acts just as any other property, including property shadowing as shown above (in this case, a form of method overriding ).

When an inherited function is executed, the value of `this` points to the inheriting object, not to the prototype object where the function is an own property.

 js 

```
const parent = {
  value: 2,
  method() {
    return this.value + 1;
  },
};

console.log(parent.method()); // 3
// When calling parent.method in this case, 'this' refers to parent

// child is an object that inherits from parent
const child = {
  __proto__: parent,
};
console.log(child.method()); // 3
// When child.method is called, 'this' refers to child.
// So when child inherits the method of parent,
// The property 'value' is sought on child. However, since child
// doesn't have an own property called 'value', the property is
// found on the [[Prototype]], which is parent.value.

child.value = 4; // assign the value 4 to the property 'value' on child.
// This shadows the 'value' property on parent.
// The child object now looks like:
// { value: 4, __proto__: { value: 2, method: [Function] } }
console.log(child.method()); // 5
// Since child now has the 'value' property, 'this.value' means
// child.value instead
```

 
 
 

## Constructors 

 
 

The power of prototypes is that we can reuse a set of properties if they should be present on every instance — especially for methods. Suppose we are to create a series of boxes, where each box is an object that contains a value which can be accessed through a `getValue` function. A naive implementation would be:

 js 

```
const boxes = [
  { value: 1, getValue() { return this.value; } },
  { value: 2, getValue() { return this.value; } },
  { value: 3, getValue() { return this.value; } },
];
```

 

This is subpar, because each instance has its own function property that does the same thing, which is redundant and unnecessary. Instead, we can move `getValue` to the `[[Prototype]]` of all boxes:

 js 

```
const boxPrototype = {
  getValue() {
    return this.value;
  },
};

const boxes = [
  { value: 1, __proto__: boxPrototype },
  { value: 2, __proto__: boxPrototype },
  { value: 3, __proto__: boxPrototype },
];
```

 

This way, all boxes' `getValue` method will refer to the same function, lowering memory usage. However, manually binding the `__proto__` for every object creation is still very inconvenient. This is when we would use a constructor function, which automatically sets the `[[Prototype]]` for every object manufactured. Constructors are functions called with `new` .

 js 

```
// A constructor function
function Box(value) {
  this.value = value;
}

// Properties all boxes created from the Box() constructor
// will have
Box.prototype.getValue = function () {
  return this.value;
};

const boxes = [new Box(1), new Box(2), new Box(3)];
```

 

We say that `new Box(1)` is an instance created from the `Box` constructor function. `Box.prototype` is not much different from the `boxPrototype` object we created previously — it's just a plain object. Every instance created from a constructor function will automatically have the constructor's `prototype` property as its `[[Prototype]]` — that is, `Object.getPrototypeOf(new Box()) === Box.prototype`. `Constructor.prototype` by default has one own property: `constructor` , which references the constructor function itself — that is, `Box.prototype.constructor === Box`. This allows one to access the original constructor from any instance.

 

 Note: 
If a non-primitive is returned from the constructor function, that value will become the result of the `new` expression. In this case the `[[Prototype]]` may not be correctly bound — but this should not happen much in practice.

 

The above constructor function can be rewritten in classes as:

 js 

```
class Box {
  constructor(value) {
    this.value = value;
  }

  // Methods are created on Box.prototype
  getValue() {
    return this.value;
  }
}
```

 

Classes are syntax sugar over constructor functions, which means you can still manipulate `Box.prototype` to change the behavior of all instances. However, because classes are designed to be an abstraction over the underlying prototype mechanism, we will use the more-lightweight constructor function syntax for this tutorial to fully demonstrate how prototypes work.

Because `Box.prototype` references the same object as the `[[Prototype]]` of all instances, we can change the behavior of all instances by mutating `Box.prototype`.

 js 

```
function Box(value) {
  this.value = value;
}
Box.prototype.getValue = function () {
  return this.value;
};
const box = new Box(1);

// Mutate Box.prototype after an instance has already been created
Box.prototype.getValue = function () {
  return this.value + 1;
};
box.getValue(); // 2
```

 

A corollary is, re-assigning `Constructor.prototype` (`Constructor.prototype = ...`) is a bad idea for two reasons:

- The `[[Prototype]]` of instances created before the reassignment is now referencing a different object from the `[[Prototype]]` of instances created after the reassignment — mutating one's `[[Prototype]]` no longer mutates the other.

- Unless you manually re-set the `constructor` property, the constructor function can no longer be traced from `instance.constructor`, which may break user expectation. Some built-in operations will read the `constructor` property as well, and if it is not set, they may not work as expected.

`Constructor.prototype` is only useful when constructing instances. It has nothing to do with `Constructor.[[Prototype]]`, which is the constructor function's own prototype, which is `Function.prototype` — that is, 

```
Object.getPrototypeOf(Constructor) === Function.prototype
```

.

 
 

### Implicit constructors of literals 

 
 

Some literal syntaxes in JavaScript create instances that implicitly set the `[[Prototype]]`. For example:

 js 

```
// Object literals (without the `__proto__` key) automatically
// have `Object.prototype` as their `[[Prototype]]`
const object = { a: 1 };
Object.getPrototypeOf(object) === Object.prototype; // true

// Array literals automatically have `Array.prototype` as their `[[Prototype]]`
const array = [1, 2, 3];
Object.getPrototypeOf(array) === Array.prototype; // true

// RegExp literals automatically have `RegExp.prototype` as their `[[Prototype]]`
const regexp = /abc/;
Object.getPrototypeOf(regexp) === RegExp.prototype; // true
```

 

We can "de-sugar" them into their constructor form.

 js 

```
const array = new Array(1, 2, 3);
const regexp = new RegExp("abc");
```

 

For example, "array methods" like `map()` are simply methods defined on `Array.prototype`, which is why they are automatically available on all array instances.

 

 Warning: 
There is one misfeature that used to be prevalent — extending `Object.prototype` or one of the other built-in prototypes. An example of this misfeature is, defining `Array.prototype.myMethod = function () {...}` and then using `myMethod` on all array instances.

This misfeature is called monkey patching . Doing monkey patching risks forward compatibility, because if the language adds this method in the future but with a different signature, your code will break. It has led to incidents like the SmooshGate , and can be a great nuisance for the language to advance since JavaScript tries to "not break the web".

The only good reason for extending a built-in prototype is to backport the features of newer JavaScript engines, like `Array.prototype.forEach`.

 

It may be interesting to note that due to historical reasons, some built-in constructors' `prototype` property are instances themselves. For example, `Number.prototype` is a number 0, `Array.prototype` is an empty array, and `RegExp.prototype` is `/(?:)/`.

 js 

```
Number.prototype + 1; // 1
Array.prototype.map((x) => x + 1); // []
String.prototype + "a"; // "a"
RegExp.prototype.source; // "(?:)"
Function.prototype(); // Function.prototype is a no-op function by itself
```

 

However, this is not the case for user-defined constructors, nor for modern constructors like `Map`.

 js 

```
Map.prototype.get(1);
// Uncaught TypeError: get method called on incompatible Map.prototype
```

 
 
 

### Building longer inheritance chains 

 
 

The `Constructor.prototype` property will become the `[[Prototype]]` of the constructor's instances, as-is — including `Constructor.prototype`'s own `[[Prototype]]`. By default, `Constructor.prototype` is a plain object — that is, 

```
Object.getPrototypeOf(Constructor.prototype) === Object.prototype
```

. The only exception is `Object.prototype` itself, whose `[[Prototype]]` is `null` — that is, `Object.getPrototypeOf(Object.prototype) === null`. Therefore, a typical constructor will build the following prototype chain:

 js 

```
function Constructor() {}

const obj = new Constructor();
// obj ---> Constructor.prototype ---> Object.prototype ---> null
```

 

To build longer prototype chains, we can set the `[[Prototype]]` of `Constructor.prototype` via the `Object.setPrototypeOf()` function.

 js 

```
function Base() {}
function Derived() {}
// Set the `[[Prototype]]` of `Derived.prototype`
// to `Base.prototype`
Object.setPrototypeOf(Derived.prototype, Base.prototype);

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null
```

 

In class terms, this is equivalent to using the `extends` syntax.

 js 

```
class Base {}
class Derived extends Base {}

const obj = new Derived();
// obj ---> Derived.prototype ---> Base.prototype ---> Object.prototype ---> null
```

 

You may also see some legacy code using `Object.create()` to build the inheritance chain. However, because this reassigns the `prototype` property and removes the `constructor` property, it can be more error-prone, while performance gains may not be apparent if the constructors haven't created any instances yet.

 js 

```
function Base() {}
function Derived() {}
// Re-assigns `Derived.prototype` to a new object
// with `Base.prototype` as its `[[Prototype]]`
// DON'T DO THIS — use Object.setPrototypeOf to mutate it instead
Derived.prototype = Object.create(Base.prototype);
```

 
 
 

## Inspecting prototypes: a deeper dive 

 
 

Let's look at what happens behind the scenes in a bit more detail.

In JavaScript, as mentioned above, functions are able to have properties. All functions have a special property named `prototype`. Please note that the code below is free-standing (it is safe to assume there is no other JavaScript on the webpage other than the below code). For the best learning experience, it is highly recommended that you open a console, navigate to the "console" tab, copy-and-paste in the below JavaScript code, and run it by pressing the Enter/Return key. (The console is included in most web browser's Developer Tools. More information is available for Firefox Developer Tools , Chrome DevTools , and Edge DevTools .)

 js 

```
function doSomething() {}
console.log(doSomething.prototype);
// It does not matter how you declare the function; a
// function in JavaScript will always have a default
// prototype property — with one exception: an arrow
// function doesn't have a default prototype property:
const doSomethingFromArrowFunction = () => {};
console.log(doSomethingFromArrowFunction.prototype);
```

 

As seen above, `doSomething()` has a default `prototype` property, as demonstrated by the console. After running this code, the console should have displayed an object that looks similar to this.



```
{
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}
```


 

 Note: 
The Chrome console uses `[[Prototype]]` to denote the object's prototype, following the spec's terms; Firefox uses ` `. For consistency we will use `[[Prototype]]`.

 

We can add properties to the prototype of `doSomething()`, as shown below.

 js 

```
function doSomething() {}
doSomething.prototype.foo = "bar";
console.log(doSomething.prototype);
```

 

This results in:



```
{
  foo: "bar",
  constructor: ƒ doSomething(),
  [[Prototype]]: {
    constructor: ƒ Object(),
    hasOwnProperty: ƒ hasOwnProperty(),
    isPrototypeOf: ƒ isPrototypeOf(),
    propertyIsEnumerable: ƒ propertyIsEnumerable(),
    toLocaleString: ƒ toLocaleString(),
    toString: ƒ toString(),
    valueOf: ƒ valueOf()
  }
}
```



We can now use the `new` operator to create an instance of `doSomething()` based on this prototype. To use the new operator, call the function normally except prefix it with `new`. Calling a function with the `new` operator returns an object that is an instance of the function. Properties can then be added onto this object.

Try the following code:

 js 

```
function doSomething() {}
doSomething.prototype.foo = "bar"; // add a property onto the prototype
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value"; // add a property onto the object
console.log(doSomeInstancing);
```

 

This results in an output similar to the following:



```
{
  prop: "some value",
  [[Prototype]]: {
    foo: "bar",
    constructor: ƒ doSomething(),
    [[Prototype]]: {
      constructor: ƒ Object(),
      hasOwnProperty: ƒ hasOwnProperty(),
      isPrototypeOf: ƒ isPrototypeOf(),
      propertyIsEnumerable: ƒ propertyIsEnumerable(),
      toLocaleString: ƒ toLocaleString(),
      toString: ƒ toString(),
      valueOf: ƒ valueOf()
    }
  }
}
```



As seen above, the `[[Prototype]]` of `doSomeInstancing` is `doSomething.prototype`. But, what does this do? When you access a property of `doSomeInstancing`, the runtime first looks to see if `doSomeInstancing` has that property.

If `doSomeInstancing` does not have the property, then the runtime looks for the property in `doSomeInstancing.[[Prototype]]` (a.k.a. `doSomething.prototype`). If `doSomeInstancing.[[Prototype]]` has the property being looked for, then that property on `doSomeInstancing.[[Prototype]]` is used.

Otherwise, if `doSomeInstancing.[[Prototype]]` does not have the property, then `doSomeInstancing.[[Prototype]].[[Prototype]]` is checked for the property. By default, the `[[Prototype]]` of any function's `prototype` property is `Object.prototype`. So, `doSomeInstancing.[[Prototype]].[[Prototype]]` (a.k.a. `doSomething.prototype.[[Prototype]]` (a.k.a. `Object.prototype`)) is then looked through for the property being searched for.

If the property is not found in `doSomeInstancing.[[Prototype]].[[Prototype]]`, then 

```
doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]]
```

 is looked through. However, there is a problem: 

```
doSomeInstancing.[[Prototype]].[[Prototype]].[[Prototype]]
```

 does not exist, because `Object.prototype.[[Prototype]]` is `null`. Then, and only then, after the entire prototype chain of `[[Prototype]]`'s is looked through, the runtime asserts that the property does not exist and conclude that the value at the property is `undefined`.

Let's try entering some more code into the console:

 js 

```
function doSomething() {}
doSomething.prototype.foo = "bar";
const doSomeInstancing = new doSomething();
doSomeInstancing.prop = "some value";
console.log("doSomeInstancing.prop:     ", doSomeInstancing.prop);
console.log("doSomeInstancing.foo:      ", doSomeInstancing.foo);
console.log("doSomething.prop:          ", doSomething.prop);
console.log("doSomething.foo:           ", doSomething.foo);
console.log("doSomething.prototype.prop:", doSomething.prototype.prop);
console.log("doSomething.prototype.foo: ", doSomething.prototype.foo);
```

 

This results in the following:



```
doSomeInstancing.prop:      some value
doSomeInstancing.foo:       bar
doSomething.prop:           undefined
doSomething.foo:            undefined
doSomething.prototype.prop: undefined
doSomething.prototype.foo:  bar
```


 
 

## Different ways of creating and mutating prototype chains 

 
 

We have encountered many ways to create objects and change their prototype chains. We will systematically summarize the different ways, comparing each approach's pros and cons.

 
 

### Objects created with syntax constructs 

 
 js 

```
const o = { a: 1 };
// The newly created object o has Object.prototype as its [[Prototype]]
// Object.prototype has null as its [[Prototype]].
// o ---> Object.prototype ---> null

const b = ["yo", "sup", "?"];
// Arrays inherit from Array.prototype
// (which has methods indexOf, forEach, etc.)
// The prototype chain looks like:
// b ---> Array.prototype ---> Object.prototype ---> null

function f() {
  return 2;
}
// Functions inherit from Function.prototype
// (which has methods call, bind, etc.)
// f ---> Function.prototype ---> Object.prototype ---> null

const p = { b: 2, __proto__: o };
// It is possible to point the newly created object's [[Prototype]] to
// another object via the __proto__ literal property. (Not to be confused
// with Object.prototype.__proto__ accessors)
// p ---> o ---> Object.prototype ---> null
```

 

When using the `__proto__` key in object initializers , pointing the `__proto__` key to something that is not an object only fails silently without throwing an exception. Contrary to the `Object.prototype.__proto__` setter, `__proto__` in object literal initializers is standardized and optimized, and can even be more performant than `Object.create` . Declaring extra own properties on the object at creation is more ergonomic than `Object.create` .

 
 

### With constructor functions 

 
 js 

```
function Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g is an object with own properties 'vertices' and 'edges'.
// g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.
```

 

Constructor functions have been available since very early JavaScript. Therefore, it is very fast, very standard, and very JIT-optimizable. However, it's also hard to "do properly" because methods added this way are enumerable by default, which is inconsistent with the class syntax or how built-in methods behave. Doing longer inheritance chains is also error-prone, as previously demonstrated.

 
 

### With Object.create() 

 
 

Calling `Object.create()` creates a new object. The `[[Prototype]]` of this object is the first argument of the function:

 js 

```
const a = { a: 1 };
// a ---> Object.prototype ---> null

const b = Object.create(a);
// b ---> a ---> Object.prototype ---> null
console.log(b.a); // 1 (inherited)

const c = Object.create(b);
// c ---> b ---> a ---> Object.prototype ---> null

const d = Object.create(null);
// d ---> null (d is an object that has null directly as its prototype)
console.log(d.hasOwnProperty);
// undefined, because d doesn't inherit from Object.prototype
```

 

Similar to the `__proto__` key in object initializers, `Object.create()` allows directly setting the prototype of an object at creation time, which permits the runtime to further optimize the object. It also allows the creation of objects with `null` prototype, using `Object.create(null)`. The second parameter of `Object.create()` allows you to precisely specify the attributes of each property in the new object, which can be a double-edged sword:

- It allows you to create non-enumerable properties, etc., during object creation, which is not possible with object literals.

- It is much more verbose and error-prone than object literals.

- It may be slower than object literals, especially when creating many properties.

 
 

### With classes 

 
 js 

```
class Rectangle {
  constructor(height, width) {
    this.name = "Rectangle";
    this.height = height;
    this.width = width;
  }
}

class FilledRectangle extends Rectangle {
  constructor(height, width, color) {
    super(height, width);
    this.name = "Filled rectangle";
    this.color = color;
  }
}

const filledRectangle = new FilledRectangle(5, 10, "blue");
// filledRectangle ---> FilledRectangle.prototype ---> Rectangle.prototype ---> Object.prototype ---> null
```

 

Classes offer the highest readability and maintainability when defining complex inheritance structures. Private elements are a feature with no trivial replacement in prototypal inheritance. However, classes are less optimized than traditional constructor functions and are not supported in older environments.

 
 

### With Object.setPrototypeOf() 

 
 

While all methods above will set the prototype chain at object creation time, `Object.setPrototypeOf()` allows mutating the `[[Prototype]]` internal property of an existing object. It can even force a prototype on a prototype-less object created with `Object.create(null)` or remove the prototype of an object by setting it to `null`.

 js 

```
const obj = { a: 1 };
const anotherObj = { b: 2 };
Object.setPrototypeOf(obj, anotherObj);
// obj ---> anotherObj ---> Object.prototype ---> null
```

 

However, you should set the prototype during creation if possible, because setting the prototype dynamically disrupts all optimizations that engines have made to the prototype chain. It might cause some engines to recompile your code for de-optimization, to make it work according to the specs.

 
 

### With the __proto__ accessor 

 
 

All objects inherit the `Object.prototype.__proto__` setter, which can be used to set the `[[Prototype]]` of an existing object (if the `__proto__` key is not overridden on the object).

 

 Warning: 
`Object.prototype.__proto__` accessors are non-standard and deprecated. You should almost always use `Object.setPrototypeOf` instead.

 
 js 

```
const obj = {};
// DON'T USE THIS: for example only.
obj.__proto__ = { barProp: "bar val" };
obj.__proto__.__proto__ = { fooProp: "foo val" };
console.log(obj.fooProp);
console.log(obj.barProp);
```

 

Compared to `Object.setPrototypeOf`, setting `__proto__` to something that is not an object fails silently without throwing an exception. It also has slightly better browser support. However, it is non-standard and deprecated. You should almost always use `Object.setPrototypeOf` instead.

 
 

## Performance 

 
 

The lookup time for properties that are high up on the prototype chain can have a negative impact on the performance, and this may be significant in the code where performance is critical. Additionally, trying to access nonexistent properties will always traverse the full prototype chain.

Also, when iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated. To check whether an object has a property defined on itself and not somewhere on its prototype chain, it is necessary to use the `hasOwnProperty` or `Object.hasOwn` methods. All objects, except those with `null` as `[[Prototype]]`, inherit `hasOwnProperty` from `Object.prototype` — unless it has been overridden further down the prototype chain. To give you a concrete example, let's take the above graph example code to illustrate it:

 js 

```
function Graph() {
  this.vertices = [];
  this.edges = [];
}

Graph.prototype.addVertex = function (v) {
  this.vertices.push(v);
};

const g = new Graph();
// g ---> Graph.prototype ---> Object.prototype ---> null

g.hasOwnProperty("vertices"); // true
Object.hasOwn(g, "vertices"); // true

g.hasOwnProperty("nope"); // false
Object.hasOwn(g, "nope"); // false

g.hasOwnProperty("addVertex"); // false
Object.hasOwn(g, "addVertex"); // false

Object.getPrototypeOf(g).hasOwnProperty("addVertex"); // true
```

 

Note: It is not enough to check whether a property is `undefined` . The property might very well exist, but its value just happens to be set to `undefined`.

 
 

## Conclusion 

 
 

JavaScript may be a bit confusing for developers coming from Java or C++, as it's all dynamic, all runtime, and it has no static types at all. Everything is either an object (instance) or a function (constructor), and even functions themselves are instances of the `Function` constructor. Even the "classes" as syntax constructs are just constructor functions at runtime.

All constructor functions in JavaScript have a special property called `prototype`, which works with the `new` operator. The reference to the prototype object is copied to the internal `[[Prototype]]` property of the new instance. For example, when you do `const a1 = new A()`, JavaScript (after creating the object in memory and before running function `A()` with `this` defined to it) sets `a1.[[Prototype]] = A.prototype`. When you then access properties of the instance, JavaScript first checks whether they exist on that object directly, and if not, it looks in `[[Prototype]]`. `[[Prototype]]` is looked at recursively , i.e., `a1.doSomething`, `Object.getPrototypeOf(a1).doSomething`, 

```
Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething
```

 etc., until it's found or `Object.getPrototypeOf` returns `null`. This means that all properties defined on `prototype` are effectively shared by all instances, and you can even later change parts of `prototype` and have the changes appear in all existing instances.

If, in the example above, you do `const a1 = new A(); const a2 = new A();`, then `a1.doSomething` would actually refer to `Object.getPrototypeOf(a1).doSomething` — which is the same as the `A.prototype.doSomething` you defined, i.e., 

```
Object.getPrototypeOf(a1).doSomething === Object.getPrototypeOf(a2).doSomething === A.prototype.doSomething
```

.

It is essential to understand the prototypal inheritance model before writing complex code that makes use of it. Also, be aware of the length of the prototype chains in your code and break them up if necessary to avoid possible performance problems. Further, the native prototypes should never be extended unless it is for the sake of compatibility with newer JavaScript features.

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Using classes - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes#overview_of_classes

Using classes - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Using classes

 
 
 
- Previous 
- Next 

JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes , the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.

In many other languages, classes , or constructors, are clearly distinguished from objects , or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the `new` operator with a constructor function to create a new object.

We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.

This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.

 
 
 
 
 
 

## Overview of classes 

 
 

If you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you :

 js 

```
const bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}
```

 

On the first line, we created an instance of the class `Date` , and called it `bigDay`. On the second line, we called a method `toLocaleDateString()` on the `bigDay` instance, which returns a string. Then, we compared two numbers: one returned from the `getTime()` method, the other directly called from the `Date` class itself , as `Date.now()` .

`Date` is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

- Classes create objects through the `new` operator.

- Each object has some properties (data or method) added by the class.

- The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

- Constructor;

- Instance methods and instance fields;

- Static methods and static fields.

 
 

## Declaring a class 

 
 

Classes are usually created with class declarations .

 js 

```
class MyClass {
  // class body...
}
```

 

Within a class body, there are a range of features available.

 js 

```
class MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}
```

 

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:

 js 

```
function MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();
```

 
 

 Note: 
Private fields and methods are new features in classes with no trivial equivalent in function constructors.

 
 
 

### Constructing a class 

 
 

After a class has been declared, you can create instances of it using the `new` operator.

 js 

```
const myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();
```

 

Typical function constructors can both be constructed with `new` and called without `new`. However, attempting to "call" a class without `new` will result in an error.

 js 

```
const myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
```

 
 
 

### Class declaration hoisting 

 
 

Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.

 js 

```
new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}
```

 

This behavior is similar to variables declared with `let` and `const` .

 
 

### Class expressions 

 
 

Similar to functions, class declarations also have their expression counterparts.

 js 

```
const MyClass = class {
  // Class body...
};
```

 

Class expressions can have names as well. The expression's name is only visible to the class's body.

 js 

```
const MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
```

 
 
 

## Constructor 

 
 

Perhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the `Date` constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor .

As an example, we would create a class called `Color`, which represents a specific color. Users create colors through passing in an RGB triplet.

 js 

```
class Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}
```

 

Open your browser's devtools, paste the above code into the console, and then create an instance:

 js 

```
const red = new Color(255, 0, 0);
console.log(red);
```

 

You should see some output like this:



```
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]
```



You have successfully created a `Color` instance, and the instance has a `values` property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:

 js 

```
function createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}
```

 

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters :

 js 

```
class Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.
```

 

Each time you call `new`, a different instance is created.

 js 

```
const red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false
```

 

Within a class constructor, the value of `this` points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).

The `this` value will be automatically returned as the result of `new`. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the `new` expression, and the value of `this` is dropped. (You can read more about what `new` does in its description .)

 js 

```
class MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
```

 
 
 

## Instance methods 

 
 

If a class only has a constructor, it is not much different from a `createX` factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.

For example, for `Date` instances, you can use a range of methods to get different information from a single date value, such as the year , month , day of the week , etc. You can also set those values through the `setX` counterparts like `setFullYear` .

For our own `Color` class, we can add a method called `getRed` which returns the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Without methods, you may be tempted to define the function within the constructor:

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}
```

 

This also works. However, a problem is that this creates a new function every time a `Color` instance is created, even when they all do the same thing!

 js 

```
console.log(new Color().getRed === new Color().getRed); // false
```

 

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of `this` is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or `Color.prototype`, which is explained in more detail in Inheritance and the prototype chain .

Similarly, we can create a new method called `setRed`, which sets the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
```

 
 
 

## Private fields 

 
 

You might be wondering: why do we want to go to the trouble of using `getRed` and `setRed` methods, when we can directly access the `values` array on the instance?

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0
```

 

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:

 js 

```
class Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0
```

 

The user assumption that `values` means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields .

A private field is an identifier prefixed with `#` (the hash symbol). The hash is an integral part of the field's name, which means a private field can never have name clash with a public field or method. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private element on the fly). Apart from this, a private field is pretty much equivalent to a normal property.

 js 

```
class Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Accessing private fields outside the class is an early syntax error. The language can guard against this because `#privateField` is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.

 js 

```
console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
```

 
 

 Note: 
Code run in the Chrome console can access private elements outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

 

Private fields in JavaScript are hard private : if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.

After we've made the `values` field private, we can add some more logic in the `getRed` and `setRed` methods, instead of making them simple pass-through methods. For example, we can add a check in `setRed` to see if it's a valid R value:

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value
```

 

If we leave the `values` property exposed, our users can easily circumvent that check by assigning to `values[0]` directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.

A class method can read the private fields of other instances, as long as they belong to the same class.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35
```

 

However, if `anotherColor` is not a Color instance, `#values` won't exist. (Even if another class has an identically named `#values` private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private element throws an error instead of returning `undefined` like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using `try`/`catch` to handle the error, you can use the `in` operator.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}
```

 
 

 Note: 
Keep in mind that the `#` is a special identifier syntax, and you can't use the field name as if it's a string. `"#values" in anotherColor` would look for a property name literally called `"#values"`, instead of a private field.

 

There are some limitations in using private elements: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.

 js 

```
class BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}
```

 

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.

For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.

 js 

```
class Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);
```

 

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of `Counter`.

 
 

## Accessor fields 

 
 

`color.getRed()` and `color.setRed()` allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0
```

 

It looks as if the object has a property called `red` — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with `get` and `set`, which allows them to be manipulated as if they were properties.

If a field only has a getter but no setter, it will be effectively read-only.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255
```

 

In strict mode , the `red.red = 0` line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.

 
 

## Public fields 

 
 

Private fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.

 js 

```
class MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3
```

 

Public fields are almost equivalent to assigning a property to `this`. For example, the above example can also be converted to:

 js 

```
class MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
```

 
 
 

## Static properties 

 
 

With the `Date` example, we have also encountered the `Date.now()` method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the `Date` class instead of being exposed as a global `DateNow()` function, because it's mostly useful when dealing with date instances.

 

 Note: 
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed `parseInt()` method, JavaScript also later added the prefixed `Number.parseInt()` method to indicate that it's for dealing with numbers.

 

 Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

- Static methods

- Static fields

- Static getters and setters

Everything also has private counterparts. For example, for our `Color` class, we can create a static method that checks whether a given triplet is a valid RGB value:

 js 

```
class Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false
```

 

Static properties are very similar to their instance counterparts, except that:

- They are all prefixed with `static`, and

- They are not accessible from instances.

 js 

```
console.log(new Color(0, 0, 0).isValid); // undefined
```

 

There is also a special construct called a static initialization block , which is a block of code that runs when the class is first loaded.

 js 

```
class MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'
```

 

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private elements.

 
 

## Extends and inheritance 

 
 

A key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance , which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.

For example, suppose our `Color` class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:

 js 

```
class Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}
```

 

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our `Color` class will become very bloated and hard to maintain.

Instead, in object-oriented programming, we would create a derived class . The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an `extends` clause, which indicates the class it extends from.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}
```

 

There are a few things that have immediately come to attention. First is that in the constructor, we are calling `super(r, g, b)`. It is a language requirement to call `super()` before accessing `this`. The `super()` call calls the parent class's constructor to initialize `this` — here it's roughly equivalent to `this = new Color(r, g, b)`. You can have code before `super()`, but you cannot access `this` before `super()` — the language prevents you from accessing the uninitialized `this`.

After the parent class is done with modifying `this`, the derived class can do its own logic. Here we added a private field called `#alpha`, and also provided a pair of getter/setters to interact with them.

A derived class inherits all methods from its parent. For example, consider the `get red()` accessor we added to the `Color` in the Accessor fields section—even though we haven't declared one in `ColorWithAlpha`, we can still access `red` because this behavior is specified by the parent class:

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255
```

 

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the `Object` class, which defines some basic methods like `toString()` . However, the base `toString()` method is notoriously useless, because it prints `[object Object]` in most cases:

 js 

```
console.log(red.toString()); // [object Object]
```

 

Instead, our class can override it to print the color's RGB values:

 js 

```
class Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'
```

 

Within derived classes, you can access the parent class's methods by using `super`. This allows you to build enhancement methods and avoid code duplication.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'
```

 

When you use `extends`, the static methods inherit from each other as well, so you can also override or enhance them.

 js 

```
class ColorWithAlpha extends Color {
  // …
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false
```

 

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.

 js 

```
class ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}
```

 

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem . However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins .

Instances of derived classes are also instances of the base class.

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
```

 
 
 

## Why classes? 

 
 

The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.

Classes introduce a paradigm , or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism ). However, many people are philosophically against certain OOP practices and don't use classes as a result.

For example, one thing that makes `Date` objects infamous is that they're mutable .

 js 

```
function incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20
```

 

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.

In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

 

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.

On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the `Color` class, we may need to create a dozen of utility functions:

 js 

```
function isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// …
```

 

But with classes, we can congregate them all under the `Color` namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.

In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

- The `Map` and `Set` classes store a collection of elements and allow you to access them by key using `get()`, `set()`, `has()`, etc.

- The `Date` class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.

- The `Error` class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like `TypeError` and `ReferenceError` that extend `Error`. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with `instanceof` .

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 6, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Using classes - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes#declaring_a_class

Using classes - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Using classes

 
 
 
- Previous 
- Next 

JavaScript is a prototype-based language — an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes , the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.

In many other languages, classes , or constructors, are clearly distinguished from objects , or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism — all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors — you use the `new` operator with a constructor function to create a new object.

We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide.

This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects.

 
 
 
 
 
 

## Overview of classes 

 
 

If you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you :

 js 

```
const bigDay = new Date(2019, 6, 19);
console.log(bigDay.toLocaleDateString());
if (bigDay.getTime() < Date.now()) {
  console.log("Once upon a time...");
}
```

 

On the first line, we created an instance of the class `Date` , and called it `bigDay`. On the second line, we called a method `toLocaleDateString()` on the `bigDay` instance, which returns a string. Then, we compared two numbers: one returned from the `getTime()` method, the other directly called from the `Date` class itself , as `Date.now()` .

`Date` is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do:

- Classes create objects through the `new` operator.

- Each object has some properties (data or method) added by the class.

- The class stores some properties (data or method) itself, which are usually used to interact with instances.

These correspond to the three key features of classes:

- Constructor;

- Instance methods and instance fields;

- Static methods and static fields.

 
 

## Declaring a class 

 
 

Classes are usually created with class declarations .

 js 

```
class MyClass {
  // class body...
}
```

 

Within a class body, there are a range of features available.

 js 

```
class MyClass {
  // Constructor
  constructor() {
    // Constructor body
  }
  // Instance field
  myField = "foo";
  // Instance method
  myMethod() {
    // myMethod body
  }
  // Static field
  static myStaticField = "bar";
  // Static method
  static myStaticMethod() {
    // myStaticMethod body
  }
  // Static block
  static {
    // Static initialization code
  }
  // Fields, methods, static fields, and static methods all have
  // "private" forms
  #myPrivateField = "bar";
}
```

 

If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors:

 js 

```
function MyClass() {
  this.myField = "foo";
  // Constructor body
}
MyClass.myStaticField = "bar";
MyClass.myStaticMethod = function () {
  // myStaticMethod body
};
MyClass.prototype.myMethod = function () {
  // myMethod body
};

(function () {
  // Static initialization code
})();
```

 
 

 Note: 
Private fields and methods are new features in classes with no trivial equivalent in function constructors.

 
 
 

### Constructing a class 

 
 

After a class has been declared, you can create instances of it using the `new` operator.

 js 

```
const myInstance = new MyClass();
console.log(myInstance.myField); // 'foo'
myInstance.myMethod();
```

 

Typical function constructors can both be constructed with `new` and called without `new`. However, attempting to "call" a class without `new` will result in an error.

 js 

```
const myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new'
```

 
 
 

### Class declaration hoisting 

 
 

Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared.

 js 

```
new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {}
```

 

This behavior is similar to variables declared with `let` and `const` .

 
 

### Class expressions 

 
 

Similar to functions, class declarations also have their expression counterparts.

 js 

```
const MyClass = class {
  // Class body...
};
```

 

Class expressions can have names as well. The expression's name is only visible to the class's body.

 js 

```
const MyClass = class MyClassLongerName {
  // Class body. Here MyClass and MyClassLongerName point to the same class.
};
new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined
```

 
 
 

## Constructor 

 
 

Perhaps the most important job of a class is to act as a "factory" for objects. For example, when we use the `Date` constructor, we expect it to give a new object which represents the date data we passed in — which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor .

As an example, we would create a class called `Color`, which represents a specific color. Users create colors through passing in an RGB triplet.

 js 

```
class Color {
  constructor(r, g, b) {
    // Assign the RGB values as a property of `this`.
    this.values = [r, g, b];
  }
}
```

 

Open your browser's devtools, paste the above code into the console, and then create an instance:

 js 

```
const red = new Color(255, 0, 0);
console.log(red);
```

 

You should see some output like this:



```
Object { values: (3) […] }
  values: Array(3) [ 255, 0, 0 ]
```



You have successfully created a `Color` instance, and the instance has a `values` property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following:

 js 

```
function createColor(r, g, b) {
  return {
    values: [r, g, b],
  };
}
```

 

The constructor's syntax is exactly the same as a normal function — which means you can use other syntaxes, like rest parameters :

 js 

```
class Color {
  constructor(...values) {
    this.values = values;
  }
}

const red = new Color(255, 0, 0);
// Creates an instance with the same shape as above.
```

 

Each time you call `new`, a different instance is created.

 js 

```
const red = new Color(255, 0, 0);
const anotherRed = new Color(255, 0, 0);
console.log(red === anotherRed); // false
```

 

Within a class constructor, the value of `this` points to the newly created instance. You can assign properties to it, or read existing properties (especially methods — which we will cover next).

The `this` value will be automatically returned as the result of `new`. You are advised to not return any value from the constructor — because if you return a non-primitive value, it will become the value of the `new` expression, and the value of `this` is dropped. (You can read more about what `new` does in its description .)

 js 

```
class MyClass {
  constructor() {
    this.myField = "foo";
    return {};
  }
}

console.log(new MyClass().myField); // undefined
```

 
 
 

## Instance methods 

 
 

If a class only has a constructor, it is not much different from a `createX` factory function which just creates plain objects. However, the power of classes is that they can be used as "templates" which automatically assign methods to instances.

For example, for `Date` instances, you can use a range of methods to get different information from a single date value, such as the year , month , day of the week , etc. You can also set those values through the `setX` counterparts like `setFullYear` .

For our own `Color` class, we can add a method called `getRed` which returns the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Without methods, you may be tempted to define the function within the constructor:

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
    this.getRed = function () {
      return this.values[0];
    };
  }
}
```

 

This also works. However, a problem is that this creates a new function every time a `Color` instance is created, even when they all do the same thing!

 js 

```
console.log(new Color().getRed === new Color().getRed); // false
```

 

In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of `this` is different. If you are curious where this method is stored in — it's defined on the prototype of all instances, or `Color.prototype`, which is explained in more detail in Inheritance and the prototype chain .

Similarly, we can create a new method called `setRed`, which sets the red value of the color.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(0);
console.log(red.getRed()); // 0; of course, it should be called "black" at this stage!
```

 
 
 

## Private fields 

 
 

You might be wondering: why do we want to go to the trouble of using `getRed` and `setRed` methods, when we can directly access the `values` array on the instance?

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
}

const red = new Color(255, 0, 0);
red.values[0] = 0;
console.log(red.values[0]); // 0
```

 

There is a philosophy in object-oriented programming called "encapsulation". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead:

 js 

```
class Color {
  constructor(r, g, b) {
    // values is now an HSL array!
    this.values = rgbToHSL([r, g, b]);
  }
  getRed() {
    return this.values[0];
  }
  setRed(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0
```

 

The user assumption that `values` means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some "harmless refactors". In classes, this is done through private fields .

A private field is an identifier prefixed with `#` (the hash symbol). The hash is an integral part of the field's name, which means a private field can never have name clash with a public field or method. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private element on the fly). Apart from this, a private field is pretty much equivalent to a normal property.

 js 

```
class Color {
  // Declare: every Color instance has a private field called #values.
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
console.log(red.getRed()); // 255
```

 

Accessing private fields outside the class is an early syntax error. The language can guard against this because `#privateField` is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code.

 js 

```
console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
```

 
 

 Note: 
Code run in the Chrome console can access private elements outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.

 

Private fields in JavaScript are hard private : if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same.

After we've made the `values` field private, we can add some more logic in the `getRed` and `setRed` methods, instead of making them simple pass-through methods. For example, we can add a check in `setRed` to see if it's a valid R value:

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  getRed() {
    return this.#values[0];
  }
  setRed(value) {
    if (value < 0 || value > 255) {
      throw new RangeError("Invalid R value");
    }
    this.#values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.setRed(1000); // RangeError: Invalid R value
```

 

If we leave the `values` property exposed, our users can easily circumvent that check by assigning to `values[0]` directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream.

A class method can read the private fields of other instances, as long as they belong to the same class.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    // #values doesn't necessarily need to be accessed from this:
    // you can access private fields of other instances belonging
    // to the same class.
    return this.#values[0] - anotherColor.#values[0];
  }
}

const red = new Color(255, 0, 0);
const crimson = new Color(220, 20, 60);
red.redDifference(crimson); // 35
```

 

However, if `anotherColor` is not a Color instance, `#values` won't exist. (Even if another class has an identically named `#values` private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private element throws an error instead of returning `undefined` like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using `try`/`catch` to handle the error, you can use the `in` operator.

 js 

```
class Color {
  #values;
  constructor(r, g, b) {
    this.#values = [r, g, b];
  }
  redDifference(anotherColor) {
    if (!(#values in anotherColor)) {
      throw new TypeError("Color instance expected");
    }
    return this.#values[0] - anotherColor.#values[0];
  }
}
```

 
 

 Note: 
Keep in mind that the `#` is a special identifier syntax, and you can't use the field name as if it's a string. `"#values" in anotherColor` would look for a property name literally called `"#values"`, instead of a private field.

 

There are some limitations in using private elements: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors.

 js 

```
class BadIdeas {
  #firstName;
  #firstName; // syntax error occurs here
  #lastName;
  constructor() {
    delete this.#lastName; // also a syntax error
  }
}
```

 

Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call.

For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it.

 js 

```
class Counter extends HTMLElement {
  #xValue = 0;
  constructor() {
    super();
    this.onclick = this.#clicked.bind(this);
  }
  get #x() {
    return this.#xValue;
  }
  set #x(value) {
    this.#xValue = value;
    window.requestAnimationFrame(this.#render.bind(this));
  }
  #clicked() {
    this.#x++;
  }
  #render() {
    this.textContent = this.#x.toString();
  }
  connectedCallback() {
    this.#render();
  }
}

customElements.define("num-counter", Counter);
```

 

In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of `Counter`.

 
 

## Accessor fields 

 
 

`color.getRed()` and `color.setRed()` allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an "actual property".

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
  set red(value) {
    this.values[0] = value;
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 0
```

 

It looks as if the object has a property called `red` — but actually, no such property exists on the instance! There are only two methods, but they are prefixed with `get` and `set`, which allows them to be manipulated as if they were properties.

If a field only has a getter but no setter, it will be effectively read-only.

 js 

```
class Color {
  constructor(r, g, b) {
    this.values = [r, g, b];
  }
  get red() {
    return this.values[0];
  }
}

const red = new Color(255, 0, 0);
red.red = 0;
console.log(red.red); // 255
```

 

In strict mode , the `red.red = 0` line will throw a type error: "Cannot set property red of #<Color> which has only a getter". In non-strict mode, the assignment is silently ignored.

 
 

## Public fields 

 
 

Private fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters.

 js 

```
class MyClass {
  luckyNumber = Math.random();
}
console.log(new MyClass().luckyNumber); // 0.5
console.log(new MyClass().luckyNumber); // 0.3
```

 

Public fields are almost equivalent to assigning a property to `this`. For example, the above example can also be converted to:

 js 

```
class MyClass {
  constructor() {
    this.luckyNumber = Math.random();
  }
}
```

 
 
 

## Static properties 

 
 

With the `Date` example, we have also encountered the `Date.now()` method, which returns the current date. This method does not belong to any date instance — it belongs to the class itself. However, it's put on the `Date` class instead of being exposed as a global `DateNow()` function, because it's mostly useful when dealing with date instances.

 

 Note: 
Prefixing utility methods with what they deal with is called "namespacing" and is considered a good practice. For example, in addition to the older, unprefixed `parseInt()` method, JavaScript also later added the prefixed `Number.parseInt()` method to indicate that it's for dealing with numbers.

 

 Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include:

- Static methods

- Static fields

- Static getters and setters

Everything also has private counterparts. For example, for our `Color` class, we can create a static method that checks whether a given triplet is a valid RGB value:

 js 

```
class Color {
  static isValid(r, g, b) {
    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;
  }
}

Color.isValid(255, 0, 0); // true
Color.isValid(1000, 0, 0); // false
```

 

Static properties are very similar to their instance counterparts, except that:

- They are all prefixed with `static`, and

- They are not accessible from instances.

 js 

```
console.log(new Color(0, 0, 0).isValid); // undefined
```

 

There is also a special construct called a static initialization block , which is a block of code that runs when the class is first loaded.

 js 

```
class MyClass {
  static {
    MyClass.myStaticProperty = "foo";
  }
}

console.log(MyClass.myStaticProperty); // 'foo'
```

 

Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private elements.

 
 

## Extends and inheritance 

 
 

A key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance , which means one object can "borrow" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic.

For example, suppose our `Color` class now needs to support transparency. We may be tempted to add a new field that indicates its transparency:

 js 

```
class Color {
  #values;
  constructor(r, g, b, a = 1) {
    this.#values = [r, g, b, a];
  }
  get alpha() {
    return this.#values[3];
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#values[3] = value;
  }
}
```

 

However, this means every instance — even the vast majority which aren't transparent (those with an alpha value of 1) — will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our `Color` class will become very bloated and hard to maintain.

Instead, in object-oriented programming, we would create a derived class . The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an `extends` clause, which indicates the class it extends from.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  constructor(r, g, b, a) {
    super(r, g, b);
    this.#alpha = a;
  }
  get alpha() {
    return this.#alpha;
  }
  set alpha(value) {
    if (value < 0 || value > 1) {
      throw new RangeError("Alpha value must be between 0 and 1");
    }
    this.#alpha = value;
  }
}
```

 

There are a few things that have immediately come to attention. First is that in the constructor, we are calling `super(r, g, b)`. It is a language requirement to call `super()` before accessing `this`. The `super()` call calls the parent class's constructor to initialize `this` — here it's roughly equivalent to `this = new Color(r, g, b)`. You can have code before `super()`, but you cannot access `this` before `super()` — the language prevents you from accessing the uninitialized `this`.

After the parent class is done with modifying `this`, the derived class can do its own logic. Here we added a private field called `#alpha`, and also provided a pair of getter/setters to interact with them.

A derived class inherits all methods from its parent. For example, consider the `get red()` accessor we added to the `Color` in the Accessor fields section—even though we haven't declared one in `ColorWithAlpha`, we can still access `red` because this behavior is specified by the parent class:

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color.red); // 255
```

 

Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the `Object` class, which defines some basic methods like `toString()` . However, the base `toString()` method is notoriously useless, because it prints `[object Object]` in most cases:

 js 

```
console.log(red.toString()); // [object Object]
```

 

Instead, our class can override it to print the color's RGB values:

 js 

```
class Color {
  #values;
  // …
  toString() {
    return this.#values.join(", ");
  }
}

console.log(new Color(255, 0, 0).toString()); // '255, 0, 0'
```

 

Within derived classes, you can access the parent class's methods by using `super`. This allows you to build enhancement methods and avoid code duplication.

 js 

```
class ColorWithAlpha extends Color {
  #alpha;
  // …
  toString() {
    // Call the parent class's toString() and build on the return value
    return `${super.toString()}, ${this.#alpha}`;
  }
}

console.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5'
```

 

When you use `extends`, the static methods inherit from each other as well, so you can also override or enhance them.

 js 

```
class ColorWithAlpha extends Color {
  // …
  static isValid(r, g, b, a) {
    // Call the parent class's isValid() and build on the return value
    return super.isValid(r, g, b) && a >= 0 && a <= 1;
  }
}

console.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false
```

 

Derived classes don't have access to the parent class's private fields — this is another key aspect to JavaScript private fields being "hard private". Private fields are scoped to the class body itself and do not grant access to any outside code.

 js 

```
class ColorWithAlpha extends Color {
  log() {
    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class
  }
}
```

 

A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem . However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins .

Instances of derived classes are also instances of the base class.

 js 

```
const color = new ColorWithAlpha(255, 0, 0, 0.5);
console.log(color instanceof Color); // true
console.log(color instanceof ColorWithAlpha); // true
```

 
 
 

## Why classes? 

 
 

The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends.

Classes introduce a paradigm , or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism ). However, many people are philosophically against certain OOP practices and don't use classes as a result.

For example, one thing that makes `Date` objects infamous is that they're mutable .

 js 

```
function incrementDay(date) {
  return date.setDate(date.getDate() + 1);
}
const date = new Date(); // 2019-06-19
const newDay = incrementDay(date);
console.log(newDay); // 2019-06-20
// The old date is modified as well!?
console.log(date); // 2019-06-20
```

 

Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with — because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program.

In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns.

 

However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient.

On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the `Color` class, we may need to create a dozen of utility functions:

 js 

```
function isRed(color) {
  return color.red === 255;
}
function isValidColor(color) {
  return (
    color.red >= 0 &&
    color.red <= 255 &&
    color.green >= 0 &&
    color.green <= 255 &&
    color.blue >= 0 &&
    color.blue <= 255
  );
}
// …
```

 

But with classes, we can congregate them all under the `Color` namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API.

In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples:

- The `Map` and `Set` classes store a collection of elements and allow you to access them by key using `get()`, `set()`, `has()`, etc.

- The `Date` class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components.

- The `Error` class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like `TypeError` and `ReferenceError` that extend `Error`. In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with `instanceof` .

JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 6, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#browser_compatibility

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#description

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#examples

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#specifications

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#see_also

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

Generally speaking, a function is a "subprogram" that can be called by code external (or internal, in the case of recursion) to the function. Like the program itself, a function is composed of a sequence of statements called the function body . Values can be passed to a function as parameters, and the function will return a value.

In JavaScript, functions are first-class objects , because they can be passed to other functions, returned from functions, and assigned to variables and properties. They can also have properties and methods just like any other object. What distinguishes them from other objects is that functions can be called.

For more examples and explanations, see the JavaScript guide about functions .

 
 
 
 
 
 

## Description 

 
 

Function values are typically instances of `Function` . See `Function` for information on properties and methods of `Function` objects. Callable values cause `typeof` to return `"function"` instead of `"object"`.

 

 Note: 
Not all callable values are `instanceof Function`. For example, the `Function.prototype` object is callable but not an instance of `Function`. You can also manually set the prototype chain of your function so it no longer inherits from `Function.prototype`. However, such cases are extremely rare.

 
 
 

### Return value 

 
 

By default, if a function's execution doesn't end at a `return` statement, or if the `return` keyword doesn't have an expression after it, then the return value is `undefined` . The `return` statement allows you to return an arbitrary value from the function. One function call can only return one value, but you can simulate the effect of returning multiple values by returning an object or array and destructuring the result.

 

 Note: 
Constructors called with `new` have a different set of logic to determine their return values.

 
 
 

### Passing arguments 

 
 

 Parameters and arguments have slightly different meanings, but in MDN web docs, we often use them interchangeably. For a quick reference:

 js 

```
function formatNumber(num) {
  return num.toFixed(2);
}

formatNumber(2);
```

 

In this example, the `num` variable is called the function's parameter : it's declared in the parenthesis-enclosed list of the function's definition. The function expects the `num` parameter to be a number — although this is not enforceable in JavaScript without writing runtime validation code. In the `formatNumber(2)` call, the number `2` is the function's argument : it's the value that is actually passed to the function in the function call. The argument value can be accessed inside the function body through the corresponding parameter name or the `arguments` object.

Arguments are always passed by value and never passed by reference . This means that if a function reassigns a parameter, the value won't change outside the function. More precisely, object arguments are passed by sharing , which means if the object's properties are mutated, the change will impact the outside of the function. For example:

 js 

```
function updateBrand(obj) {
  // Mutating the object is visible outside the function
  obj.brand = "Toyota";
  // Try to reassign the parameter, but this won't affect
  // the variable's value outside the function
  obj = null;
}

const car = {
  brand: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(car.brand); // Honda

// Pass object reference to the function
updateBrand(car);

// updateBrand mutates car
console.log(car.brand); // Toyota
```

 

The `this` keyword refers to the object that the function is accessed on — it does not refer to the currently executing function, so you must refer to the function value by name, even within the function body.

 
 

### Defining functions 

 
 

Broadly speaking, JavaScript has four kinds of functions:

- Regular function: can return anything; always runs to completion after invocation

- Generator function: returns a `Generator` object; can be paused and resumed with the `yield` operator

- Async function: returns a `Promise` ; can be paused and resumed with the `await` operator

- Async generator function: returns an `AsyncGenerator` object; both the `await` and `yield` operators can be used

For every kind of function, there are multiple ways to define it:

 
 Declaration 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Expression 
 

 `function` , `function*` , `async function` , `async function*` 

 
 Constructor 
 

 `Function()` , `GeneratorFunction()` , `AsyncFunction()` , `AsyncGeneratorFunction()` 

 
 

In addition, there are special syntaxes for defining arrow functions and methods , which provide more precise semantics for their usage. Classes are conceptually not functions (because they throw an error when called without `new`), but they also inherit from `Function.prototype` and have `typeof MyClass === "function"`.

 js 

```
// Constructor
const multiply = new Function("x", "y", "return x * y");

// Declaration
function multiply(x, y) {
  return x * y;
} // No need for semicolon here

// Expression; the function is anonymous but assigned to a variable
const multiply = function (x, y) {
  return x * y;
};
// Expression; the function has its own name
const multiply = function funcName(x, y) {
  return x * y;
};

// Arrow function
const multiply = (x, y) => x * y;

// Method
const obj = {
  multiply(x, y) {
    return x * y;
  },
};
```

 

All syntaxes do approximately the same thing, but there are some subtle behavior differences.

- The `Function()` constructor, `function` expression, and `function` declaration syntaxes create full-fledged function objects, which can be constructed with `new` . However, arrow functions and methods cannot be constructed. Async functions, generator functions, and async generator functions are not constructible regardless of syntax.

- The `function` declaration creates functions that are hoisted . Other syntaxes do not hoist the function and the function value is only visible after the definition.

- The arrow function and `Function()` constructor always create anonymous functions, which means they can't easily call themselves recursively. One way to call an arrow function recursively is by assigning it to a variable.

- The arrow function syntax does not have access to `arguments` or `this`.

- The `Function()` constructor cannot access any local variables — it only has access to the global scope.

- The `Function()` constructor causes runtime compilation and is often slower than other syntaxes.

For `function` expressions, there is a distinction between the function name and the variable the function is assigned to. The function name cannot be changed, while the variable the function is assigned to can be reassigned. The function name can be different from the variable the function is assigned to — they have no relation to each other. The function name can be used only within the function's body. Attempting to use it outside the function's body results in an error (or gets another value, if the same name is declared elsewhere). For example:

 js 

```
const y = function x() {};
console.log(x); // ReferenceError: x is not defined
```

 

On the other hand, the variable the function is assigned to is limited only by its scope, which is guaranteed to include the scope in which the function is declared.

A function declaration also creates a variable with the same name as the function name. Thus, unlike those defined by function expressions, functions defined by function declarations can be accessed by their name in the scope they were defined in, as well as in their own body.

A function defined by `new Function` will dynamically have its source assembled, which is observable when you serialize it. For example, `console.log(new Function().toString())` gives:

 js 

```
function anonymous(
) {

}
```

 

This is the actual source used to compile the function. However, although the `Function()` constructor will create the function with name `anonymous`, this name is not added to the scope of the body. The body only ever has access to global variables. For example, the following would result in an error:

 js 

```
new Function("alert(anonymous);")();
```

 

A function defined by a function expression or by a function declaration inherits the current scope. That is, the function forms a closure. On the other hand, a function defined by a `Function` constructor does not inherit any scope other than the global scope (which all functions inherit).

 js 

```
// p is a global variable
globalThis.p = 5;
function myFunc() {
  // p is a local variable
  const p = 9;

  function decl() {
    console.log(p);
  }
  const expr = function () {
    console.log(p);
  };
  const cons = new Function("\tconsole.log(p);");

  decl();
  expr();
  cons();
}
myFunc();

// Logs:
// 9 (for 'decl' by function declaration (current scope))
// 9 (for 'expr' by function expression (current scope))
// 5 (for 'cons' by Function constructor (global scope))
```

 

Functions defined by function expressions and function declarations are parsed only once, while a function defined by the `Function` constructor parses the string passed to it each and every time the constructor is called. Although a function expression creates a closure every time, the function body is not reparsed, so function expressions are still faster than `new Function(...)`. Therefore the `Function` constructor should generally be avoided whenever possible.

A function declaration may be unintentionally turned into a function expression when it appears in an expression context.

 js 

```
// A function declaration
function foo() {
  console.log("FOO!");
}

doSomething(
  // A function expression passed as an argument
  function foo() {
    console.log("FOO!");
  },
);
```

 

On the other hand, a function expression may also be turned into a function declaration. An expression statement cannot begin with the `function` or `async function` keywords, which is a common mistake when implementing IIFEs (Immediately Invoked Function Expressions).

 js 

```
function () { // SyntaxError: Function statements require a function name
  console.log("FOO!");
}();

function foo() {
  console.log("FOO!");
}(); // SyntaxError: Unexpected token ')'
```

 

Instead, start the expression statement with something else, so that the `function` keyword unambiguously starts a function expression. Common options include grouping and using `void` .

 js 

```
(function () {
  console.log("FOO!");
})();

void function () {
  console.log("FOO!");
}();
```

 
 
 

### Function parameters 

 
 

Each function parameter is a simple identifier that you can access in the local scope.

 js 

```
function myFunc(a, b, c) {
  // You can access the values of a, b, and c here
}
```

 

There are three special parameter syntaxes:

- Default parameters allow formal parameters to be initialized with default values if no value or `undefined` is passed.

- The rest parameter allows representing an indefinite number of arguments as an array.

- Destructuring allows unpacking elements from arrays, or properties from objects, into distinct variables.

 js 

```
function myFunc({ a, b }, c = 1, ...rest) {
  // You can access the values of a, b, c, and rest here
}
```

 

There are some consequences if one of the above non-simple parameter syntaxes is used:

- You cannot apply `"use strict"` to the function body — this causes a syntax error .

- Even if the function is not in strict mode , certain strict mode function features apply, including that the `arguments` object stops syncing with the named parameters, `arguments.callee` throws an error when accessed, and duplicate parameter names are not allowed.

 
 

### The arguments object 

 
 

You can refer to a function's arguments within the function by using the `arguments` object.

 
 `arguments` 
 

An array-like object containing the arguments passed to the currently executing function.

 
 `arguments.callee` 
 

The currently executing function.

 
 `arguments.length` 
 

The number of arguments passed to the function.

 
 
 
 

### Getter and setter functions 

 
 

You can define accessor properties on any standard built-in object or user-defined object that supports the addition of new properties. Within object literals and classes , you can use special syntaxes to define the getter and setter of an accessor property.

 
 get 
 

Binds an object property to a function that will be called when that property is looked up.

 
 set 
 

Binds an object property to a function to be called when there is an attempt to set that property.

 
 

Note that these syntaxes create an object property , not a method . The getter and setter functions themselves can only be accessed using reflective APIs such as `Object.getOwnPropertyDescriptor()` .

 
 

### Block-level functions 

 
 

In strict mode , functions inside blocks are scoped to that block. Prior to ES2015, block-level functions were forbidden in strict mode.

 js 

```
"use strict";

function f() {
  return 1;
}

{
  function f() {
    return 2;
  }
}

f() === 1; // true

// f() === 2 in non-strict mode
```

 
 
 

### Block-level functions in non-strict code 

 
 

In a word: Don't. 

In non-strict code, function declarations inside blocks behave strangely. For example:

 js 

```
if (shouldDefineZero) {
  function zero() {
    // DANGER: compatibility risk
    console.log("This is zero.");
  }
}
```

 

The semantics of this in strict mode are well-specified — `zero` only ever exists within that scope of the `if` block. If `shouldDefineZero` is false, then `zero` should never be defined, since the block never executes. However, historically, this was left unspecified, so different browsers implemented it differently in non-strict mode. For more information, see the `function` declaration reference.

A safer way to define functions conditionally is to assign a function expression to a variable:

 js 

```
// Using a var makes it available as a global variable,
// with closer behavior to a top-level function declaration
var zero;
if (shouldDefineZero) {
  zero = function () {
    console.log("This is zero.");
  };
}
```

 
 
 

## Examples 

 
 
 
 

### Returning a formatted number 

 
 

The following function returns a string containing the formatted representation of a number padded with leading zeros.

 js 

```
// This function returns a string padded with leading zeros
function padZeros(num, totalLen) {
  let numStr = num.toString(); // Initialize return value as string
  const numZeros = totalLen - numStr.length; // Calculate no. of zeros
  for (let i = 1; i <= numZeros; i++) {
    numStr = `0${numStr}`;
  }
  return numStr;
}
```

 

The following statements call the `padZeros` function.

 js 

```
let result;
result = padZeros(42, 4); // returns "0042"
result = padZeros(42, 2); // returns "42"
result = padZeros(5, 4); // returns "0005"
```

 
 
 

### Determining whether a function exists 

 
 

You can determine whether a function exists by using the `typeof` operator. In the following example, a test is performed to determine if the `window` object has a property called `noFunc` that is a function. If so, it is used; otherwise, some other action is taken.

 js 

```
if (typeof window.noFunc === "function") {
  // use noFunc()
} else {
  // do something else
}
```

 

Note that in the `if` test, a reference to `noFunc` is used — there are no parentheses `()` after the function name so the actual function is not called.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Classes 

- `function` 

- `function` expression 

- `Function` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Function - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function

Function - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Function

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `Function` object provides methods for functions . In JavaScript, every function is actually a `Function` object.

 
 
 
 
 
 

## Constructor 

 
 
 `Function()` 
 

Creates a new `Function` object. Calling the constructor directly can create functions dynamically but suffers from security and similar (but far less significant) performance issues to `eval()` . However, unlike `eval()`, the `Function` constructor creates functions that execute in the global scope only.

 
 
 
 

## Instance properties 

 
 

These properties are defined on `Function.prototype` and shared by all `Function` instances.

 
 `Function.prototype.arguments` 
 Deprecated 
 
 Non-standard 
 
 

Represents the arguments passed to this function. For strict , arrow, async, and generator functions, accessing the `arguments` property throws a `TypeError` . Use the `arguments` object inside function closures instead.

 
 `Function.prototype.caller` 
 Deprecated 
 
 Non-standard 
 
 

Represents the function that invoked this function. For strict , arrow, async, and generator functions, accessing the `caller` property throws a `TypeError` .

 
 `Function.prototype.constructor` 
 

The constructor function that created the instance object. For `Function` instances, the initial value is the `Function` constructor.

 
 

These properties are own properties of each `Function` instance.

 
 `displayName` 
 Non-standard 
 Optional 
 

The display name of the function.

 
 `length` 
 

Specifies the number of arguments expected by the function.

 
 `name` 
 

The name of the function.

 
 `prototype` 
 

Used when the function is used as a constructor with the `new` operator. It will become the new object's prototype.

 
 
 
 

## Instance methods 

 
 
 `Function.prototype.apply()` 
 

Calls a function with a given `this` value and optional arguments provided as an array (or an array-like object ).

 
 `Function.prototype.bind()` 
 

Creates a new function that, when called, has its `this` keyword set to a provided value, optionally with a given sequence of arguments preceding any provided when the new function is called.

 
 `Function.prototype.call()` 
 

Calls a function with a given `this` value and optional arguments.

 
 `Function.prototype.toString()` 
 

Returns a string representing the source code of the function.
Overrides the `Object.prototype.toString` method.

 
 `Function.prototype[Symbol.hasInstance]()` 
 

Specifies the default procedure for determining if a constructor function recognizes an object as one of the constructor's instances. Called by the `instanceof` operator.

 
 
 
 

## Examples 

 
 
 
 

### Difference between Function constructor and function declaration 

 
 

Functions created with the `Function` constructor do not create closures to their creation contexts; they always are created in the global scope. When running them, they will only be able to access their own local variables and global ones, not the ones from the scope in which the `Function` constructor was created. This is different from using `eval()` with code for a function expression.

 js 

```
// Create a global property with `var`
var x = 10;

function createFunction1() {
  const x = 20;
  return new Function("return x;"); // this `x` refers to global `x`
}

function createFunction2() {
  const x = 20;
  function f() {
    return x; // this `x` refers to the local `x` above
  }
  return f;
}

const f1 = createFunction1();
console.log(f1()); // 10
const f2 = createFunction2();
console.log(f2()); // 20
```

 

While this code works in web browsers, `f1()` will produce a `ReferenceError` in Node.js, as `x` will not be found. This is because the top-level scope in Node is not the global scope, and `x` will be local to the module.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-objects 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `function` 

- `function` expression 

- `AsyncFunction` 

- `AsyncGeneratorFunction` 

- `GeneratorFunction` 

- Functions 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#content

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#search

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#introduction

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#grammar_and_types

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#control_flow_and_error_handling

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#loops_and_iteration

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#functions

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript Guide - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide#expressions_and_operators

JavaScript Guide - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript Guide

 
 
 

The JavaScript Guide shows you how to use JavaScript and gives an overview of the language. If you need exhaustive information about a language feature, have a look at the JavaScript reference .

This Guide is divided into the following chapters.

 
 
 
 
 
 

## Introduction 

 
 

Overview: Introduction 

- About this guide 

- About JavaScript 

- JavaScript and Java 

- ECMAScript 

- Tools 

- What's next 

 
 

## Grammar and types 

 
 

Overview: Grammar and types 

- Basic syntax & comments 

- Declarations 

- Variable scope 

- Variable hoisting 

- Data structures and types 

- Literals 

 
 

## Control flow and error handling 

 
 

Overview: Control flow and error handling 

- `if...else` 

- `switch` 

- `try`/`catch`/`throw` 

- Error objects 

 
 

## Loops and iteration 

 
 

Overview: Loops and iteration 

- `for` 

- `while` 

- `do...while` 

- `continue` 

- `break` 

- `for...in` 

- `for...of` 

 
 

## Functions 

 
 

Overview: Functions 

- Defining functions 

- Calling functions 

- Function scopes and closures 

- Arguments & parameters 

- Arrow functions 

 
 

## Expressions and operators 

 
 

Overview: Expressions and operators 

- Assignment & Comparisons 

- Arithmetic operators 

- Bitwise & logical operators 

- Conditional (ternary) operator 

 
 

## Numbers and strings 

 
 

Overview: Numbers and strings 

- Numbers 

- `Number` object 

- `Math` object 

- Strings 

- `String` object 

- Template literals 

 
 

## Representing dates & times 

 
 

Overview: Representing dates & times 

- `Date` object 

 
 

## Regular expressions 

 
 

Overview: Regular expressions 

- Creating a regular expression 

- Writing a regular expression pattern 

 Assertions 

- Character classes 

- Groups and backreferences 

- Quantifiers 

 

 
 

## Indexed collections 

 
 

Overview: Indexed collections 

 
 

## Keyed collections 

 
 

Overview: Keyed collections 

- `Map` 

- `WeakMap` 

- `Set` 

- `WeakSet` 

 
 

## Working with objects 

 
 

Overview: Working with objects 

- Objects and properties 

- Creating objects 

- Defining methods 

- Getter and setter 

 
 

## Using classes 

 
 

Overview: Using classes 

- Declaring a class 

- Various class features 

- Extends and inheritance 

- Why classes? 

 
 

## Promises 

 
 

Overview: Promises 

- Guarantees 

- Chaining 

- Error handling 

- Composition 

- Timing 

 
 

## Typed arrays 

 
 

Overview: Typed arrays 

 
 

## Iterators and generators 

 
 

Overview: Iterators and generators 

- Iterators 

- Iterables 

- Generators 

 
 

## Resource management 

 
 

Overview: JavaScript resource management 

- The `using` and `await using` declarations 

- The `DisposableStack` and `AsyncDisposableStack` objects 

- Error handling 

 
 

## Internationalization 

 
 

Overview: Internationalization 

- Date and time formatting 

- Number formatting 

- Collation 

 
 

## JavaScript modules 

 
 

Overview: JavaScript modules 

- Exporting 

- Importing 

- Default exports 

- Renaming features 

- Aggregating modules 

- Dynamic module loading 

 
 

## Advanced topics 

 
 

After you have learned all fundamental features of JavaScript, you can explore some more niche features, or dive deeper into the language's mechanisms and concepts.

- Language overview 

- Data structures 

- Enumerability and ownership of properties 

- Inheritance and the prototype chain 

- Equality comparisons and sameness 

- Closures 

- Meta programming 

- Memory management 

- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 7, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#statements

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#expressions_and_operators

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#functions

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#classes

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#regular_expressions

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#additional_reference_pages

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript reference - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference#value_properties

JavaScript reference - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript reference

 
 
 

The JavaScript reference serves as a repository of facts about the JavaScript language. The entire language is described here in detail. As you write JavaScript code, you'll refer to these pages often (thus the title "JavaScript reference").

The JavaScript language is intended to be used within some larger environment, be it a browser, server-side scripts, or similar. For the most part, this reference attempts to be environment-agnostic and does not target a web browser environment.

If you are new to JavaScript, start with the guide . Once you have a firm grasp of the fundamentals, you can use the reference to get more details on individual objects and language constructs.

 
 
 
 
 
 

## Built-ins 

 
 

 JavaScript standard built-in objects , along with their methods and properties.

 
 

### Value properties 

 
 

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

- `Array` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 

## Statements 

 
 

 JavaScript statements and declarations 

 
 

### Control flow 

 
 

- `return` 

- `break` 

- `continue` 

- `throw` 

- `if...else` 

- `switch` 

- `try...catch` 

 
 

### Declaring variables 

 
 

- `var` 

- `let` 

- `const` 

- `using` 

- `await using` 

 
 

### Functions and classes 

 
 

- `function` 

- `function*` 

- `async function` 

- `async function*` 

- `class` 

 
 

### Iterations 

 
 

- `do...while` 

- `for` 

- `for...in` 

- `for...of` 

- `for await...of` 

- `while` 

 
 

### Others 

 
 

- Empty 

- Block 

- Expression statement 

- `debugger` 

- `export` 

- `import` 

- label 

- `with` 
 Deprecated 
 

 
 

## Expressions and operators 

 
 

 JavaScript expressions and operators .

 
 

### Primary expressions 

 
 

- `this` 

- Literals 

- `[]` 

- `{}` 

- `function` 

- `class` 

- `function*` 

- `async function` 

- `async function*` 

- `/ab+c/i` 

- ``string`` 

- `( )` 

 
 

### Left-hand-side expressions 

 
 

- Property accessors 

- `?.` 

- `new` 

- `new.target` 

- `import.meta` 

- `super` 

- `import()` 

 
 

### Increment and decrement 

 
 

- `A++` 

- `A--` 

- `++A` 

- `--A` 

 
 

### Unary operators 

 
 

- `delete` 

- `void` 

- `typeof` 

- `+` 

- `-` 

- `~` 

- `!` 

- `await` 

 
 

### Arithmetic operators 

 
 

- `**` 

- `*` 

- `/` 

- `%` 

- `+` (Plus)

- `-` 

 
 

### Relational operators 

 
 

- ` (Less than)

- `>` (Greater than)

- ` 

- `>=` 

- `instanceof` 

- `in` 

 
 

### Equality operators 

 
 

- `==` 

- `!=` 

- `===` 

- `!==` 

 
 

### Bitwise shift operators 

 
 

- ` 

- `>>` 

- `>>>` 

 
 

### Binary bitwise operators 

 
 

- `&` 

- `|` 

- `^` 

 
 

### Binary logical operators 

 
 

- `&&` 

- `||` 

- `??` 

 
 

### Conditional (ternary) operator 

 
 

- `(condition ? ifTrue : ifFalse)` 

 
 

### Assignment operators 

 
 

- `=` 

- `*=` 

- `/=` 

- `%=` 

- `+=` 

- `-=` 

- ` 

- `>>=` 

- `>>>=` 

- `&=` 

- `^=` 

- `|=` 

- `**=` 

- `&&=` 

- `||=` 

- `??=` 

- `[a, b] = arr`, `{ a, b } = obj` 

 
 

### Yield operators 

 
 

- `yield` 

- `yield*` 

 
 

### Spread syntax 

 
 

- `...obj` 

 
 

### Comma operator 

 
 

- `,` 

 
 

## Functions 

 
 

 JavaScript functions. 

- Arrow Functions 

- Default parameters 

- Rest parameters 

- `arguments` 

- Method definitions 

- getter 

- setter 

 
 

## Classes 

 
 

 JavaScript classes. 

- `constructor` 

- `extends` 

- Private elements 

- Public class fields 

- `static` 

- Static initialization blocks 

 
 

## Regular expressions 

 
 

 JavaScript regular expressions. 

- Backreference: `\1`, `\2` 

- Capturing group: `(...)` 

- Character class: `[...]`, `[^...]` 

- Character class escape: `\d`, `\D`, `\w`, `\W`, `\s`, `\S` 

- Character escape: `\n`, `\u{...}` 

- Disjunction: `|` 

- Input boundary assertion: `^`, `$` 

- Literal character: `a`, `b` 

- Lookahead assertion: `(?=...)`, `(?!...)` 

- Lookbehind assertion: `(? 

- Modifier: `(?ims-ims:...)` 

- Named backreference: `\k ` 

- Named capturing group: `(? ...)` 

- Non-capturing group: `(?:...)` 

- Quantifier: `*`, `+`, `?`, `{n}`, `{n,}`, `{n,m}` 

- Unicode character class escape: `\p{...}`, `\P{...}` 

- Wildcard: `.` 

- Word boundary assertion: `\b`, `\B` 

 
 

## Additional reference pages 

 
 

- JavaScript technologies overview 

- Execution model 

- Lexical grammar 

- Data types and data structures 

- Iteration protocols 

- Trailing commas 

- Errors 

- Strict mode 

- Deprecated features 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Control flow and error handling - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#block_statement

Control flow and error handling - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Control flow and error handling

 
 
 
- Previous 
- Next 

JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.

The JavaScript reference 
contains exhaustive details about the statements in this chapter. The semicolon
(`;`) character is used to separate statements in JavaScript code.

Any JavaScript expression is also a statement.
See Expressions and operators 
for complete information about expressions.

 
 
 
 
 
 

## Block statement 

 
 

The most basic statement is a block statement , which is used to group
statements. The block is delimited by a pair of curly braces:

 js 

```
{
  statement1;
  statement2;
  // …
  statementN;
}
```

 
 
 

### Example 

 
 

Block statements are commonly used with control flow statements (`if`,
`for`, `while`).

 js 

```
while (x < 10) {
  x++;
}
```

 

Here, `{ x++; }` is the block statement.

 

 Note: 
 `var` -declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This outputs `2` because the `var x` statement within the block is in the same scope as the `var x` statement before the block. (In C or Java, the equivalent code would have output `1`.)

This scoping effect can be mitigated by using `let` or `const` .

 
 
 

## Conditional statements 

 
 

A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: `if...else` and
`switch`.

 
 

### if...else statement 

 
 

Use the `if` statement to execute a statement if a logical condition is
`true`. Use the optional `else` clause to execute a statement if
the condition is `false`.

An `if` statement looks like this:

 js 

```
if (condition) {
  statement1;
} else {
  statement2;
}
```

 

Here, the `condition` can be any expression that evaluates to
`true` or `false`. (See Boolean 
for an explanation of what evaluates to `true` and `false`.)

If `condition` evaluates to `true`,
`statement1` is executed. Otherwise,
`statement2` is executed. `statement1` and
`statement2` can be any statement, including further nested
`if` statements.

You can also compound the statements using `else if` to have multiple
conditions tested in sequence, as follows:

 js 

```
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

 

In the case of multiple conditions, only the first logical condition which evaluates to
`true` will be executed. To execute multiple statements, group them within a
block statement (`{ /* … */ }`).

#### Best practice

In general, it's good practice to always use block statements— especially when
nesting `if` statements:

 js 

```
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
```

 

In general it's good practice to not have an `if...else` with an assignment like `x = y` as a condition:

 js 

```
if (x = y) {
  // statements here
}
```

 

However, in the rare case you find yourself wanting to do something like that, the `while` documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.

#### Falsy values

The following values evaluate to `false` (also known as Falsy values):

- `false`

- `undefined`

- `null`

- `0`

- `NaN`

- the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a
conditional statement.

 

 Note: 
Do not confuse the primitive boolean values
`true` and `false` with the true and false values of the
 `Boolean` object!

For example:

 js 

```
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```

 
 

#### Example

In the following example, the function `checkData` returns `true`
if the number of characters in a `Text` object is three. Otherwise, it
displays an alert and returns `false`.

 js 

```
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  }
  alert(
    `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
  );
  return false;
}
```

 
 
 

### switch statement 

 
 

A `switch` statement allows a program to evaluate an expression and attempt
to match the expression's value to a `case` label. If a match is found, the
program executes the associated statement.

A `switch` statement looks like this:

 js 

```
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

 

JavaScript evaluates the above switch statement as follows:

- The program first looks for a `case` clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.

- If no matching label is found, the program looks for the optional
`default` clause:

 If a `default` clause is found, the program transfers control to that
clause, executing the associated statements.

- If no `default` clause is found, the program resumes execution at the
statement following the end of `switch`.

- (By convention, the `default` clause is written as the last clause,
but it does not need to be so.)

 

#### break statements

The optional `break` statement associated with each `case` clause
ensures that the program breaks out of `switch` once the matched statement is
executed, and then continues execution at the statement following `switch`.
If `break` is omitted, the program continues execution inside the
`switch` statement (and will execute statements under the next `case`, and so on).

 Example 

In the following example, if `fruitType` evaluates to
`"Bananas"`, the program matches the value with `case "Bananas"`
and executes the associated statement. When `break` is encountered, the
program exits the `switch` and continues execution from the statement
following `switch`. If `break` were omitted, the statement for
`case "Cherries"` would also be executed.

 js 

```
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
```

 
 
 

## Exception handling statements 

 
 

You can throw exceptions using the `throw` statement and handle them using
the `try...catch` statements.

- `throw` statement 

- `try...catch` statement 

 
 

### Exception types 

 
 

Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

- ECMAScript exceptions 

- `DOMException` 

 
 

### throw statement 

 
 

Use the `throw` statement to throw an exception. A `throw`
statement specifies the value to be thrown:

 js 

```
throw expression;
```

 

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:

 js 

```
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
```

 
 
 

### try...catch statement 

 
 

The `try...catch` statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the `try...catch` statement catches it.

The `try...catch` statement consists of a `try` block, which
contains one or more statements, and a `catch` block, containing statements
that specify what to do if an exception is thrown in the `try` block.

In other words, you want the `try` block to succeed—but if it does not, you
want control to pass to the `catch` block. If any statement within the
`try` block (or in a function called from within the `try` block)
throws an exception, control immediately shifts to the `catch`
block. If no exception is thrown in the `try` block, the `catch`
block is skipped. The `finally` block executes after the `try` and
`catch` blocks execute but before the statements following the
`try...catch` statement.

The following example uses a `try...catch` statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(`1` – `12`), an exception is thrown with the value
`'Invalid month code'` and the statements in the `catch` block set the
`monthName` variable to `'unknown'`.

 js 

```
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  // prettier-ignore
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (!months[mo]) {
    throw new Error("Invalid month code"); // throw keyword is used here
  }
  return months[mo];
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
```

 

#### The catch block

You can use a `catch` block to handle all exceptions that may be generated
in the `try` block.

 js 

```
catch (exception) {
  statements
}
```

 

The `catch` block specifies an identifier (`exception`
in the preceding syntax) that holds the value specified by the `throw`
statement. You can use this identifier to get information about the exception that was
thrown.

JavaScript creates this identifier when the `catch` block is entered. The
identifier lasts only for the duration of the `catch` block. Once the
`catch` block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control
transfers to the `catch` block.

 js 

```
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
```

 
 

 Note: 
When logging errors to the console inside
a `catch` block, using `console.error()` rather than
`console.log()` is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

 

#### The finally block

The `finally` block contains statements to be executed after the
`try` and `catch` blocks execute. Additionally, the
`finally` block executes before the code that follows the
`try...catch...finally` statement.

It is also important to note that the `finally` block will execute
 whether or not an exception is thrown. If an exception is thrown, however, the
statements in the `finally` block execute even if no `catch` block
handles the exception that was thrown.

You can use the `finally` block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.

The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the `finally` block closes the file before the script fails.
Using `finally` here ensures that the file is never left open, even
if an error occurs.

 js 

```
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

 

If the `finally` block returns a value, this value becomes the return value
of the entire `try...catch...finally` production, regardless of any
`return` statements in the `try` and `catch` blocks:

 js 

```
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    // `f` exits here
    console.log(4); // not reachable
  }
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

 

Overwriting of return values by the `finally` block also applies to
exceptions thrown or re-thrown inside of the `catch` block:

 js 

```
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
    // `f` exits here
  }
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

 

#### Nesting try...catch statements

You can nest one or more `try...catch` statements.

If an inner `try` block does not have a corresponding
`catch` block:

- it must contain a `finally` block, and

- the enclosing `try...catch` statement's `catch` block is
checked for a match.

For more information, see nested try-blocks 
on the `try...catch` 
reference page.

 
 

### Utilizing Error objects 

 
 

Depending on the type of error, you may be able to use the `name` and
`message` properties to get a more refined message.

The `name` property provides the general class of `Error` (such
as `DOMException` or `Error`), while `message`
generally provides a more succinct message than one would get by converting the error
object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your `catch` block doesn't discriminate between your own
exceptions and system ones), you can use the `Error` constructor.

For example:

 js 

```
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  }
  doSomethingToGetAJavaScriptError();
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Control flow and error handling - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#conditional_statements

Control flow and error handling - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Control flow and error handling

 
 
 
- Previous 
- Next 

JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.

The JavaScript reference 
contains exhaustive details about the statements in this chapter. The semicolon
(`;`) character is used to separate statements in JavaScript code.

Any JavaScript expression is also a statement.
See Expressions and operators 
for complete information about expressions.

 
 
 
 
 
 

## Block statement 

 
 

The most basic statement is a block statement , which is used to group
statements. The block is delimited by a pair of curly braces:

 js 

```
{
  statement1;
  statement2;
  // …
  statementN;
}
```

 
 
 

### Example 

 
 

Block statements are commonly used with control flow statements (`if`,
`for`, `while`).

 js 

```
while (x < 10) {
  x++;
}
```

 

Here, `{ x++; }` is the block statement.

 

 Note: 
 `var` -declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This outputs `2` because the `var x` statement within the block is in the same scope as the `var x` statement before the block. (In C or Java, the equivalent code would have output `1`.)

This scoping effect can be mitigated by using `let` or `const` .

 
 
 

## Conditional statements 

 
 

A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: `if...else` and
`switch`.

 
 

### if...else statement 

 
 

Use the `if` statement to execute a statement if a logical condition is
`true`. Use the optional `else` clause to execute a statement if
the condition is `false`.

An `if` statement looks like this:

 js 

```
if (condition) {
  statement1;
} else {
  statement2;
}
```

 

Here, the `condition` can be any expression that evaluates to
`true` or `false`. (See Boolean 
for an explanation of what evaluates to `true` and `false`.)

If `condition` evaluates to `true`,
`statement1` is executed. Otherwise,
`statement2` is executed. `statement1` and
`statement2` can be any statement, including further nested
`if` statements.

You can also compound the statements using `else if` to have multiple
conditions tested in sequence, as follows:

 js 

```
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

 

In the case of multiple conditions, only the first logical condition which evaluates to
`true` will be executed. To execute multiple statements, group them within a
block statement (`{ /* … */ }`).

#### Best practice

In general, it's good practice to always use block statements— especially when
nesting `if` statements:

 js 

```
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
```

 

In general it's good practice to not have an `if...else` with an assignment like `x = y` as a condition:

 js 

```
if (x = y) {
  // statements here
}
```

 

However, in the rare case you find yourself wanting to do something like that, the `while` documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.

#### Falsy values

The following values evaluate to `false` (also known as Falsy values):

- `false`

- `undefined`

- `null`

- `0`

- `NaN`

- the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a
conditional statement.

 

 Note: 
Do not confuse the primitive boolean values
`true` and `false` with the true and false values of the
 `Boolean` object!

For example:

 js 

```
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```

 
 

#### Example

In the following example, the function `checkData` returns `true`
if the number of characters in a `Text` object is three. Otherwise, it
displays an alert and returns `false`.

 js 

```
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  }
  alert(
    `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
  );
  return false;
}
```

 
 
 

### switch statement 

 
 

A `switch` statement allows a program to evaluate an expression and attempt
to match the expression's value to a `case` label. If a match is found, the
program executes the associated statement.

A `switch` statement looks like this:

 js 

```
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

 

JavaScript evaluates the above switch statement as follows:

- The program first looks for a `case` clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.

- If no matching label is found, the program looks for the optional
`default` clause:

 If a `default` clause is found, the program transfers control to that
clause, executing the associated statements.

- If no `default` clause is found, the program resumes execution at the
statement following the end of `switch`.

- (By convention, the `default` clause is written as the last clause,
but it does not need to be so.)

 

#### break statements

The optional `break` statement associated with each `case` clause
ensures that the program breaks out of `switch` once the matched statement is
executed, and then continues execution at the statement following `switch`.
If `break` is omitted, the program continues execution inside the
`switch` statement (and will execute statements under the next `case`, and so on).

 Example 

In the following example, if `fruitType` evaluates to
`"Bananas"`, the program matches the value with `case "Bananas"`
and executes the associated statement. When `break` is encountered, the
program exits the `switch` and continues execution from the statement
following `switch`. If `break` were omitted, the statement for
`case "Cherries"` would also be executed.

 js 

```
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
```

 
 
 

## Exception handling statements 

 
 

You can throw exceptions using the `throw` statement and handle them using
the `try...catch` statements.

- `throw` statement 

- `try...catch` statement 

 
 

### Exception types 

 
 

Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

- ECMAScript exceptions 

- `DOMException` 

 
 

### throw statement 

 
 

Use the `throw` statement to throw an exception. A `throw`
statement specifies the value to be thrown:

 js 

```
throw expression;
```

 

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:

 js 

```
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
```

 
 
 

### try...catch statement 

 
 

The `try...catch` statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the `try...catch` statement catches it.

The `try...catch` statement consists of a `try` block, which
contains one or more statements, and a `catch` block, containing statements
that specify what to do if an exception is thrown in the `try` block.

In other words, you want the `try` block to succeed—but if it does not, you
want control to pass to the `catch` block. If any statement within the
`try` block (or in a function called from within the `try` block)
throws an exception, control immediately shifts to the `catch`
block. If no exception is thrown in the `try` block, the `catch`
block is skipped. The `finally` block executes after the `try` and
`catch` blocks execute but before the statements following the
`try...catch` statement.

The following example uses a `try...catch` statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(`1` – `12`), an exception is thrown with the value
`'Invalid month code'` and the statements in the `catch` block set the
`monthName` variable to `'unknown'`.

 js 

```
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  // prettier-ignore
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (!months[mo]) {
    throw new Error("Invalid month code"); // throw keyword is used here
  }
  return months[mo];
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
```

 

#### The catch block

You can use a `catch` block to handle all exceptions that may be generated
in the `try` block.

 js 

```
catch (exception) {
  statements
}
```

 

The `catch` block specifies an identifier (`exception`
in the preceding syntax) that holds the value specified by the `throw`
statement. You can use this identifier to get information about the exception that was
thrown.

JavaScript creates this identifier when the `catch` block is entered. The
identifier lasts only for the duration of the `catch` block. Once the
`catch` block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control
transfers to the `catch` block.

 js 

```
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
```

 
 

 Note: 
When logging errors to the console inside
a `catch` block, using `console.error()` rather than
`console.log()` is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

 

#### The finally block

The `finally` block contains statements to be executed after the
`try` and `catch` blocks execute. Additionally, the
`finally` block executes before the code that follows the
`try...catch...finally` statement.

It is also important to note that the `finally` block will execute
 whether or not an exception is thrown. If an exception is thrown, however, the
statements in the `finally` block execute even if no `catch` block
handles the exception that was thrown.

You can use the `finally` block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.

The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the `finally` block closes the file before the script fails.
Using `finally` here ensures that the file is never left open, even
if an error occurs.

 js 

```
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

 

If the `finally` block returns a value, this value becomes the return value
of the entire `try...catch...finally` production, regardless of any
`return` statements in the `try` and `catch` blocks:

 js 

```
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    // `f` exits here
    console.log(4); // not reachable
  }
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

 

Overwriting of return values by the `finally` block also applies to
exceptions thrown or re-thrown inside of the `catch` block:

 js 

```
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
    // `f` exits here
  }
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

 

#### Nesting try...catch statements

You can nest one or more `try...catch` statements.

If an inner `try` block does not have a corresponding
`catch` block:

- it must contain a `finally` block, and

- the enclosing `try...catch` statement's `catch` block is
checked for a match.

For more information, see nested try-blocks 
on the `try...catch` 
reference page.

 
 

### Utilizing Error objects 

 
 

Depending on the type of error, you may be able to use the `name` and
`message` properties to get a more refined message.

The `name` property provides the general class of `Error` (such
as `DOMException` or `Error`), while `message`
generally provides a more succinct message than one would get by converting the error
object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your `catch` block doesn't discriminate between your own
exceptions and system ones), you can use the `Error` constructor.

For example:

 js 

```
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  }
  doSomethingToGetAJavaScriptError();
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Control flow and error handling - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#exception_handling_statements

Control flow and error handling - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Control flow and error handling

 
 
 
- Previous 
- Next 

JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.

The JavaScript reference 
contains exhaustive details about the statements in this chapter. The semicolon
(`;`) character is used to separate statements in JavaScript code.

Any JavaScript expression is also a statement.
See Expressions and operators 
for complete information about expressions.

 
 
 
 
 
 

## Block statement 

 
 

The most basic statement is a block statement , which is used to group
statements. The block is delimited by a pair of curly braces:

 js 

```
{
  statement1;
  statement2;
  // …
  statementN;
}
```

 
 
 

### Example 

 
 

Block statements are commonly used with control flow statements (`if`,
`for`, `while`).

 js 

```
while (x < 10) {
  x++;
}
```

 

Here, `{ x++; }` is the block statement.

 

 Note: 
 `var` -declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This outputs `2` because the `var x` statement within the block is in the same scope as the `var x` statement before the block. (In C or Java, the equivalent code would have output `1`.)

This scoping effect can be mitigated by using `let` or `const` .

 
 
 

## Conditional statements 

 
 

A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: `if...else` and
`switch`.

 
 

### if...else statement 

 
 

Use the `if` statement to execute a statement if a logical condition is
`true`. Use the optional `else` clause to execute a statement if
the condition is `false`.

An `if` statement looks like this:

 js 

```
if (condition) {
  statement1;
} else {
  statement2;
}
```

 

Here, the `condition` can be any expression that evaluates to
`true` or `false`. (See Boolean 
for an explanation of what evaluates to `true` and `false`.)

If `condition` evaluates to `true`,
`statement1` is executed. Otherwise,
`statement2` is executed. `statement1` and
`statement2` can be any statement, including further nested
`if` statements.

You can also compound the statements using `else if` to have multiple
conditions tested in sequence, as follows:

 js 

```
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

 

In the case of multiple conditions, only the first logical condition which evaluates to
`true` will be executed. To execute multiple statements, group them within a
block statement (`{ /* … */ }`).

#### Best practice

In general, it's good practice to always use block statements— especially when
nesting `if` statements:

 js 

```
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
```

 

In general it's good practice to not have an `if...else` with an assignment like `x = y` as a condition:

 js 

```
if (x = y) {
  // statements here
}
```

 

However, in the rare case you find yourself wanting to do something like that, the `while` documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.

#### Falsy values

The following values evaluate to `false` (also known as Falsy values):

- `false`

- `undefined`

- `null`

- `0`

- `NaN`

- the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a
conditional statement.

 

 Note: 
Do not confuse the primitive boolean values
`true` and `false` with the true and false values of the
 `Boolean` object!

For example:

 js 

```
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```

 
 

#### Example

In the following example, the function `checkData` returns `true`
if the number of characters in a `Text` object is three. Otherwise, it
displays an alert and returns `false`.

 js 

```
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  }
  alert(
    `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
  );
  return false;
}
```

 
 
 

### switch statement 

 
 

A `switch` statement allows a program to evaluate an expression and attempt
to match the expression's value to a `case` label. If a match is found, the
program executes the associated statement.

A `switch` statement looks like this:

 js 

```
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

 

JavaScript evaluates the above switch statement as follows:

- The program first looks for a `case` clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.

- If no matching label is found, the program looks for the optional
`default` clause:

 If a `default` clause is found, the program transfers control to that
clause, executing the associated statements.

- If no `default` clause is found, the program resumes execution at the
statement following the end of `switch`.

- (By convention, the `default` clause is written as the last clause,
but it does not need to be so.)

 

#### break statements

The optional `break` statement associated with each `case` clause
ensures that the program breaks out of `switch` once the matched statement is
executed, and then continues execution at the statement following `switch`.
If `break` is omitted, the program continues execution inside the
`switch` statement (and will execute statements under the next `case`, and so on).

 Example 

In the following example, if `fruitType` evaluates to
`"Bananas"`, the program matches the value with `case "Bananas"`
and executes the associated statement. When `break` is encountered, the
program exits the `switch` and continues execution from the statement
following `switch`. If `break` were omitted, the statement for
`case "Cherries"` would also be executed.

 js 

```
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
```

 
 
 

## Exception handling statements 

 
 

You can throw exceptions using the `throw` statement and handle them using
the `try...catch` statements.

- `throw` statement 

- `try...catch` statement 

 
 

### Exception types 

 
 

Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

- ECMAScript exceptions 

- `DOMException` 

 
 

### throw statement 

 
 

Use the `throw` statement to throw an exception. A `throw`
statement specifies the value to be thrown:

 js 

```
throw expression;
```

 

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:

 js 

```
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
```

 
 
 

### try...catch statement 

 
 

The `try...catch` statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the `try...catch` statement catches it.

The `try...catch` statement consists of a `try` block, which
contains one or more statements, and a `catch` block, containing statements
that specify what to do if an exception is thrown in the `try` block.

In other words, you want the `try` block to succeed—but if it does not, you
want control to pass to the `catch` block. If any statement within the
`try` block (or in a function called from within the `try` block)
throws an exception, control immediately shifts to the `catch`
block. If no exception is thrown in the `try` block, the `catch`
block is skipped. The `finally` block executes after the `try` and
`catch` blocks execute but before the statements following the
`try...catch` statement.

The following example uses a `try...catch` statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(`1` – `12`), an exception is thrown with the value
`'Invalid month code'` and the statements in the `catch` block set the
`monthName` variable to `'unknown'`.

 js 

```
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  // prettier-ignore
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (!months[mo]) {
    throw new Error("Invalid month code"); // throw keyword is used here
  }
  return months[mo];
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
```

 

#### The catch block

You can use a `catch` block to handle all exceptions that may be generated
in the `try` block.

 js 

```
catch (exception) {
  statements
}
```

 

The `catch` block specifies an identifier (`exception`
in the preceding syntax) that holds the value specified by the `throw`
statement. You can use this identifier to get information about the exception that was
thrown.

JavaScript creates this identifier when the `catch` block is entered. The
identifier lasts only for the duration of the `catch` block. Once the
`catch` block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control
transfers to the `catch` block.

 js 

```
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
```

 
 

 Note: 
When logging errors to the console inside
a `catch` block, using `console.error()` rather than
`console.log()` is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

 

#### The finally block

The `finally` block contains statements to be executed after the
`try` and `catch` blocks execute. Additionally, the
`finally` block executes before the code that follows the
`try...catch...finally` statement.

It is also important to note that the `finally` block will execute
 whether or not an exception is thrown. If an exception is thrown, however, the
statements in the `finally` block execute even if no `catch` block
handles the exception that was thrown.

You can use the `finally` block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.

The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the `finally` block closes the file before the script fails.
Using `finally` here ensures that the file is never left open, even
if an error occurs.

 js 

```
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

 

If the `finally` block returns a value, this value becomes the return value
of the entire `try...catch...finally` production, regardless of any
`return` statements in the `try` and `catch` blocks:

 js 

```
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    // `f` exits here
    console.log(4); // not reachable
  }
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

 

Overwriting of return values by the `finally` block also applies to
exceptions thrown or re-thrown inside of the `catch` block:

 js 

```
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
    // `f` exits here
  }
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

 

#### Nesting try...catch statements

You can nest one or more `try...catch` statements.

If an inner `try` block does not have a corresponding
`catch` block:

- it must contain a `finally` block, and

- the enclosing `try...catch` statement's `catch` block is
checked for a match.

For more information, see nested try-blocks 
on the `try...catch` 
reference page.

 
 

### Utilizing Error objects 

 
 

Depending on the type of error, you may be able to use the `name` and
`message` properties to get a more refined message.

The `name` property provides the general class of `Error` (such
as `DOMException` or `Error`), while `message`
generally provides a more succinct message than one would get by converting the error
object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your `catch` block doesn't discriminate between your own
exceptions and system ones), you can use the `Error` constructor.

For example:

 js 

```
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  }
  doSomethingToGetAJavaScriptError();
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Control flow and error handling - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#example

Control flow and error handling - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Control flow and error handling

 
 
 
- Previous 
- Next 

JavaScript supports a compact set of statements, specifically
control flow statements, that you can use to incorporate a great deal of interactivity
in your application. This chapter provides an overview of these statements.

The JavaScript reference 
contains exhaustive details about the statements in this chapter. The semicolon
(`;`) character is used to separate statements in JavaScript code.

Any JavaScript expression is also a statement.
See Expressions and operators 
for complete information about expressions.

 
 
 
 
 
 

## Block statement 

 
 

The most basic statement is a block statement , which is used to group
statements. The block is delimited by a pair of curly braces:

 js 

```
{
  statement1;
  statement2;
  // …
  statementN;
}
```

 
 
 

### Example 

 
 

Block statements are commonly used with control flow statements (`if`,
`for`, `while`).

 js 

```
while (x < 10) {
  x++;
}
```

 

Here, `{ x++; }` is the block statement.

 

 Note: 
 `var` -declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This outputs `2` because the `var x` statement within the block is in the same scope as the `var x` statement before the block. (In C or Java, the equivalent code would have output `1`.)

This scoping effect can be mitigated by using `let` or `const` .

 
 
 

## Conditional statements 

 
 

A conditional statement is a set of commands that executes if a specified condition is
true. JavaScript supports two conditional statements: `if...else` and
`switch`.

 
 

### if...else statement 

 
 

Use the `if` statement to execute a statement if a logical condition is
`true`. Use the optional `else` clause to execute a statement if
the condition is `false`.

An `if` statement looks like this:

 js 

```
if (condition) {
  statement1;
} else {
  statement2;
}
```

 

Here, the `condition` can be any expression that evaluates to
`true` or `false`. (See Boolean 
for an explanation of what evaluates to `true` and `false`.)

If `condition` evaluates to `true`,
`statement1` is executed. Otherwise,
`statement2` is executed. `statement1` and
`statement2` can be any statement, including further nested
`if` statements.

You can also compound the statements using `else if` to have multiple
conditions tested in sequence, as follows:

 js 

```
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
```

 

In the case of multiple conditions, only the first logical condition which evaluates to
`true` will be executed. To execute multiple statements, group them within a
block statement (`{ /* … */ }`).

#### Best practice

In general, it's good practice to always use block statements— especially when
nesting `if` statements:

 js 

```
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
```

 

In general it's good practice to not have an `if...else` with an assignment like `x = y` as a condition:

 js 

```
if (x = y) {
  // statements here
}
```

 

However, in the rare case you find yourself wanting to do something like that, the `while` documentation has a Using an assignment as a condition section with guidance on a general best-practice syntax you should know about and follow.

#### Falsy values

The following values evaluate to `false` (also known as Falsy values):

- `false`

- `undefined`

- `null`

- `0`

- `NaN`

- the empty string (`""`)

All other values—including all objects—evaluate to `true` when passed to a
conditional statement.

 

 Note: 
Do not confuse the primitive boolean values
`true` and `false` with the true and false values of the
 `Boolean` object!

For example:

 js 

```
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
```

 
 

#### Example

In the following example, the function `checkData` returns `true`
if the number of characters in a `Text` object is three. Otherwise, it
displays an alert and returns `false`.

 js 

```
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  }
  alert(
    `Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`,
  );
  return false;
}
```

 
 
 

### switch statement 

 
 

A `switch` statement allows a program to evaluate an expression and attempt
to match the expression's value to a `case` label. If a match is found, the
program executes the associated statement.

A `switch` statement looks like this:

 js 

```
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
```

 

JavaScript evaluates the above switch statement as follows:

- The program first looks for a `case` clause with a label matching the
value of expression and then transfers control to that clause, executing the
associated statements.

- If no matching label is found, the program looks for the optional
`default` clause:

 If a `default` clause is found, the program transfers control to that
clause, executing the associated statements.

- If no `default` clause is found, the program resumes execution at the
statement following the end of `switch`.

- (By convention, the `default` clause is written as the last clause,
but it does not need to be so.)

 

#### break statements

The optional `break` statement associated with each `case` clause
ensures that the program breaks out of `switch` once the matched statement is
executed, and then continues execution at the statement following `switch`.
If `break` is omitted, the program continues execution inside the
`switch` statement (and will execute statements under the next `case`, and so on).

 Example 

In the following example, if `fruitType` evaluates to
`"Bananas"`, the program matches the value with `case "Bananas"`
and executes the associated statement. When `break` is encountered, the
program exits the `switch` and continues execution from the statement
following `switch`. If `break` were omitted, the statement for
`case "Cherries"` would also be executed.

 js 

```
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
```

 
 
 

## Exception handling statements 

 
 

You can throw exceptions using the `throw` statement and handle them using
the `try...catch` statements.

- `throw` statement 

- `try...catch` statement 

 
 

### Exception types 

 
 

Just about any object can be thrown in JavaScript. Nevertheless, not all thrown objects
are created equal. While it is common to throw numbers or strings as errors, it is
frequently more effective to use one of the exception types specifically created for
this purpose:

- ECMAScript exceptions 

- `DOMException` 

 
 

### throw statement 

 
 

Use the `throw` statement to throw an exception. A `throw`
statement specifies the value to be thrown:

 js 

```
throw expression;
```

 

You may throw any expression, not just expressions of a specific type. The following
code throws several exceptions of varying types:

 js 

```
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  },
};
```

 
 
 

### try...catch statement 

 
 

The `try...catch` statement marks a block of statements to try, and
specifies one or more responses should an exception be thrown. If an exception is
thrown, the `try...catch` statement catches it.

The `try...catch` statement consists of a `try` block, which
contains one or more statements, and a `catch` block, containing statements
that specify what to do if an exception is thrown in the `try` block.

In other words, you want the `try` block to succeed—but if it does not, you
want control to pass to the `catch` block. If any statement within the
`try` block (or in a function called from within the `try` block)
throws an exception, control immediately shifts to the `catch`
block. If no exception is thrown in the `try` block, the `catch`
block is skipped. The `finally` block executes after the `try` and
`catch` blocks execute but before the statements following the
`try...catch` statement.

The following example uses a `try...catch` statement. The example calls a
function that retrieves a month name from an array based on the value passed to the
function. If the value does not correspond to a month number
(`1` – `12`), an exception is thrown with the value
`'Invalid month code'` and the statements in the `catch` block set the
`monthName` variable to `'unknown'`.

 js 

```
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  // prettier-ignore
  const months = [
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
  ];
  if (!months[mo]) {
    throw new Error("Invalid month code"); // throw keyword is used here
  }
  return months[mo];
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
```

 

#### The catch block

You can use a `catch` block to handle all exceptions that may be generated
in the `try` block.

 js 

```
catch (exception) {
  statements
}
```

 

The `catch` block specifies an identifier (`exception`
in the preceding syntax) that holds the value specified by the `throw`
statement. You can use this identifier to get information about the exception that was
thrown.

JavaScript creates this identifier when the `catch` block is entered. The
identifier lasts only for the duration of the `catch` block. Once the
`catch` block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control
transfers to the `catch` block.

 js 

```
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
```

 
 

 Note: 
When logging errors to the console inside
a `catch` block, using `console.error()` rather than
`console.log()` is advised for debugging. It formats the message as an
error, and adds it to the list of error messages generated by the page.

 

#### The finally block

The `finally` block contains statements to be executed after the
`try` and `catch` blocks execute. Additionally, the
`finally` block executes before the code that follows the
`try...catch...finally` statement.

It is also important to note that the `finally` block will execute
 whether or not an exception is thrown. If an exception is thrown, however, the
statements in the `finally` block execute even if no `catch` block
handles the exception that was thrown.

You can use the `finally` block to make your script fail gracefully when an
exception occurs. For example, you may need to release a resource that your script has
tied up.

The following example opens a file and then executes statements that use the file.
(Server-side JavaScript allows you to access files.) If an exception is thrown while the
file is open, the `finally` block closes the file before the script fails.
Using `finally` here ensures that the file is never left open, even
if an error occurs.

 js 

```
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
```

 

If the `finally` block returns a value, this value becomes the return value
of the entire `try...catch...finally` production, regardless of any
`return` statements in the `try` and `catch` blocks:

 js 

```
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended
    // until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    // `f` exits here
    console.log(4); // not reachable
  }
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
```

 

Overwriting of return values by the `finally` block also applies to
exceptions thrown or re-thrown inside of the `catch` block:

 js 

```
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
    // `f` exits here
  }
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}

// Logs:
// caught inner "bogus"
// false
```

 

#### Nesting try...catch statements

You can nest one or more `try...catch` statements.

If an inner `try` block does not have a corresponding
`catch` block:

- it must contain a `finally` block, and

- the enclosing `try...catch` statement's `catch` block is
checked for a match.

For more information, see nested try-blocks 
on the `try...catch` 
reference page.

 
 

### Utilizing Error objects 

 
 

Depending on the type of error, you may be able to use the `name` and
`message` properties to get a more refined message.

The `name` property provides the general class of `Error` (such
as `DOMException` or `Error`), while `message`
generally provides a more succinct message than one would get by converting the error
object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties
(such as if your `catch` block doesn't discriminate between your own
exceptions and system ones), you can use the `Error` constructor.

For example:

 js 

```
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  }
  doSomethingToGetAJavaScriptError();
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message', or a JavaScript error message
}
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### var - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var

var - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# var

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `var` statement declares function-scoped or globally-scoped variables, optionally initializing each to a value.

 
 
 
 
 
 

## Try it 

 
 
 

```
var x = 1;

if (x === 1) {
  var x = 2;

  console.log(x);
  // Expected output: 2
}

console.log(x);
// Expected output: 2
```

 
 
 

## Syntax 

 
 js 

```
var name1;
var name1 = value1;
var name1 = value1, name2 = value2;
var name1, name2 = value2;
var name1 = value1, name2, /* …, */ nameN = valueN;
```

 
 
 `nameN` 
 

The name of the variable to declare. Each must be a legal JavaScript identifier or a destructuring binding pattern .

 
 `valueN` Optional 
 

Initial value of the variable. It can be any legal expression. Default value is `undefined`.

 
 
 
 

## Description 

 
 

The scope of a variable declared with `var` is one of the following curly-brace-enclosed syntaxes that most closely contains the `var` statement:

- Function body

- Static initialization block 

Or if none of the above applies:

- The current module , for code running in module mode

- The global scope, for code running in script mode.

 js 

```
function foo() {
  var x = 1;
  function bar() {
    var y = 2;
    console.log(x); // 1 (function `bar` closes over `x`)
    console.log(y); // 2 (`y` is in scope)
  }
  bar();
  console.log(x); // 1 (`x` is in scope)
  console.log(y); // ReferenceError, `y` is scoped to `bar`
}

foo();
```

 

Importantly, other block constructs, including block statements , `try...catch` , `switch` , headers of one of the `for` statements , do not create scopes for `var`, and variables declared with `var` inside such a block can continue to be referenced outside the block.

 js 

```
for (var a of [1, 2, 3]);
console.log(a); // 3
```

 

In a script, a variable declared using `var` is added as a non-configurable property of the global object. This means its property descriptor cannot be changed and it cannot be deleted using `delete` . JavaScript has automatic memory management, and it would make no sense to be able to use the `delete` operator on a global variable.

 js 

```
"use strict";
var x = 1;
Object.hasOwn(globalThis, "x"); // true
delete globalThis.x; // TypeError in strict mode. Fails silently otherwise.
delete x; // SyntaxError in strict mode. Fails silently otherwise.
```

 

In both NodeJS CommonJS modules and native ECMAScript modules , top-level variable declarations are scoped to the module, and are not added as properties to the global object.

The list that follows the `var` keyword is called a binding list and is separated by commas, where the commas are not comma operators and the `=` signs are not assignment operators . Initializers of later variables can refer to earlier variables in the list and get the initialized value.

 
 

### Hoisting 

 
 

`var` declarations, wherever they occur in a script, are processed before any code within the script is executed. Declaring a variable anywhere in the code is equivalent to declaring it at the top. This also means that a variable can appear to be used before it's declared. This behavior is called hoisting , as it appears that the variable declaration is moved to the top of the function, static initialization block, or script source in which it occurs.

 

 Note: 
`var` declarations are only hoisted to the top of the current script. If you have two ` ` elements within one HTML, the first script cannot access variables declared by the second before the second script has been processed and executed.

 
 js 

```
bla = 2;
var bla;
```

 

This is implicitly understood as:

 js 

```
var bla;
bla = 2;
```

 

For that reason, it is recommended to always declare variables at the top of their scope (the top of global code and the top of function code) so it's clear which variables are scoped to the current function.

Only a variable's declaration is hoisted, not its initialization. The initialization happens only when the assignment statement is reached. Until then the variable remains `undefined` (but declared):

 js 

```
function doSomething() {
  console.log(bar); // undefined
  var bar = 111;
  console.log(bar); // 111
}
```

 

This is implicitly understood as:

 js 

```
function doSomething() {
  var bar;
  console.log(bar); // undefined
  bar = 111;
  console.log(bar); // 111
}
```

 
 
 

### Redeclarations 

 
 

Duplicate variable declarations using `var` will not trigger an error, even in strict mode, and the variable will not lose its value, unless the declaration has an initializer.

 js 

```
var a = 1;
var a = 2;
console.log(a); // 2
var a;
console.log(a); // 2; not undefined
```

 

`var` declarations can also be in the same scope as a `function` declaration. In this case, the `var` declaration's initializer always overrides the function's value, regardless of their relative position. This is because function declarations are hoisted before any initializer gets evaluated, so the initializer comes later and overrides the value.

 js 

```
var a = 1;
function a() {}
console.log(a); // 1
```

 

`var` declarations cannot be in the same scope as a `let` , `const` , `class` , or `import` declaration.

 js 

```
var a = 1;
let a = 2; // SyntaxError: Identifier 'a' has already been declared
```

 

Because `var` declarations are not scoped to blocks, this also applies to the following case:

 js 

```
let a = 1;
{
  var a = 1; // SyntaxError: Identifier 'a' has already been declared
}
```

 

It does not apply to the following case, where `let` is in a child scope of `var`, not the same scope:

 js 

```
var a = 1;
{
  let a = 2;
}
```

 

A `var` declaration within a function's body can have the same name as a parameter.

 js 

```
function foo(a) {
  var a = 1;
  console.log(a);
}

foo(2); // Logs 1
```

 

A `var` declaration within a `catch` block can have the same name as the `catch`-bound identifier, but only if the `catch` binding is a simple identifier, not a destructuring pattern. This is a deprecated syntax and you should not rely on it. In this case, the declaration is hoisted to outside the `catch` block, but any value assigned within the `catch` block is not visible outside.

 js 

```
try {
  throw new Error();
} catch (e) {
  var e = 2; // Works
}
console.log(e); // undefined
```

 
 
 

## Examples 

 
 
 
 

### Declaring and initializing two variables 

 
 js 

```
var a = 0,
  b = 0;
```

 
 
 

### Assigning two variables with single string value 

 
 js 

```
var a = "A";
var b = a;
```

 

This is equivalent to:

 js 

```
var a, b = a = "A";
```

 

Be mindful of the order:

 js 

```
var x = y,
  y = "A";
console.log(x, y); // undefined A
```

 

Here, `x` and `y` are declared before any code is executed, but the assignments occur later. At the time `x = y` is evaluated, `y` exists so no `ReferenceError` is thrown and its value is `undefined`. So, `x` is assigned the undefined value. Then, `y` is assigned the value `"A"`.

 
 

### Initialization of several variables 

 
 

Be careful of the `var x = y = 1` syntax — `y` is not actually declared as a variable, so `y = 1` is an unqualified identifier assignment , which creates a global variable in non-strict mode.

 js 

```
var x = 0;
function f() {
  var x = y = 1; // Declares x locally; declares y globally.
}
f();

console.log(x, y); // 0 1

// In non-strict mode:
// x is the global one as expected;
// y is leaked outside of the function, though!
```

 

The same example as above but with a strict mode:

 js 

```
"use strict";

var x = 0;
function f() {
  var x = y = 1; // ReferenceError: y is not defined
}
f();

console.log(x, y);
```

 
 
 

### Implicit globals and outer function scope 

 
 

Variables that appear to be implicit globals may be references to variables in an outer function scope:

 js 

```
var x = 0; // Declares x within file scope, then assigns it a value of 0.

console.log(typeof z); // "undefined", since z doesn't exist yet

function a() {
  var y = 2; // Declares y within scope of function a, then assigns it a value of 2.

  console.log(x, y); // 0 2

  function b() {
    x = 3; // Assigns 3 to existing file scoped x.
    y = 4; // Assigns 4 to existing outer y.
    z = 5; // Creates a new global variable z, and assigns it a value of 5.
    // (Throws a ReferenceError in strict mode.)
  }

  b(); // Creates z as a global variable.
  console.log(x, y, z); // 3 4 5
}

a(); // Also calls b.
console.log(x, z); // 3 5
console.log(typeof y); // "undefined", as y is local to function a
```

 
 
 

### Declaration with destructuring 

 
 

The left-hand side of each `=` can also be a binding pattern. This allows creating multiple variables at once.

 js 

```
const result = /(a+)(b+)(c+)/.exec("aaabcc");
var [, a, b, c] = result;
console.log(a, b, c); // "aaa" "b" "cc"
```

 

For more information, see Destructuring .

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-variable-statement 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `let` 

- `const` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### let - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let

let - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# let

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨September 2016⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `let` declaration declares re-assignable, block-scoped local variables, optionally initializing each to a value.

 
 
 
 
 
 

## Try it 

 
 
 

```
let x = 1;

if (x === 1) {
  let x = 2;

  console.log(x);
  // Expected output: 2
}

console.log(x);
// Expected output: 1
```

 
 
 

## Syntax 

 
 js 

```
let name1;
let name1 = value1;
let name1 = value1, name2 = value2;
let name1, name2 = value2;
let name1 = value1, name2, /* …, */ nameN = valueN;
```

 
 
 

### Parameters 

 
 
 `nameN` 
 

The name of the variable to declare. Each must be a legal JavaScript identifier or a destructuring binding pattern .

 
 `valueN` Optional 
 

Initial value of the variable. It can be any legal expression. Default value is `undefined`.

 
 
 
 

## Description 

 
 

The scope of a variable declared with `let` is one of the following curly-brace-enclosed syntaxes that most closely contains the `let` declaration:

- Block statement

- `switch` statement

- `try...catch` statement

- Body of one of the `for` statements , if the `let` is in the header of the statement

- Function body

- Static initialization block 

Or if none of the above applies:

- The current module , for code running in module mode

- The global scope, for code running in script mode.

Compared with `var` , `let` declarations have the following differences:

- 

`let` declarations are scoped to blocks as well as functions.

- 

`let` declarations can only be accessed after the place of declaration is reached (see temporal dead zone ). For this reason, `let` declarations are commonly regarded as non-hoisted .

- 

`let` declarations do not create properties on `globalThis` when declared at the top level of a script.

- 

`let` declarations cannot be redeclared by any other declaration in the same scope.

- 

`let` begins declarations , not statements . That means you cannot use a lone `let` declaration as the body of a block (which makes sense, since there's no way to access the variable).

 js 

```
if (true) let a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context
```

 

Note that `let` is allowed as an identifier name when declared with `var` or `function` in non-strict mode , but you should avoid using `let` as an identifier name to prevent unexpected syntax ambiguities.

Many style guides (including MDN's ) recommend using `const` over `let` whenever a variable is not reassigned in its scope. This makes the intent clear that a variable's type (or value, in the case of a primitive) can never change. Others may prefer `let` for non-primitives that are mutated.

The list that follows the `let` keyword is called a binding list and is separated by commas, where the commas are not comma operators and the `=` signs are not assignment operators . Initializers of later variables can refer to earlier variables in the list.

 
 

### Temporal dead zone (TDZ) 

 
 

A variable declared with `let`, `const`, or `class` is said to be in a "temporal dead zone" (TDZ) from the start of the block until code execution reaches the place where the variable is declared and initialized.

While inside the TDZ, the variable has not been initialized with a value, and any attempt to access it will result in a `ReferenceError` . The variable is initialized with a value when execution reaches the place in the code where it was declared. If no initial value was specified with the variable declaration, it will be initialized with a value of `undefined`.

This differs from `var` variables, which will return a value of `undefined` if they are accessed before they are declared. The code below demonstrates the different result when `let` and `var` are accessed in code before the place where they are declared.

 js 

```
{
  // TDZ starts at beginning of scope
  console.log(bar); // "undefined"
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  var bar = 1;
  let foo = 2; // End of TDZ (for foo)
}
```

 

The term "temporal" is used because the zone depends on the order of execution (time) rather than the order in which the code is written (position). For example, the code below works because, even though the function that uses the `let` variable appears before the variable is declared, the function is called outside the TDZ.

 js 

```
{
  // TDZ starts at beginning of scope
  const func = () => console.log(letVar); // OK

  // Within the TDZ letVar access throws `ReferenceError`

  let letVar = 3; // End of TDZ (for letVar)
  func(); // Called outside TDZ!
}
```

 

Using the `typeof` operator for a variable in its TDZ will throw a `ReferenceError` :

 js 

```
{
  typeof i; // ReferenceError: Cannot access 'i' before initialization
  let i = 10;
}
```

 

This differs from using `typeof` for undeclared variables, and variables that hold a value of `undefined`:

 js 

```
console.log(typeof undeclaredVariable); // "undefined"
```

 
 

 Note: 
`let` and `const` declarations are only processed when the current script gets processed. If you have two ` ` elements running in script mode within one HTML, the first script is not subject to the TDZ restrictions for top-level `let` or `const` variables declared in the second script, although if you declare a `let` or `const` variable in the first script, declaring it again in the second script will cause a redeclaration error .

 
 
 

### Redeclarations 

 
 

`let` declarations cannot be in the same scope as any other declaration, including `let`, `const` , `class` , `function` , `var` , and `import` declaration.

 js 

```
{
  let foo;
  let foo; // SyntaxError: Identifier 'foo' has already been declared
}
```

 

A `let` declaration within a function's body cannot have the same name as a parameter. A `let` declaration within a `catch` block cannot have the same name as the `catch`-bound identifier.

 js 

```
function foo(a) {
  let a = 1; // SyntaxError: Identifier 'a' has already been declared
}
try {
} catch (e) {
  let e; // SyntaxError: Identifier 'e' has already been declared
}
```

 

If you're experimenting in a REPL, such as the Firefox web console ( Tools > Web Developer > Web Console ), and you run two `let` declarations with the same name in two separate inputs, you may get the same re-declaration error. See further discussion of this issue in Firefox bug 1580891 . The Chrome console allows `let` re-declarations between different REPL inputs.

You may encounter errors in `switch` statements because there is only one block.

 js 

```
let x = 1;

switch (x) {
  case 0:
    let foo;
    break;
  case 1:
    let foo; // SyntaxError: Identifier 'foo' has already been declared
    break;
}
```

 

To avoid the error, wrap each `case` in a new block statement.

 js 

```
let x = 1;

switch (x) {
  case 0: {
    let foo;
    break;
  }
  case 1: {
    let foo;
    break;
  }
}
```

 
 
 

## Examples 

 
 
 
 

### Scoping rules 

 
 

Variables declared by `let` have their scope in the block for which they are declared, as well as in any contained sub-blocks. In this way, `let` works very much like `var`. The main difference is that the scope of a `var` variable is the entire enclosing function:

 js 

```
function varTest() {
  var x = 1;
  {
    var x = 2; // same variable!
    console.log(x); // 2
  }
  console.log(x); // 2
}

function letTest() {
  let x = 1;
  {
    let x = 2; // different variable
    console.log(x); // 2
  }
  console.log(x); // 1
}
```

 

At the top level of programs and functions, `let`, unlike `var`, does not create a property on the global object. For example:

 js 

```
var x = "global";
let y = "global";
console.log(this.x); // "global"
console.log(this.y); // undefined
```

 
 
 

### TDZ combined with lexical scoping 

 
 

The following code results in a `ReferenceError` at the line shown:

 js 

```
function test() {
  var foo = 33;
  if (foo) {
    let foo = foo + 55; // ReferenceError
  }
}
test();
```

 

The `if` block is evaluated because the outer `var foo` has a value. However due to lexical scoping this value is not available inside the block: the identifier `foo` inside the `if` block is the `let foo`. The expression `foo + 55` throws a `ReferenceError` because initialization of `let foo` has not completed — it is still in the temporal dead zone.

This phenomenon can be confusing in a situation like the following. The instruction `let n of n.a` is already inside the scope of the `for...of` loop's block. So, the identifier `n.a` is resolved to the property `a` of the `n` object located in the first part of the instruction itself (`let n`). This is still in the temporal dead zone as its declaration statement has not been reached and terminated.

 js 

```
function go(n) {
  // n here is defined!
  console.log(n); // { a: [1, 2, 3] }

  for (let n of n.a) {
    //          ^ ReferenceError
    console.log(n);
  }
}

go({ a: [1, 2, 3] });
```

 
 
 

### Other situations 

 
 

When used inside a block, `let` limits the variable's scope to that block. Note the difference between `var`, whose scope is inside the function where it is declared.

 js 

```
var a = 1;
var b = 2;

{
  var a = 11; // the scope is global
  let b = 22; // the scope is inside the block

  console.log(a); // 11
  console.log(b); // 22
}

console.log(a); // 11
console.log(b); // 2
```

 

However, this combination of `var` and `let` declarations below is a `SyntaxError` because `var` not being block-scoped, leading to them being in the same scope. This results in an implicit re-declaration of the variable.

 js 

```
let x = 1;

{
  var x = 2; // SyntaxError for re-declaration
}
```

 
 
 

### Declaration with destructuring 

 
 

The left-hand side of each `=` can also be a binding pattern. This allows creating multiple variables at once.

 js 

```
const result = /(a+)(b+)(c+)/.exec("aaabcc");
let [, a, b, c] = result;
console.log(a, b, c); // "aaa" "b" "cc"
```

 

For more information, see Destructuring .

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-let-and-const-declarations 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `var` 

- `const` 

- Hoisting 

- ES6 In Depth: `let` and `const` on hacks.mozilla.org (2015)

- Breaking changes in `let` and `const` in Firefox 44 on blog.mozilla.org (2015)

- You Don't Know JS: Scope & Closures, Ch.3: Function vs. Block Scope by Kyle Simpson

- What is the Temporal Dead Zone? on Stack Overflow

- What is the difference between using `let` and `var`? on Stack Overflow

- Why was the name 'let' chosen for block-scoped variable declarations in JavaScript? on Stack Overflow

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#content

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#search

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Introduction - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Introduction

Introduction - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Introduction

 
 
 
- Previous 
- Next 

This chapter introduces JavaScript and discusses some of its fundamental concepts.

 
 
 
 
 
 

## What you should already know 

 
 

This guide assumes you have the following basic background:

- A general understanding of the Internet and the World Wide Web ( WWW ).

- Good working knowledge of HyperText Markup Language ( HTML ).

- Some programming experience. If you are new to programming, try one of the tutorials linked on the main page about JavaScript .

 
 

## Where to find JavaScript information 

 
 

The JavaScript documentation on MDN includes the following:

- Dynamic scripting with JavaScript provides structured JavaScript guides for beginners and introduces basic concepts of programming and the Internet.

- JavaScript Guide (this guide) provides an overview about the JavaScript language and its objects.

- JavaScript Reference provides detailed reference material for JavaScript.

 
 

## What is JavaScript? 

 
 

JavaScript is a cross-platform, object-oriented scripting language used to make webpages interactive (e.g., having complex animations, clickable buttons, popup menus, etc.). There are also more advanced server side versions of JavaScript such as Node.js, which allow you to add more functionality to a website than downloading files (such as realtime collaboration between multiple computers). Inside a host environment (for example, a web browser), JavaScript can be connected to the objects of its environment to provide programmatic control over them.

JavaScript contains a standard library of objects, such as `Array`, `Map`, and `Math`, and a core set of language elements such as operators, control structures, and statements. Core JavaScript can be extended for a variety of purposes by supplementing it with additional objects; for example:

- Client-side JavaScript extends the core language by supplying objects to control a browser and its Document Object Model (DOM). For example, client-side extensions allow an application to place elements on an HTML form and respond to user events such as mouse clicks, form input, and page navigation.

- Server-side JavaScript extends the core language by supplying objects relevant to running JavaScript on a server. For example, server-side extensions allow an application to communicate with a database, provide continuity of information from one invocation to another of the application, or perform file manipulations on a server.

This means that in the browser, JavaScript can change the way the webpage (DOM) looks. And, likewise, Node.js JavaScript on the server can respond to custom requests sent by code executed in the browser.

 
 

## JavaScript and Java 

 
 

JavaScript and Java are similar in some ways but fundamentally different in some others. The JavaScript language resembles Java but does not have Java's static typing and strong type checking. JavaScript follows most Java expression syntax, naming conventions and basic control-flow constructs which was the reason why it was renamed from LiveScript to JavaScript.

In contrast to Java's compile-time system of classes built by declarations, JavaScript supports a runtime system based on a small number of data types representing numeric, Boolean, and string values. JavaScript has a prototype-based object model instead of the more common class-based object model. The prototype-based model provides dynamic inheritance; that is, what is inherited can vary for individual objects. JavaScript also supports functions without any special declarative requirements. Functions can be properties of objects, executing as loosely typed methods.

JavaScript is a very free-form language compared to Java. You do not have to declare all variables, classes, and methods. You do not have to be concerned with whether methods are public, private, or protected, and you do not have to implement interfaces. Variables, parameters, and function return types are not explicitly typed.

Java is a class-based programming language designed for fast execution and type safety. Type safety means, for instance, that you can't cast a Java integer into an object reference or access private memory by corrupting the Java bytecode. Java's class-based model means that programs consist exclusively of classes and their methods. Java's class inheritance and strong typing generally require tightly coupled object hierarchies. These requirements make Java programming more complex than JavaScript programming.

In contrast, JavaScript descends in spirit from a line of smaller, dynamically typed languages such as HyperTalk and dBase. These scripting languages offer programming tools to a much wider audience because of their easier syntax, specialized built-in functionality, and minimal requirements for object creation.

 
 
 
 JavaScript 
 Java 
 
 
 
 
 Object-oriented. No distinction between types of objects. Inheritance is through the prototype mechanism, and properties and methods can be added to any object dynamically. 
 Class-based. Objects are divided into classes and instances with all inheritance through the class hierarchy. Classes and instances cannot have properties or methods added dynamically. 
 
 
 Variable data types are not declared (dynamic typing, loosely typed). 
 Variable data types must be declared (static typing, strongly typed). 
 
 
 Cannot automatically write to hard disk. 
 Can automatically write to hard disk. 
 
 
 
 
 

## JavaScript and the ECMAScript specification 

 
 

JavaScript is standardized at Ecma International — the European association for standardizing information and communication systems (ECMA was formerly an acronym for the European Computer Manufacturers Association) to deliver a standardized, international programming language based on JavaScript. This standardized version of JavaScript, called ECMAScript, behaves the same way in all applications that support the standard. Companies can use the open standard language to develop their implementation of JavaScript. The ECMAScript standard is documented in the ECMA-262 specification.

The ECMA-262 standard is also approved by the ISO (International Organization for Standardization) as ISO-16262. You can also find the specification on the Ecma International website . The ECMAScript specification does not describe the Document Object Model (DOM), which is standardized by the World Wide Web Consortium (W3C) and/or WHATWG (Web Hypertext Application Technology Working Group) . The DOM defines the way in which HTML document objects are exposed to your script. To get a better idea about the different technologies that are used when programming with JavaScript, consult the article JavaScript technologies overview .

 
 

### JavaScript documentation versus the ECMAScript specification 

 
 

The ECMAScript specification is a set of requirements for implementing ECMAScript. It is useful if you want to implement standards-compliant language features in your ECMAScript implementation or engine (such as SpiderMonkey in Firefox, or V8 in Chrome).

The ECMAScript document is not intended to help script programmers. Use the JavaScript documentation for information when writing scripts.

The ECMAScript specification uses terminology and syntax that may be unfamiliar to a JavaScript programmer. Although the description of the language may differ in ECMAScript, the language itself remains the same. JavaScript supports all functionality outlined in the ECMAScript specification.

The JavaScript documentation describes aspects of the language that are appropriate for a JavaScript programmer.

 
 

## Getting started with JavaScript 

 
 

To get started with JavaScript, all you need is a modern web browser. Recent versions of Firefox , Chrome , Microsoft Edge , and Safari all support the features discussed in this guide.

A very useful tool for exploring JavaScript is the JavaScript Console (sometimes called the Web Console, or just the console): this is a tool which enables you to enter JavaScript and run it in the current page.

The screenshots here show the Firefox Web Console , but all modern browsers ship with a console that works in a similar way.

 
 

### Opening the console 

 
 

The exact instructions for opening the console vary from one browser to another:

- Opening the console in Firefox 

- Opening the console in Chrome 

- Opening the console in Microsoft Edge 

 
 

### Entering and running JavaScript 

 
 

The console appears at the bottom of the browser window. Along the bottom of the console is an input line that you can use to enter JavaScript, and the output appears in the panel above:

 

The console works the exact same way as `eval`: the last expression entered is returned. For the sake of simplicity, it can be imagined that every time something is entered into the console, it is actually surrounded by `console.log` around `eval`, like so:

 js 

```
console.log(eval("3 + 5"));
```

 
 
 

### Multi-line input in the console 

 
 

By default, if you press Enter (or Return , depending on your keyboard) after entering a line of code, then the string you typed is executed. To enter multi-line input:

- If the string you typed was incomplete (for example, you typed `function foo() {`) then the console will treat Enter as a line break, and let you type another line.

- If you hold down Shift while pressing Enter , then the console will treat this as a line break, and let you type another line.

- In Firefox only, you can activate multi-line input mode , in which you can enter multiple lines in a mini-editor, then run the whole thing when you are ready.

To get started with writing JavaScript, open the console, copy the following code, and paste it in at the prompt:

 js 

```
(function () {
  "use strict";
  /* Start of your code */
  function greetMe(yourName) {
    alert(`Hello ${yourName}`);
  }

  greetMe("World");
  /* End of your code */
})();
```

 

Press Enter to watch it unfold in your browser!

 
 

## What's next 

 
 

In the following pages, this guide introduces you to the JavaScript syntax and language features, so that you will be able to write more complex applications.

But for now, remember to always include the `(function(){"use strict";` before your code, and add `})();` to the end of your code. The strict mode and IIFE articles explain what those do, but for now they can be thought of as doing the following:

- Prevent semantics in JavaScript that trip up beginners.

- Prevent code snippets executed in the console from interacting with one another (e.g., having something created in one console execution being used for a different console execution).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#basics

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#comments

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#declarations

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#data_structures_and_types

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#literals

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#content

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 
- Previous 
- Next 

This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.

At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate .

The expression `x = 7` is an example of the first type. This expression uses the `=` operator to assign the value seven to the variable `x`. The expression itself evaluates to `7`.

The expression `3 + 4` is an example of the second type. This expression uses the `+` operator to add `3` and `4` together and produces a value, `7`. However, if it's not eventually part of a bigger construct (for example, a variable declaration like `const z = 3 + 4`), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.

As the examples above also illustrate, all complex expressions are joined by operators , such as `=` and `+`. In this section, we will introduce the following operators:

- Assignment operators 

- Comparison operators 

- Arithmetic operators 

- Bitwise operators 

- Logical operators 

- BigInt operators 

- String operators 

- Conditional (ternary) operator 

- Comma operator 

- Unary operators 

- Relational operators 

These operators join operands either formed by higher-precedence operators or one of the basic expressions . A complete and detailed list of operators and expressions is also available in the reference .

The precedence of operators determines the order they are applied when evaluating an expression. For example:

 js 

```
const x = 1 + 2 * 3;
const y = 2 * 3 + 1;
```

 

Despite `*` and `+` coming in different orders, both expressions would result in `7` because `*` has precedence over `+`, so the `*`-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.

JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:



```
operand1 operator operand2
```



For example, `3 + 4` or `x * y`. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.

A unary operator requires a single operand, either before or after the operator:



```
operator operand
operand operator
```



For example, `x++` or `++x`. The `operator operand` form is called a prefix unary operator, and the `operand operator` form is called a postfix unary operator. `++` and `--` are the only postfix operators in JavaScript — all other operators, like `!`, `typeof`, etc. are prefix.

 
 
 
 
 
 

## Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (`=`), which assigns the value of its right operand to its left operand.
That is, `x = f()` is an assignment expression that assigns the value of `f()` to `x`.

There are also compound assignment operators that are shorthand for the operations listed in the following table:

 
 
 
 Name 
 Shorthand operator 
 Meaning 
 
 
 
 
 Assignment 
 `x = f()` 
 `x = f()` 
 
 
 Addition assignment 
 `x += f()` 
 `x = x + f()` 
 
 
 Subtraction assignment 
 `x -= f()` 
 `x = x - f()` 
 
 
 Multiplication assignment 
 `x *= f()` 
 `x = x * f()` 
 
 
 Division assignment 
 `x /= f()` 
 `x = x / f()` 
 
 
 Remainder assignment 
 `x %= f()` 
 `x = x % f()` 
 
 
 Exponentiation assignment 
 `x **= f()` 
 `x = x ** f()` 
 
 
 Left shift assignment 
 `x 
 `x = x 
 
 
 Right shift assignment 
 `x >>= f()` 
 `x = x >> f()` 
 
 
 Unsigned right shift assignment 
 `x >>>= f()` 
 `x = x >>> f()` 
 
 
 Bitwise AND assignment 
 `x &= f()` 
 `x = x & f()` 
 
 
 Bitwise XOR assignment 
 `x ^= f()` 
 `x = x ^ f()` 
 
 
 Bitwise OR assignment 
 `x |= f()` 
 `x = x | f()` 
 
 
 Logical AND assignment 
 `x &&= f()` 
 `x && (x = f())` 
 
 
 Logical OR assignment 
 `x ||= f()` 
 `x || (x = f())` 
 
 
 Nullish coalescing assignment 
 `x ??= f()` 
 `x ?? (x = f())` 
 
 
 
 
 

### Assigning to properties 

 
 

If an expression evaluates to an object , then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:

 js 

```
const obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.
```

 

For more information about objects, read Working with Objects .

If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:

 js 

```
const val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.
```

 

In strict mode , the code above throws, because one cannot assign properties to primitives.

It is an error to assign values to unmodifiable properties or to properties of an expression without properties (`null` or `undefined`).

 
 

### Destructuring 

 
 

For more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.

Without destructuring, it takes multiple statements to extract values from arrays and objects:

 js 

```
const foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];
```

 

With destructuring, you can extract multiple values into distinct variables using a single statement:

 js 

```
const [one, two, three] = foo;
```

 
 
 

### Evaluation and nesting 

 
 

In general, assignments are used within a variable declaration (i.e., with `const` , `let` , or `var` ) or as standalone statements.

 js 

```
// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().
```

 

However, like other expressions, assignment expressions like `x = f()` evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.

Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments .
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.

By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.

 js 

```
let x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

 

The evaluation result matches the expression to the right of the `=` sign in the
"Meaning" column of the table above. That means that `x = f()` evaluates into
whatever `f()`'s result is, `x += f()` evaluates into the resulting sum `x + f()`,
`x **= f()` evaluates into the resulting power `x ** f()`, and so on.

In the case of logical assignments, `x &&= f()`,
`x ||= f()`, and `x ??= f()`, the return value is that of the
logical operation without the assignment, so `x && f()`,
`x || f()`, and `x ?? f()`, respectively.

When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left 
(they are right-associative ), but they are evaluated left to right .

Note that, for all assignment operators other than `=` itself,
the resulting values are always based on the operands' values before 
the operation.

For example, assume that the following functions `f` and `g`
and the variables `x` and `y` have been declared:

 js 

```
function f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;
```

 

Consider these three examples:

 js 

```
y = x = f();
y = [f(), x = g()];
x[f()] = g();
```

 

#### Evaluation example 1

`y = x = f()` is equivalent to `y = (x = f())`,
because the assignment operator `=` is right-associative .
However, it evaluates from left to right:

- The assignment expression `y = x = f()` starts to evaluate.

 The `y` on this assignment's left-hand side evaluates
into a reference to the variable named `y`.

- The assignment expression `x = f()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- That `2` result from `f()` is assigned to `x`.

 
- The assignment expression `x = f()` has now finished evaluating;
its result is the new value of `x`, which is `2`.

- That `2` result in turn is also assigned to `y`.

 
- The assignment expression `y = x = f()` has now finished evaluating;
its result is the new value of `y` – which happens to be `2`.
`x` and `y` are assigned to `2`,
and the console has printed "F!".

#### Evaluation example 2

`y = [ f(), x = g() ]` also evaluates from left to right:

- The assignment expression `y = [ f(), x = g() ]` starts to evaluate.

 The `y` on this assignment's left-hand evaluates
into a reference to the variable named `y`.

- The inner array literal `[ f(), x = g() ]` starts to evaluate.

 The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- The assignment expression `x = g()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` result from `g()` is assigned to `x`.

 
- The assignment expression `x = g()` has now finished evaluating;
its result is the new value of `x`, which is `3`.
That `3` result becomes the next element
in the inner array literal (after the `2` from the `f()`).

 
- The inner array literal `[ f(), x = g() ]`
has now finished evaluating;
its result is an array with two values: `[ 2, 3 ]`.

- That `[ 2, 3 ]` array is now assigned to `y`.

 
- The assignment expression `y = [ f(), x = g() ]` has
now finished evaluating;
its result is the new value of `y` – which happens to be `[ 2, 3 ]`.
`x` is now assigned to `3`,
`y` is now assigned to `[ 2, 3 ]`,
and the console has printed "F!" then "G!".

#### Evaluation example 3

`x[f()] = g()` also evaluates from left to right.
(This example assumes that `x` is already assigned to some object.
For more information about objects, read Working with Objects .)

- The assignment expression `x[f()] = g()` starts to evaluate.

 The `x[f()]` property access on this assignment's left-hand
starts to evaluate.

 The `x` in this property access evaluates
into a reference to the variable named `x`.

- Then the function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

 
- The `x[f()]` property access on this assignment
has now finished evaluating;
its result is a variable property reference: `x[2]`.

- Then the function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` is now assigned to `x[2]`.
(This step will succeed only if `x` is assigned to an object .)

 
- The assignment expression `x[f()] = g()` has now finished evaluating;
its result is the new value of `x[2]` – which happens to be `3`.
`x[2]` is now assigned to `3`,
and the console has printed "F!" then "G!".

 
 

### Avoid assignment chains 

 
 

Chaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
 chaining assignments in the same statement is discouraged .

In particular, putting a variable chain in a `const` , `let` , or `var` statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the `const`/`let`/`var` statement.
For example:

 js 

```
const z = y = x = f();
```

 

This statement seemingly declares the variables `x`, `y`, and `z`.
However, it only actually declares the variable `z`.
`y` and `x` are either invalid references to nonexistent variables (in strict mode ) or, worse, would implicitly create global variables for `x` and `y` in sloppy mode .

 
 

## Comparison operators 

 
 

A comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the `===` and `!==` operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:

 js 

```
const var1 = 3;
const var2 = 4;
```

 
 
 
 Comparison operators
 
 
 
 Operator 
 Description 
 Examples returning true 
 
 
 
 
 
 Equal (`==`)
 
 Returns `true` if the operands are equal. 
 
 `3 == var1`
 

`"3" == var1`

 `3 == '3'`
 
 
 
 
 Not equal (`!=`)
 
 Returns `true` if the operands are not equal. 
 
 `var1 != 4var2 != "3"`
 
 
 
 
 Strict equal (`===`)
 
 
 Returns `true` if the operands are equal and of the same
 type. See also `Object.is` and
 sameness in JS .
 
 `3 === var1` 
 
 
 
 Strict not equal (`!==`)
 
 
 Returns `true` if the operands are of the same type but not equal, or are of different type.
 
 
 `var1 !== "3"3 !== '3'`
 
 
 
 
 Greater than (`>`)
 
 
 Returns `true` if the left operand is greater than the right operand.
 
 
 `var2 > var1"12" > 2`
 
 
 
 
 Greater than or equal 
 (`>=`)
 
 
 Returns `true` if the left operand is greater than or equal to the right operand.
 
 
 `var2 >= var1var1 >= 3`
 
 
 
 
 Less than 
 (` 
 
 Returns `true` if the left operand is less than the right operand.
 
 
 `var1 
 
 
 
 Less than or equal 
 (` 
 
 Returns `true` if the left operand is less than or equal to the right operand.
 
 
 `var1 
 
 
 
 

 Note: 
`=>` is not a comparison operator but rather is the notation
for Arrow functions .

 
 
 

## Arithmetic operators 

 
 

An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces `Infinity` ). For example:

 js 

```
1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true
```

 

In addition to the standard arithmetic operations (`+`, `-`, `*`, `/`), JavaScript provides the arithmetic operators listed in the following table:

 
 
 Arithmetic operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Remainder (`%`)
 
 
 Binary operator. Returns the integer remainder of dividing the two operands.
 
 12 % 5 returns 2. 
 
 
 
 Increment (`++`)
 
 
 Unary operator. Adds one to its operand. If used as a prefix operator
 (`++x`), returns the value of its operand after adding one;
 if used as a postfix operator (`x++`), returns the value of
 its operand before adding one.
 
 
 If `x` is 3, then `++x` sets `x` to 4
 and returns 4, whereas `x++` returns 3 and, only then, sets `x` to 4.
 
 
 
 
 Decrement (`--`)
 
 
 Unary operator. Subtracts one from its operand.
 The return value is analogous to that for the increment operator.
 
 
 If `x` is 3, then `--x` sets `x` to 2
 and returns 2, whereas `x--` returns 3 and, only then, sets `x` to 2.
 
 
 
 
 Unary negation (`-`)
 
 Unary operator. Returns the negation of its operand. 
 If `x` is 3, then `-x` returns -3. 
 
 
 
 Unary plus (`+`)
 
 
 Unary operator. Attempts to convert the operand to a number , if it is not already.
 
 
 

`+"3"` returns `3`.

 

`+true` returns `1`.

 
 
 
 
 Exponentiation operator (`**`)
 
 
 Calculates the `base` to the `exponent` power,
 that is, `base^exponent`
 
 
 `2 ** 3` returns `8`.
`10 ** -1`
 returns `0.1`.
 
 
 
 
 
 

## Bitwise operators 

 
 

A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.

The following table summarizes JavaScript's bitwise operators.

 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 Bitwise AND 
 `a & b` 
 Returns a one in each bit position for which the corresponding bits of both operands are ones. 
 
 
 Bitwise OR 
 `a | b` 
 Returns a zero in each bit position for which the corresponding bits of both operands are zeros. 
 
 
 Bitwise XOR 
 `a ^ b` 
 Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.] 
 
 
 Bitwise NOT 
 `~ a` 
 Inverts the bits of its operand. 
 
 
 Left shift 
 `a 
 Shifts `a` in binary representation `b` bits to the left, shifting in zeros from the right. 
 
 
 Sign-propagating right shift 
 `a >> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off. 
 
 
 Zero-fill right shift 
 `a >>> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off, and shifting in zeros from the left. 
 
 
 
 
 

### Bitwise logical operators 

 
 

Conceptually, the bitwise logical operators work as follows:

- 

The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:



```
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001
```



- 

Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.

- 

The operator is applied to each pair of bits, and the result is constructed bitwise.

For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:

 
 
 
 Expression 
 Result 
 Binary Description 
 
 
 
 
 `15 & 9` 
 `9` 
 `1111 & 1001 = 1001` 
 
 
 `15 | 9` 
 `15` 
 `1111 | 1001 = 1111` 
 
 
 `15 ^ 9` 
 `6` 
 `1111 ^ 1001 = 0110` 
 
 
 `~15` 
 `-16` 
 `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` 
 
 
 `~9` 
 `-10` 
 `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` 
 
 
 

Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). `~x` evaluates to the same value that
`-x - 1` evaluates to.

 
 

### Bitwise shift operators 

 
 

The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.

Shift operators convert their operands to thirty-two-bit integers and return a result of either type `Number` or `BigInt` : specifically, if the type
of the left operand is `BigInt` , they return `BigInt` ;
otherwise, they return `Number` .

The shift operators are listed in the following table.

 
 
 Bitwise shift operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Left shift 
(` 
 
 This operator shifts the first operand the specified number of bits to
 the left. Excess bits shifted off to the left are discarded. Zero bits
 are shifted in from the right.
 
 
 `9 
 
 
 
 Sign-propagating right shift (`>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Copies of
 the leftmost bit are shifted in from the left.
 
 
 `9>>2` yields 2, because 1001 shifted 2 bits to the right
 becomes 10, which is 2. Likewise, `-9>>2` yields -3, because the sign is preserved.
 
 
 
 
 Zero-fill right shift (`>>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Zero bits
 are shifted in from the left.
 
 
 `19>>>2` yields 4, because 10011 shifted 2 bits to the right
 becomes 100, which is 4. For non-negative numbers, zero-fill right shift
 and sign-propagating right shift yield the same result.
 
 
 
 
 
 

## Logical operators 

 
 

Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the `&&`, `||`, and `??` operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

 
 
 Logical operators
 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 
 Logical AND (`&&`)
 
 `expr1 && expr2` 
 
 Returns `expr1` if it can be converted to `false`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `&&` returns `true` if both
 operands are true; otherwise, returns `false`.
 
 
 
 
 Logical OR (`||`)
 
 `expr1 || expr2` 
 
 Returns `expr1` if it can be converted to `true`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `||` returns `true` if either operand is
 true; if both are false, returns `false`.
 
 
 
 
 Nullish coalescing operator (`??`)
 
 `expr1 ?? expr2` 
 
 Returns `expr1` if it is neither `null` nor
 `undefined`; otherwise, returns `expr2`.
 
 
 
 
 Logical NOT (`!`)
 
 `!expr` 
 
 Returns `false` if its single operand can be converted
 to `true`; otherwise, returns `true`.
 
 
 
 

Examples of expressions that can be converted to `false` are those that evaluate to `null`, `0`, `0n`, `NaN`, the empty string (`""`), or `undefined`.

The following code shows examples of the `&&` (logical AND) operator.

 js 

```
const a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false
```

 

The following code shows examples of the `||` (logical OR) operator.

 js 

```
const o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat
```

 

The following code shows examples of the `??` (nullish coalescing) operator.

 js 

```
const n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0
```

 

Note how `??` works like `||`, but it only returns the second expression when the first one is " nullish ", i.e., `null` or `undefined` . `??` is a better alternative than `||` for setting defaults for values that might be `null` or `undefined`, in particular when values like `''` or `0` are valid values and the default should not apply.

The following code shows examples of the `!` (logical NOT) operator.

 js 

```
const n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
```

 
 
 

### Short-circuit evaluation 

 
 

As logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

- `falsy && anything` is short-circuit evaluated to the falsy value.

- `truthy || anything` is short-circuit evaluated to the truthy value.

- `nonNullish ?? anything` is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
 anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.

 
 

## BigInt operators 

 
 

Most operators that can be used between numbers can be used between `BigInt` values as well.

 js 

```
// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n
```

 

One exception is unsigned right shift (`>>>`) , which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".

 js 

```
const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

 

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.

 js 

```
const a = 1n + 2; // TypeError: Cannot mix BigInt and other types
```

 

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.

 js 

```
const a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n
```

 

You can compare BigInts with numbers.

 js 

```
const a = 1n > 2; // false
const b = 3 > 2n; // true
```

 
 
 

## String operators 

 
 

In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.

For example,

 js 

```
console.log("my " + "string"); // console logs the string "my string".
```

 

The shorthand assignment operator `+=` can also be used to concatenate strings.

For example,

 js 

```
let myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
```

 
 
 

## Conditional (ternary) operator 

 
 

The conditional operator 
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:

 js 

```
condition ? val1 : val2
```

 

If `condition` is true, the operator has the value of `val1`.
Otherwise it has the value of `val2`. You can use the conditional operator anywhere you would use a standard operator.

For example,

 js 

```
const status = age >= 18 ? "adult" : "minor";
```

 

This statement assigns the value "adult" to the variable `status` if
`age` is eighteen or more. Otherwise, it assigns the value "minor" to
`status`.

 
 

## Comma operator 

 
 

The comma operator (`,`)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a `for` loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.

For example, if `a` is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:

 js 

```
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

 
 
 

## Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 

### delete 

 
 

The `delete` operator deletes an object's property.
The syntax is:

 js 

```
delete object.property;
delete object[propertyKey];
delete objectName[index];
```

 

where `object` is the name of an object, `property` is an existing property, and `propertyKey` is a string or symbol referring to an existing property.

If the `delete` operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield `undefined`.
The `delete` operator returns `true` if the operation is possible; it returns `false` if the operation is not possible.

 js 

```
delete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)
```

 

#### Deleting array elements

Since arrays are just objects, it's technically possible to `delete` elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value `undefined`.
To actually manipulate the array, use the various array methods such as `splice` .

 
 

### typeof 

 
 

The `typeof` operator returns a string indicating the type of the unevaluated operand.
`operand` is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.

Suppose you define the following variables:

 js 

```
const myFun = () => 5 + 2;
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();
```

 

The `typeof` operator returns the following results for these variables:

 js 

```
typeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"
```

 

For the keywords `true` and `null`, the `typeof`
operator returns the following results:

 js 

```
typeof true; // returns "boolean"
typeof null; // returns "object"
```

 

For a number or string, the `typeof` operator returns the following results:

 js 

```
typeof 62; // returns "number"
typeof "Hello world"; // returns "string"
```

 

For property values, the `typeof` operator returns the type of value the
property contains:

 js 

```
typeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"
```

 

For methods and functions, the `typeof` operator returns results as follows:

 js 

```
typeof blur; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"
```

 

For predefined objects, the `typeof` operator returns results as follows:

 js 

```
typeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
```

 
 
 

### void 

 
 

The `void` operator specifies an expression to be evaluated without returning a value. `expression` is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.

 
 

## Relational operators 

 
 

A relational operator compares its operands and returns a Boolean value based on whether the comparison is true.

 
 

### in 

 
 

The `in` operator returns `true` if the specified property is in the specified object.
The syntax is:

 js 

```
propNameOrNumber in objectName
```

 

where `propNameOrNumber` is a string, numeric, or symbol expression representing a property name or array index, and `objectName` is the name of an object.

The following examples show some uses of the `in` operator.

 js 

```
// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
```

 
 
 

### instanceof 

 
 

The `instanceof` operator returns `true`
if the specified object is of the specified object type. The syntax is:

 js 

```
object instanceof objectType
```

 

where `object` is the object to test against `objectType`, and `objectType` is a constructor representing a type, such as `Map` or `Array` .

Use `instanceof` when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.

For example, the following code uses `instanceof` to determine whether `obj` is a `Map` object. Because `obj` is a `Map` object, the statements inside the `if` block execute.

 js 

```
const obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
```

 
 
 

## Basic expressions 

 
 

All operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals , but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.

 
 

### this 

 
 

The `this` keyword is usually used within a function. In general, when the function is attached to an object as a method, `this` refers to the object that the method is called on. It functions like a hidden parameter that is passed to the function. `this` is an expression that evaluates to the object, so you can use all the object operations we introduced.

 js 

```
this["propertyName"];
this.propertyName;
doSomething(this);
```

 

For example, suppose a function is defined as follows:

 js 

```
function getFullName() {
  return `${this.firstName} ${this.lastName}`;
}
```

 

We can now attach this function to an object, and it will use the properties of that object when called:

 js 

```
const person1 = {
  firstName: "Chris",
  lastName: "Martin",
};

const person2 = {
  firstName: "Chester",
  lastName: "Bennington",
};

// Attach the same function
person1.getFullName = getFullName;
person2.getFullName = getFullName;

console.log(person1.getFullName()); // "Chris Martin"
console.log(person2.getFullName()); // "Chester Bennington"
```

 
 
 

### Grouping operator 

 
 

The grouping operator `( )` controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.

 js 

```
const a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7

// now overriding precedence
// addition before multiplication
(a + b) * c; // 9

// which is equivalent to
a * c + b * c; // 9
```

 
 
 

### Property accessor 

 
 

The property accessor syntax gets property values on objects, using either dot notation or bracket notation.

 js 

```
object.property;
object["property"];
```

 

The working with objects guide goes into more details about object properties.

 
 

### Optional chaining 

 
 

The optional chaining syntax (`?.`) performs the chained operation on an object if it is defined and non-`null`, and otherwise short-circuits the operation and returns `undefined`.
This allows you to operate on a value that may be `null` or `undefined` without causing a `TypeError`.

 js 

```
maybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
```

 
 
 

### new 

 
 

You can use the `new` operator to create an instance of a user-defined object type or of one of the built-in object types. Use `new` as follows:

 js 

```
const objectName = new ObjectType(param1, param2, /* …, */ paramN);
```

 
 
 

### super 

 
 

The `super` keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.

 js 

```
super(args); // calls the parent constructor.
super.functionOnParent(args);
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#search

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 
- Previous 
- Next 

This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.

At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate .

The expression `x = 7` is an example of the first type. This expression uses the `=` operator to assign the value seven to the variable `x`. The expression itself evaluates to `7`.

The expression `3 + 4` is an example of the second type. This expression uses the `+` operator to add `3` and `4` together and produces a value, `7`. However, if it's not eventually part of a bigger construct (for example, a variable declaration like `const z = 3 + 4`), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.

As the examples above also illustrate, all complex expressions are joined by operators , such as `=` and `+`. In this section, we will introduce the following operators:

- Assignment operators 

- Comparison operators 

- Arithmetic operators 

- Bitwise operators 

- Logical operators 

- BigInt operators 

- String operators 

- Conditional (ternary) operator 

- Comma operator 

- Unary operators 

- Relational operators 

These operators join operands either formed by higher-precedence operators or one of the basic expressions . A complete and detailed list of operators and expressions is also available in the reference .

The precedence of operators determines the order they are applied when evaluating an expression. For example:

 js 

```
const x = 1 + 2 * 3;
const y = 2 * 3 + 1;
```

 

Despite `*` and `+` coming in different orders, both expressions would result in `7` because `*` has precedence over `+`, so the `*`-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.

JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:



```
operand1 operator operand2
```



For example, `3 + 4` or `x * y`. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.

A unary operator requires a single operand, either before or after the operator:



```
operator operand
operand operator
```



For example, `x++` or `++x`. The `operator operand` form is called a prefix unary operator, and the `operand operator` form is called a postfix unary operator. `++` and `--` are the only postfix operators in JavaScript — all other operators, like `!`, `typeof`, etc. are prefix.

 
 
 
 
 
 

## Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (`=`), which assigns the value of its right operand to its left operand.
That is, `x = f()` is an assignment expression that assigns the value of `f()` to `x`.

There are also compound assignment operators that are shorthand for the operations listed in the following table:

 
 
 
 Name 
 Shorthand operator 
 Meaning 
 
 
 
 
 Assignment 
 `x = f()` 
 `x = f()` 
 
 
 Addition assignment 
 `x += f()` 
 `x = x + f()` 
 
 
 Subtraction assignment 
 `x -= f()` 
 `x = x - f()` 
 
 
 Multiplication assignment 
 `x *= f()` 
 `x = x * f()` 
 
 
 Division assignment 
 `x /= f()` 
 `x = x / f()` 
 
 
 Remainder assignment 
 `x %= f()` 
 `x = x % f()` 
 
 
 Exponentiation assignment 
 `x **= f()` 
 `x = x ** f()` 
 
 
 Left shift assignment 
 `x 
 `x = x 
 
 
 Right shift assignment 
 `x >>= f()` 
 `x = x >> f()` 
 
 
 Unsigned right shift assignment 
 `x >>>= f()` 
 `x = x >>> f()` 
 
 
 Bitwise AND assignment 
 `x &= f()` 
 `x = x & f()` 
 
 
 Bitwise XOR assignment 
 `x ^= f()` 
 `x = x ^ f()` 
 
 
 Bitwise OR assignment 
 `x |= f()` 
 `x = x | f()` 
 
 
 Logical AND assignment 
 `x &&= f()` 
 `x && (x = f())` 
 
 
 Logical OR assignment 
 `x ||= f()` 
 `x || (x = f())` 
 
 
 Nullish coalescing assignment 
 `x ??= f()` 
 `x ?? (x = f())` 
 
 
 
 
 

### Assigning to properties 

 
 

If an expression evaluates to an object , then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:

 js 

```
const obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.
```

 

For more information about objects, read Working with Objects .

If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:

 js 

```
const val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.
```

 

In strict mode , the code above throws, because one cannot assign properties to primitives.

It is an error to assign values to unmodifiable properties or to properties of an expression without properties (`null` or `undefined`).

 
 

### Destructuring 

 
 

For more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.

Without destructuring, it takes multiple statements to extract values from arrays and objects:

 js 

```
const foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];
```

 

With destructuring, you can extract multiple values into distinct variables using a single statement:

 js 

```
const [one, two, three] = foo;
```

 
 
 

### Evaluation and nesting 

 
 

In general, assignments are used within a variable declaration (i.e., with `const` , `let` , or `var` ) or as standalone statements.

 js 

```
// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().
```

 

However, like other expressions, assignment expressions like `x = f()` evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.

Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments .
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.

By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.

 js 

```
let x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

 

The evaluation result matches the expression to the right of the `=` sign in the
"Meaning" column of the table above. That means that `x = f()` evaluates into
whatever `f()`'s result is, `x += f()` evaluates into the resulting sum `x + f()`,
`x **= f()` evaluates into the resulting power `x ** f()`, and so on.

In the case of logical assignments, `x &&= f()`,
`x ||= f()`, and `x ??= f()`, the return value is that of the
logical operation without the assignment, so `x && f()`,
`x || f()`, and `x ?? f()`, respectively.

When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left 
(they are right-associative ), but they are evaluated left to right .

Note that, for all assignment operators other than `=` itself,
the resulting values are always based on the operands' values before 
the operation.

For example, assume that the following functions `f` and `g`
and the variables `x` and `y` have been declared:

 js 

```
function f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;
```

 

Consider these three examples:

 js 

```
y = x = f();
y = [f(), x = g()];
x[f()] = g();
```

 

#### Evaluation example 1

`y = x = f()` is equivalent to `y = (x = f())`,
because the assignment operator `=` is right-associative .
However, it evaluates from left to right:

- The assignment expression `y = x = f()` starts to evaluate.

 The `y` on this assignment's left-hand side evaluates
into a reference to the variable named `y`.

- The assignment expression `x = f()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- That `2` result from `f()` is assigned to `x`.

 
- The assignment expression `x = f()` has now finished evaluating;
its result is the new value of `x`, which is `2`.

- That `2` result in turn is also assigned to `y`.

 
- The assignment expression `y = x = f()` has now finished evaluating;
its result is the new value of `y` – which happens to be `2`.
`x` and `y` are assigned to `2`,
and the console has printed "F!".

#### Evaluation example 2

`y = [ f(), x = g() ]` also evaluates from left to right:

- The assignment expression `y = [ f(), x = g() ]` starts to evaluate.

 The `y` on this assignment's left-hand evaluates
into a reference to the variable named `y`.

- The inner array literal `[ f(), x = g() ]` starts to evaluate.

 The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- The assignment expression `x = g()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` result from `g()` is assigned to `x`.

 
- The assignment expression `x = g()` has now finished evaluating;
its result is the new value of `x`, which is `3`.
That `3` result becomes the next element
in the inner array literal (after the `2` from the `f()`).

 
- The inner array literal `[ f(), x = g() ]`
has now finished evaluating;
its result is an array with two values: `[ 2, 3 ]`.

- That `[ 2, 3 ]` array is now assigned to `y`.

 
- The assignment expression `y = [ f(), x = g() ]` has
now finished evaluating;
its result is the new value of `y` – which happens to be `[ 2, 3 ]`.
`x` is now assigned to `3`,
`y` is now assigned to `[ 2, 3 ]`,
and the console has printed "F!" then "G!".

#### Evaluation example 3

`x[f()] = g()` also evaluates from left to right.
(This example assumes that `x` is already assigned to some object.
For more information about objects, read Working with Objects .)

- The assignment expression `x[f()] = g()` starts to evaluate.

 The `x[f()]` property access on this assignment's left-hand
starts to evaluate.

 The `x` in this property access evaluates
into a reference to the variable named `x`.

- Then the function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

 
- The `x[f()]` property access on this assignment
has now finished evaluating;
its result is a variable property reference: `x[2]`.

- Then the function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` is now assigned to `x[2]`.
(This step will succeed only if `x` is assigned to an object .)

 
- The assignment expression `x[f()] = g()` has now finished evaluating;
its result is the new value of `x[2]` – which happens to be `3`.
`x[2]` is now assigned to `3`,
and the console has printed "F!" then "G!".

 
 

### Avoid assignment chains 

 
 

Chaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
 chaining assignments in the same statement is discouraged .

In particular, putting a variable chain in a `const` , `let` , or `var` statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the `const`/`let`/`var` statement.
For example:

 js 

```
const z = y = x = f();
```

 

This statement seemingly declares the variables `x`, `y`, and `z`.
However, it only actually declares the variable `z`.
`y` and `x` are either invalid references to nonexistent variables (in strict mode ) or, worse, would implicitly create global variables for `x` and `y` in sloppy mode .

 
 

## Comparison operators 

 
 

A comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the `===` and `!==` operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:

 js 

```
const var1 = 3;
const var2 = 4;
```

 
 
 
 Comparison operators
 
 
 
 Operator 
 Description 
 Examples returning true 
 
 
 
 
 
 Equal (`==`)
 
 Returns `true` if the operands are equal. 
 
 `3 == var1`
 

`"3" == var1`

 `3 == '3'`
 
 
 
 
 Not equal (`!=`)
 
 Returns `true` if the operands are not equal. 
 
 `var1 != 4var2 != "3"`
 
 
 
 
 Strict equal (`===`)
 
 
 Returns `true` if the operands are equal and of the same
 type. See also `Object.is` and
 sameness in JS .
 
 `3 === var1` 
 
 
 
 Strict not equal (`!==`)
 
 
 Returns `true` if the operands are of the same type but not equal, or are of different type.
 
 
 `var1 !== "3"3 !== '3'`
 
 
 
 
 Greater than (`>`)
 
 
 Returns `true` if the left operand is greater than the right operand.
 
 
 `var2 > var1"12" > 2`
 
 
 
 
 Greater than or equal 
 (`>=`)
 
 
 Returns `true` if the left operand is greater than or equal to the right operand.
 
 
 `var2 >= var1var1 >= 3`
 
 
 
 
 Less than 
 (` 
 
 Returns `true` if the left operand is less than the right operand.
 
 
 `var1 
 
 
 
 Less than or equal 
 (` 
 
 Returns `true` if the left operand is less than or equal to the right operand.
 
 
 `var1 
 
 
 
 

 Note: 
`=>` is not a comparison operator but rather is the notation
for Arrow functions .

 
 
 

## Arithmetic operators 

 
 

An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces `Infinity` ). For example:

 js 

```
1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true
```

 

In addition to the standard arithmetic operations (`+`, `-`, `*`, `/`), JavaScript provides the arithmetic operators listed in the following table:

 
 
 Arithmetic operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Remainder (`%`)
 
 
 Binary operator. Returns the integer remainder of dividing the two operands.
 
 12 % 5 returns 2. 
 
 
 
 Increment (`++`)
 
 
 Unary operator. Adds one to its operand. If used as a prefix operator
 (`++x`), returns the value of its operand after adding one;
 if used as a postfix operator (`x++`), returns the value of
 its operand before adding one.
 
 
 If `x` is 3, then `++x` sets `x` to 4
 and returns 4, whereas `x++` returns 3 and, only then, sets `x` to 4.
 
 
 
 
 Decrement (`--`)
 
 
 Unary operator. Subtracts one from its operand.
 The return value is analogous to that for the increment operator.
 
 
 If `x` is 3, then `--x` sets `x` to 2
 and returns 2, whereas `x--` returns 3 and, only then, sets `x` to 2.
 
 
 
 
 Unary negation (`-`)
 
 Unary operator. Returns the negation of its operand. 
 If `x` is 3, then `-x` returns -3. 
 
 
 
 Unary plus (`+`)
 
 
 Unary operator. Attempts to convert the operand to a number , if it is not already.
 
 
 

`+"3"` returns `3`.

 

`+true` returns `1`.

 
 
 
 
 Exponentiation operator (`**`)
 
 
 Calculates the `base` to the `exponent` power,
 that is, `base^exponent`
 
 
 `2 ** 3` returns `8`.
`10 ** -1`
 returns `0.1`.
 
 
 
 
 
 

## Bitwise operators 

 
 

A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.

The following table summarizes JavaScript's bitwise operators.

 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 Bitwise AND 
 `a & b` 
 Returns a one in each bit position for which the corresponding bits of both operands are ones. 
 
 
 Bitwise OR 
 `a | b` 
 Returns a zero in each bit position for which the corresponding bits of both operands are zeros. 
 
 
 Bitwise XOR 
 `a ^ b` 
 Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.] 
 
 
 Bitwise NOT 
 `~ a` 
 Inverts the bits of its operand. 
 
 
 Left shift 
 `a 
 Shifts `a` in binary representation `b` bits to the left, shifting in zeros from the right. 
 
 
 Sign-propagating right shift 
 `a >> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off. 
 
 
 Zero-fill right shift 
 `a >>> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off, and shifting in zeros from the left. 
 
 
 
 
 

### Bitwise logical operators 

 
 

Conceptually, the bitwise logical operators work as follows:

- 

The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:



```
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001
```



- 

Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.

- 

The operator is applied to each pair of bits, and the result is constructed bitwise.

For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:

 
 
 
 Expression 
 Result 
 Binary Description 
 
 
 
 
 `15 & 9` 
 `9` 
 `1111 & 1001 = 1001` 
 
 
 `15 | 9` 
 `15` 
 `1111 | 1001 = 1111` 
 
 
 `15 ^ 9` 
 `6` 
 `1111 ^ 1001 = 0110` 
 
 
 `~15` 
 `-16` 
 `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` 
 
 
 `~9` 
 `-10` 
 `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` 
 
 
 

Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). `~x` evaluates to the same value that
`-x - 1` evaluates to.

 
 

### Bitwise shift operators 

 
 

The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.

Shift operators convert their operands to thirty-two-bit integers and return a result of either type `Number` or `BigInt` : specifically, if the type
of the left operand is `BigInt` , they return `BigInt` ;
otherwise, they return `Number` .

The shift operators are listed in the following table.

 
 
 Bitwise shift operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Left shift 
(` 
 
 This operator shifts the first operand the specified number of bits to
 the left. Excess bits shifted off to the left are discarded. Zero bits
 are shifted in from the right.
 
 
 `9 
 
 
 
 Sign-propagating right shift (`>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Copies of
 the leftmost bit are shifted in from the left.
 
 
 `9>>2` yields 2, because 1001 shifted 2 bits to the right
 becomes 10, which is 2. Likewise, `-9>>2` yields -3, because the sign is preserved.
 
 
 
 
 Zero-fill right shift (`>>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Zero bits
 are shifted in from the left.
 
 
 `19>>>2` yields 4, because 10011 shifted 2 bits to the right
 becomes 100, which is 4. For non-negative numbers, zero-fill right shift
 and sign-propagating right shift yield the same result.
 
 
 
 
 
 

## Logical operators 

 
 

Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the `&&`, `||`, and `??` operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

 
 
 Logical operators
 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 
 Logical AND (`&&`)
 
 `expr1 && expr2` 
 
 Returns `expr1` if it can be converted to `false`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `&&` returns `true` if both
 operands are true; otherwise, returns `false`.
 
 
 
 
 Logical OR (`||`)
 
 `expr1 || expr2` 
 
 Returns `expr1` if it can be converted to `true`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `||` returns `true` if either operand is
 true; if both are false, returns `false`.
 
 
 
 
 Nullish coalescing operator (`??`)
 
 `expr1 ?? expr2` 
 
 Returns `expr1` if it is neither `null` nor
 `undefined`; otherwise, returns `expr2`.
 
 
 
 
 Logical NOT (`!`)
 
 `!expr` 
 
 Returns `false` if its single operand can be converted
 to `true`; otherwise, returns `true`.
 
 
 
 

Examples of expressions that can be converted to `false` are those that evaluate to `null`, `0`, `0n`, `NaN`, the empty string (`""`), or `undefined`.

The following code shows examples of the `&&` (logical AND) operator.

 js 

```
const a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false
```

 

The following code shows examples of the `||` (logical OR) operator.

 js 

```
const o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat
```

 

The following code shows examples of the `??` (nullish coalescing) operator.

 js 

```
const n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0
```

 

Note how `??` works like `||`, but it only returns the second expression when the first one is " nullish ", i.e., `null` or `undefined` . `??` is a better alternative than `||` for setting defaults for values that might be `null` or `undefined`, in particular when values like `''` or `0` are valid values and the default should not apply.

The following code shows examples of the `!` (logical NOT) operator.

 js 

```
const n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
```

 
 
 

### Short-circuit evaluation 

 
 

As logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

- `falsy && anything` is short-circuit evaluated to the falsy value.

- `truthy || anything` is short-circuit evaluated to the truthy value.

- `nonNullish ?? anything` is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
 anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.

 
 

## BigInt operators 

 
 

Most operators that can be used between numbers can be used between `BigInt` values as well.

 js 

```
// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n
```

 

One exception is unsigned right shift (`>>>`) , which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".

 js 

```
const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

 

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.

 js 

```
const a = 1n + 2; // TypeError: Cannot mix BigInt and other types
```

 

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.

 js 

```
const a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n
```

 

You can compare BigInts with numbers.

 js 

```
const a = 1n > 2; // false
const b = 3 > 2n; // true
```

 
 
 

## String operators 

 
 

In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.

For example,

 js 

```
console.log("my " + "string"); // console logs the string "my string".
```

 

The shorthand assignment operator `+=` can also be used to concatenate strings.

For example,

 js 

```
let myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
```

 
 
 

## Conditional (ternary) operator 

 
 

The conditional operator 
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:

 js 

```
condition ? val1 : val2
```

 

If `condition` is true, the operator has the value of `val1`.
Otherwise it has the value of `val2`. You can use the conditional operator anywhere you would use a standard operator.

For example,

 js 

```
const status = age >= 18 ? "adult" : "minor";
```

 

This statement assigns the value "adult" to the variable `status` if
`age` is eighteen or more. Otherwise, it assigns the value "minor" to
`status`.

 
 

## Comma operator 

 
 

The comma operator (`,`)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a `for` loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.

For example, if `a` is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:

 js 

```
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

 
 
 

## Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 

### delete 

 
 

The `delete` operator deletes an object's property.
The syntax is:

 js 

```
delete object.property;
delete object[propertyKey];
delete objectName[index];
```

 

where `object` is the name of an object, `property` is an existing property, and `propertyKey` is a string or symbol referring to an existing property.

If the `delete` operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield `undefined`.
The `delete` operator returns `true` if the operation is possible; it returns `false` if the operation is not possible.

 js 

```
delete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)
```

 

#### Deleting array elements

Since arrays are just objects, it's technically possible to `delete` elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value `undefined`.
To actually manipulate the array, use the various array methods such as `splice` .

 
 

### typeof 

 
 

The `typeof` operator returns a string indicating the type of the unevaluated operand.
`operand` is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.

Suppose you define the following variables:

 js 

```
const myFun = () => 5 + 2;
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();
```

 

The `typeof` operator returns the following results for these variables:

 js 

```
typeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"
```

 

For the keywords `true` and `null`, the `typeof`
operator returns the following results:

 js 

```
typeof true; // returns "boolean"
typeof null; // returns "object"
```

 

For a number or string, the `typeof` operator returns the following results:

 js 

```
typeof 62; // returns "number"
typeof "Hello world"; // returns "string"
```

 

For property values, the `typeof` operator returns the type of value the
property contains:

 js 

```
typeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"
```

 

For methods and functions, the `typeof` operator returns results as follows:

 js 

```
typeof blur; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"
```

 

For predefined objects, the `typeof` operator returns results as follows:

 js 

```
typeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
```

 
 
 

### void 

 
 

The `void` operator specifies an expression to be evaluated without returning a value. `expression` is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.

 
 

## Relational operators 

 
 

A relational operator compares its operands and returns a Boolean value based on whether the comparison is true.

 
 

### in 

 
 

The `in` operator returns `true` if the specified property is in the specified object.
The syntax is:

 js 

```
propNameOrNumber in objectName
```

 

where `propNameOrNumber` is a string, numeric, or symbol expression representing a property name or array index, and `objectName` is the name of an object.

The following examples show some uses of the `in` operator.

 js 

```
// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
```

 
 
 

### instanceof 

 
 

The `instanceof` operator returns `true`
if the specified object is of the specified object type. The syntax is:

 js 

```
object instanceof objectType
```

 

where `object` is the object to test against `objectType`, and `objectType` is a constructor representing a type, such as `Map` or `Array` .

Use `instanceof` when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.

For example, the following code uses `instanceof` to determine whether `obj` is a `Map` object. Because `obj` is a `Map` object, the statements inside the `if` block execute.

 js 

```
const obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
```

 
 
 

## Basic expressions 

 
 

All operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals , but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.

 
 

### this 

 
 

The `this` keyword is usually used within a function. In general, when the function is attached to an object as a method, `this` refers to the object that the method is called on. It functions like a hidden parameter that is passed to the function. `this` is an expression that evaluates to the object, so you can use all the object operations we introduced.

 js 

```
this["propertyName"];
this.propertyName;
doSomething(this);
```

 

For example, suppose a function is defined as follows:

 js 

```
function getFullName() {
  return `${this.firstName} ${this.lastName}`;
}
```

 

We can now attach this function to an object, and it will use the properties of that object when called:

 js 

```
const person1 = {
  firstName: "Chris",
  lastName: "Martin",
};

const person2 = {
  firstName: "Chester",
  lastName: "Bennington",
};

// Attach the same function
person1.getFullName = getFullName;
person2.getFullName = getFullName;

console.log(person1.getFullName()); // "Chris Martin"
console.log(person2.getFullName()); // "Chester Bennington"
```

 
 
 

### Grouping operator 

 
 

The grouping operator `( )` controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.

 js 

```
const a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7

// now overriding precedence
// addition before multiplication
(a + b) * c; // 9

// which is equivalent to
a * c + b * c; // 9
```

 
 
 

### Property accessor 

 
 

The property accessor syntax gets property values on objects, using either dot notation or bracket notation.

 js 

```
object.property;
object["property"];
```

 

The working with objects guide goes into more details about object properties.

 
 

### Optional chaining 

 
 

The optional chaining syntax (`?.`) performs the chained operation on an object if it is defined and non-`null`, and otherwise short-circuits the operation and returns `undefined`.
This allows you to operate on a value that may be `null` or `undefined` without causing a `TypeError`.

 js 

```
maybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
```

 
 
 

### new 

 
 

You can use the `new` operator to create an instance of a user-defined object type or of one of the built-in object types. Use `new` as follows:

 js 

```
const objectName = new ObjectType(param1, param2, /* …, */ paramN);
```

 
 
 

### super 

 
 

The `super` keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.

 js 

```
super(args); // calls the parent constructor.
super.functionOnParent(args);
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Numbers and strings - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Numbers_and_strings

Numbers and strings - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Numbers and strings

 
 
 
- Previous 
- Next 

This chapter introduces the two most fundamental data types in JavaScript: numbers and strings. We will introduce their underlying representations, and functions used to work with and perform calculations on them.

 
 
 
 
 
 

## Numbers 

 
 

In JavaScript, numbers are implemented in double-precision 64-bit binary format IEEE 754 (i.e., a number between ±2^−1022 and ±2^+1023, or about ±10^−308 to ±10^+308, with a numeric precision of 53 bits). Integer values up to ±2^53 − 1 can be represented exactly.

In addition to being able to represent floating-point numbers, the number type has three symbolic values: `Infinity` , `-Infinity`, and `NaN` (not-a-number).

See also JavaScript data types and structures for context with other primitive types in JavaScript.

You can use four types of number literals: decimal, binary, octal, and hexadecimal.

 
 

### Decimal numbers 

 
 js 

```
1234567890
42
```

 

Decimal literals can start with a zero (`0`) followed by another decimal digit, but if all digits after the leading `0` are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with `0`, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the `0o` prefix instead.

 js 

```
0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal
```

 
 
 

### Binary numbers 

 
 

Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (`0b` or `0B`). If the digits after the `0b` are not 0 or 1, the following `SyntaxError` is thrown: "Missing binary digits after 0b".

 js 

```
0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607
```

 
 
 

### Octal numbers 

 
 

The standard syntax for octal numbers is to prefix them with `0o`. For example:

 js 

```
0O755 // 493
0o644 // 420
```

 

There's also a legacy syntax for octal numbers — by prefixing the octal number with a zero: `0644 === 420` and `"\045" === "%"`. If the digits after the `0` are outside the range 0 through 7, the number will be interpreted as a decimal number.

 js 

```
const n = 0755; // 493
const m = 0644; // 420
```

 

 Strict mode forbids this octal syntax.

 
 

### Hexadecimal numbers 

 
 

Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (`0x` or `0X`). If the digits after 0x are outside the range (0123456789ABCDEF), the following `SyntaxError` is thrown: "Identifier starts immediately after numeric literal".

 js 

```
0xFFFFFFFFFFFFF // 4503599627370495
0xabcdef123456  // 188900967593046
0XA             // 10
```

 
 
 

### Exponentiation 

 
 js 

```
0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000
```

 
 
 

### Numeric separators 

 
 

For all literal syntaxes shown above, an underscore (`_`) can be inserted between digits to improve readability.

 js 

```
1_000_000_000_000
1_050.95
0b1010_0001_1000_0101
0o2_2_5_6
0xA0_B0_C0
1_000_000_000_000_000_000_000n
```

 

See the lexical grammar reference for more details about number literals.

 
 

## Number object 

 
 

The built-in `Number` object has properties for numerical constants, such as maximum value, not-a-number, and infinity. You cannot change the values of these properties and you use them as follows:

 js 

```
const biggestNum = Number.MAX_VALUE;
const smallestNum = Number.MIN_VALUE;
const infiniteNum = Number.POSITIVE_INFINITY;
const negInfiniteNum = Number.NEGATIVE_INFINITY;
const notANum = Number.NaN;
```

 

You always refer to a property of the predefined `Number` object as shown above, and not as a property of a `Number` object you create yourself.

The following table summarizes the `Number` object's properties.

 
 
 
 Property 
 Description 
 
 
 
 
 `Number.MAX_VALUE` 
 The largest positive representable number (`1.7976931348623157e+308`) 
 
 
 `Number.MIN_VALUE` 
 The smallest positive representable number (`5e-324`) 
 
 
 `Number.NaN` 
 Special "not a number" value 
 
 
 `Number.NEGATIVE_INFINITY` 
 Special negative infinite value; returned on overflow 
 
 
 `Number.POSITIVE_INFINITY` 
 Special positive infinite value; returned on overflow 
 
 
 `Number.EPSILON` 
 Difference between `1` and the smallest value greater than `1` that can be represented as a `Number` (`2.220446049250313e-16`) 
 
 
 `Number.MIN_SAFE_INTEGER` 
 Minimum safe integer in JavaScript (−2^53 + 1, or `−9007199254740991`) 
 
 
 `Number.MAX_SAFE_INTEGER` 
 Maximum safe integer in JavaScript (+2^53 − 1, or `+9007199254740991`) 
 
 
 
 
 
 
 Method 
 Description 
 
 
 
 
 `Number.parseFloat()` 
 Parses a string argument and returns a floating point number. Same as the global `parseFloat()` function. 
 
 
 `Number.parseInt()` 
 Parses a string argument and returns an integer of the specified radix or base. Same as the global `parseInt()` function. 
 
 
 `Number.isFinite()` 
 Determines whether the passed value is a finite number. 
 
 
 `Number.isInteger()` 
 Determines whether the passed value is an integer. 
 
 
 `Number.isNaN()` 
 Determines whether the passed value is `NaN` . More robust version of the original global `isNaN()` . 
 
 
 `Number.isSafeInteger()` 
 Determines whether the provided value is a number that is a safe integer . 
 
 
 

The `Number` prototype provides methods for retrieving information from `Number` objects in various formats. The following table summarizes the methods of `Number.prototype`.

 
 
 
 Method 
 Description 
 
 
 
 
 `toExponential()` 
 Returns a string representing the number in exponential notation. 
 
 
 `toFixed()` 
 Returns a string representing the number in fixed-point notation. 
 
 
 `toPrecision()` 
 Returns a string representing the number to a specified precision in fixed-point notation. 
 
 
 
 
 

## Math object 

 
 

The built-in `Math` object has properties and methods for mathematical constants and functions. For example, the `Math` object's `PI` property has the value of pi (3.141…), which you would use in an application as

 js 

```
Math.PI;
```

 

Similarly, standard mathematical functions are methods of `Math`. These include trigonometric, logarithmic, exponential, and other functions. For example, if you want to use the trigonometric function sine, you would write

 js 

```
Math.sin(1.56);
```

 

Note that all trigonometric methods of `Math` take arguments in radians.

The following table summarizes the `Math` object's methods.

 
 
 Methods of
 `Math`
 
 
 
 Method 
 Description 
 
 
 
 
 `abs()` 
 Absolute value 
 
 
 
 `sin()` ,
 `cos()` ,
 `tan()` 
 
 Standard trigonometric functions; with the argument in radians. 
 
 
 
 `asin()` ,
 `acos()` ,
 `atan()` ,
 `atan2()` 
 
 Inverse trigonometric functions; return values in radians. 
 
 
 
 `sinh()` ,
 `cosh()` ,
 `tanh()` 
 
 Hyperbolic functions; argument in hyperbolic angle. 
 
 
 
 `asinh()` ,
 `acosh()` ,
 `atanh()` 
 
 Inverse hyperbolic functions; return values in hyperbolic angle. 
 
 
 
 

 `pow()` ,
 `exp()` ,
 `expm1()` ,
 `log()` ,
 `log10()` ,
 `log1p()` ,
 `log2()` 
 

 
 Exponential and logarithmic functions. 
 
 
 
 `floor()` ,
 `ceil()` 
 
 
 Returns the largest/smallest integer less/greater than or equal to an
 argument.
 
 
 
 
 `min()` ,
 `max()` 
 
 
 Returns the minimum or maximum (respectively) value of a comma separated
 list of numbers as arguments.
 
 
 
 `random()` 
 Returns a random number between 0 and 1. 
 
 
 
 `round()` ,
 `fround()` ,
 `trunc()` ,
 
 Rounding and truncation functions. 
 
 
 
 `sqrt()` ,
 `cbrt()` ,
 `hypot()` 
 
 
 Square root, cube root, Square root of the sum of square arguments.
 
 
 
 `sign()` 
 
 The sign of a number, indicating whether the number is positive,
 negative or zero.
 
 
 
 
 `clz32()` ,
 `imul()` 
 
 
 Number of leading zero bits in the 32-bit binary representation.
The
 result of the C-like 32-bit multiplication of the two arguments.
 
 
 
 

Unlike many other objects, you never create a `Math` object of your own. You always use the built-in `Math` object.

 
 

## BigInts 

 
 

One shortcoming of number values is they only have 64 bits. In practice, due to using IEEE 754 encoding, they cannot represent any integer larger than `Number.MAX_SAFE_INTEGER` (which is 2 53 - 1) accurately. To solve the need of encoding binary data and to interoperate with other languages that offer wide integers like `i64` (64-bit integers) and `i128` (128-bit integers), JavaScript also offers another data type to represent arbitrarily large integers : `BigInt` .

A BigInt can be defined as an integer literal suffixed by `n`:

 js 

```
const b1 = 123n;
// Can be arbitrarily large.
const b2 = -1234567890987654321n;
```

 

BigInts can also be constructed from number values or string values using the `BigInt` constructor.

 js 

```
const b1 = BigInt(123);
// Using a string prevents loss of precision, since long number
// literals don't represent what they seem like.
const b2 = BigInt("-1234567890987654321");
```

 

Conceptually, a BigInt is just an arbitrarily long sequence of bits which encodes an integer. You can safely do any arithmetic operations without losing precision or over-/underflowing.

 js 

```
const integer = 12 ** 34; // 4.9222352429520264e+36; only has limited precision
const bigint = 12n ** 34n; // 4922235242952026704037113243122008064n
```

 

Compared to numbers, BigInt values yield higher precision when representing large integers ; however, they cannot represent floating-point numbers . For example, division would round to zero:

 js 

```
const bigintDiv = 5n / 2n; // 2n, because there's no 2.5 in BigInt
```

 

`Math` functions cannot be used on BigInt values; they only work with numbers.

Choosing between BigInt and number depends on your use-case and your input's range. The precision of numbers should be able to accommodate most day-to-day tasks already, and BigInts are most suitable for handling binary data.

Read more about what you can do with BigInt values in the Expressions and Operators section, or the BigInt reference .

 
 

## Strings 

 
 

JavaScript's String type is used to represent textual data. It is a set of "elements" of 16-bit unsigned integer values (UTF-16 code units). Each element in the String occupies a position in the String. The first element is at index 0, the next at index 1, and so on. The length of a String is the number of elements in it. You can create strings using string literals or string objects.

 
 

### String literals 

 
 

You can declare strings in source code using either single or double quotes:

 js 

```
'foo'
"bar"
```

 

Within a string literal, most characters can be entered literally. The only exceptions are the backslash (`\`, which starts an escape sequence), the quote character being used to enclose the string, which terminates the string, and the newline character, which is a syntax error if not preceded by a backslash.

More advanced strings can be created using escape sequences:

#### Hexadecimal escape sequences

The number after \x is interpreted as a hexadecimal number.

 js 

```
"\xA9" // "©"
```

 

#### Unicode escape sequences

The Unicode escape sequences require at least four hexadecimal digits following `\u`.

 js 

```
"\u00A9" // "©"
```

 

#### Unicode code point escapes

With Unicode code point escapes, any character can be escaped using hexadecimal numbers so that it is possible to use Unicode code points up to `0x10FFFF`. With the four-digit Unicode escapes it is often necessary to write the surrogate halves separately to achieve the same result.

See also `String.fromCodePoint()` or `String.prototype.codePointAt()` .

 js 

```
"\u{2F804}"

// the same with simple Unicode escapes
"\uD87E\uDC04"
```

 
 
 

## String object 

 
 

You can call methods directly on a string value:

 js 

```
console.log("hello".toUpperCase()); // HELLO
```

 

The following methods are available on `String` values:

- Query: get the character or character code at a particular string index. Methods include `at()` , `charAt()` , `charCodeAt()` , and `codePointAt()` .

- Search: get information about a substring that conforms to a pattern, or test if a particular substring exists. Methods include `indexOf()` , `lastIndexOf()` , `startsWith()` , `endsWith()` , `includes()` , `match()` , `matchAll()` , and `search()` 

- Composition: combine strings into a longer string. Methods include `padStart()` , `padEnd()` , `concat()` , and `repeat()` .

- Decomposition: break a string into smaller strings. Methods include `split()` , `slice()` , `substring()` , `substr()` , `trim()` , `trimStart()` , and `trimEnd()` .

- Transformation: return a new string based on the current string's content. Methods include `toLowerCase()` , `toUpperCase()` , `toLocaleLowerCase()` , `toLocaleUpperCase()` , `normalize()` , and `toWellFormed()` .

When working with strings, there are two other objects that provide important functionality for string manipulation: `RegExp` and `Intl` . They are introduced in regular expressions and internationalization respectively.

 
 

## Template literals 

 
 

 Template literals are string literals allowing embedded expressions. You can use multi-line strings and string interpolation features with them.

Template literals are enclosed by backtick ( grave accent ) characters (```) instead of double or single quotes. Template literals can contain placeholders. These are indicated by the dollar sign and curly braces (`${expression}`).

 
 

### Multi-lines 

 
 

Any new line characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings:

 js 

```
console.log(
  "string text line 1\n\
string text line 2",
);
// "string text line 1
// string text line 2"
```

 

To get the same effect with multi-line strings, you can now write:

 js 

```
console.log(`string text line 1
string text line 2`);
// "string text line 1
// string text line 2"
```

 
 
 

### Embedded expressions 

 
 

In order to embed expressions within normal strings, you would use the following syntax:

 js 

```
const five = 5;
const ten = 10;
console.log(
  "Fifteen is " + (five + ten) + " and not " + (2 * five + ten) + ".",
);
// "Fifteen is 15 and not 20."
```

 

Now, with template literals, you are able to make use of the syntactic sugar making substitutions like this more readable:

 js 

```
const five = 5;
const ten = 10;
console.log(`Fifteen is ${five + ten} and not ${2 * five + ten}.`);
// "Fifteen is 15 and not 20."
```

 

For more information, read about Template literals in the JavaScript reference .

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 26, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#assignment_operators

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 
- Previous 
- Next 

This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.

At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate .

The expression `x = 7` is an example of the first type. This expression uses the `=` operator to assign the value seven to the variable `x`. The expression itself evaluates to `7`.

The expression `3 + 4` is an example of the second type. This expression uses the `+` operator to add `3` and `4` together and produces a value, `7`. However, if it's not eventually part of a bigger construct (for example, a variable declaration like `const z = 3 + 4`), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.

As the examples above also illustrate, all complex expressions are joined by operators , such as `=` and `+`. In this section, we will introduce the following operators:

- Assignment operators 

- Comparison operators 

- Arithmetic operators 

- Bitwise operators 

- Logical operators 

- BigInt operators 

- String operators 

- Conditional (ternary) operator 

- Comma operator 

- Unary operators 

- Relational operators 

These operators join operands either formed by higher-precedence operators or one of the basic expressions . A complete and detailed list of operators and expressions is also available in the reference .

The precedence of operators determines the order they are applied when evaluating an expression. For example:

 js 

```
const x = 1 + 2 * 3;
const y = 2 * 3 + 1;
```

 

Despite `*` and `+` coming in different orders, both expressions would result in `7` because `*` has precedence over `+`, so the `*`-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.

JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:



```
operand1 operator operand2
```



For example, `3 + 4` or `x * y`. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.

A unary operator requires a single operand, either before or after the operator:



```
operator operand
operand operator
```



For example, `x++` or `++x`. The `operator operand` form is called a prefix unary operator, and the `operand operator` form is called a postfix unary operator. `++` and `--` are the only postfix operators in JavaScript — all other operators, like `!`, `typeof`, etc. are prefix.

 
 
 
 
 
 

## Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (`=`), which assigns the value of its right operand to its left operand.
That is, `x = f()` is an assignment expression that assigns the value of `f()` to `x`.

There are also compound assignment operators that are shorthand for the operations listed in the following table:

 
 
 
 Name 
 Shorthand operator 
 Meaning 
 
 
 
 
 Assignment 
 `x = f()` 
 `x = f()` 
 
 
 Addition assignment 
 `x += f()` 
 `x = x + f()` 
 
 
 Subtraction assignment 
 `x -= f()` 
 `x = x - f()` 
 
 
 Multiplication assignment 
 `x *= f()` 
 `x = x * f()` 
 
 
 Division assignment 
 `x /= f()` 
 `x = x / f()` 
 
 
 Remainder assignment 
 `x %= f()` 
 `x = x % f()` 
 
 
 Exponentiation assignment 
 `x **= f()` 
 `x = x ** f()` 
 
 
 Left shift assignment 
 `x 
 `x = x 
 
 
 Right shift assignment 
 `x >>= f()` 
 `x = x >> f()` 
 
 
 Unsigned right shift assignment 
 `x >>>= f()` 
 `x = x >>> f()` 
 
 
 Bitwise AND assignment 
 `x &= f()` 
 `x = x & f()` 
 
 
 Bitwise XOR assignment 
 `x ^= f()` 
 `x = x ^ f()` 
 
 
 Bitwise OR assignment 
 `x |= f()` 
 `x = x | f()` 
 
 
 Logical AND assignment 
 `x &&= f()` 
 `x && (x = f())` 
 
 
 Logical OR assignment 
 `x ||= f()` 
 `x || (x = f())` 
 
 
 Nullish coalescing assignment 
 `x ??= f()` 
 `x ?? (x = f())` 
 
 
 
 
 

### Assigning to properties 

 
 

If an expression evaluates to an object , then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:

 js 

```
const obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.
```

 

For more information about objects, read Working with Objects .

If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:

 js 

```
const val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.
```

 

In strict mode , the code above throws, because one cannot assign properties to primitives.

It is an error to assign values to unmodifiable properties or to properties of an expression without properties (`null` or `undefined`).

 
 

### Destructuring 

 
 

For more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.

Without destructuring, it takes multiple statements to extract values from arrays and objects:

 js 

```
const foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];
```

 

With destructuring, you can extract multiple values into distinct variables using a single statement:

 js 

```
const [one, two, three] = foo;
```

 
 
 

### Evaluation and nesting 

 
 

In general, assignments are used within a variable declaration (i.e., with `const` , `let` , or `var` ) or as standalone statements.

 js 

```
// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().
```

 

However, like other expressions, assignment expressions like `x = f()` evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.

Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments .
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.

By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.

 js 

```
let x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

 

The evaluation result matches the expression to the right of the `=` sign in the
"Meaning" column of the table above. That means that `x = f()` evaluates into
whatever `f()`'s result is, `x += f()` evaluates into the resulting sum `x + f()`,
`x **= f()` evaluates into the resulting power `x ** f()`, and so on.

In the case of logical assignments, `x &&= f()`,
`x ||= f()`, and `x ??= f()`, the return value is that of the
logical operation without the assignment, so `x && f()`,
`x || f()`, and `x ?? f()`, respectively.

When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left 
(they are right-associative ), but they are evaluated left to right .

Note that, for all assignment operators other than `=` itself,
the resulting values are always based on the operands' values before 
the operation.

For example, assume that the following functions `f` and `g`
and the variables `x` and `y` have been declared:

 js 

```
function f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;
```

 

Consider these three examples:

 js 

```
y = x = f();
y = [f(), x = g()];
x[f()] = g();
```

 

#### Evaluation example 1

`y = x = f()` is equivalent to `y = (x = f())`,
because the assignment operator `=` is right-associative .
However, it evaluates from left to right:

- The assignment expression `y = x = f()` starts to evaluate.

 The `y` on this assignment's left-hand side evaluates
into a reference to the variable named `y`.

- The assignment expression `x = f()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- That `2` result from `f()` is assigned to `x`.

 
- The assignment expression `x = f()` has now finished evaluating;
its result is the new value of `x`, which is `2`.

- That `2` result in turn is also assigned to `y`.

 
- The assignment expression `y = x = f()` has now finished evaluating;
its result is the new value of `y` – which happens to be `2`.
`x` and `y` are assigned to `2`,
and the console has printed "F!".

#### Evaluation example 2

`y = [ f(), x = g() ]` also evaluates from left to right:

- The assignment expression `y = [ f(), x = g() ]` starts to evaluate.

 The `y` on this assignment's left-hand evaluates
into a reference to the variable named `y`.

- The inner array literal `[ f(), x = g() ]` starts to evaluate.

 The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- The assignment expression `x = g()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` result from `g()` is assigned to `x`.

 
- The assignment expression `x = g()` has now finished evaluating;
its result is the new value of `x`, which is `3`.
That `3` result becomes the next element
in the inner array literal (after the `2` from the `f()`).

 
- The inner array literal `[ f(), x = g() ]`
has now finished evaluating;
its result is an array with two values: `[ 2, 3 ]`.

- That `[ 2, 3 ]` array is now assigned to `y`.

 
- The assignment expression `y = [ f(), x = g() ]` has
now finished evaluating;
its result is the new value of `y` – which happens to be `[ 2, 3 ]`.
`x` is now assigned to `3`,
`y` is now assigned to `[ 2, 3 ]`,
and the console has printed "F!" then "G!".

#### Evaluation example 3

`x[f()] = g()` also evaluates from left to right.
(This example assumes that `x` is already assigned to some object.
For more information about objects, read Working with Objects .)

- The assignment expression `x[f()] = g()` starts to evaluate.

 The `x[f()]` property access on this assignment's left-hand
starts to evaluate.

 The `x` in this property access evaluates
into a reference to the variable named `x`.

- Then the function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

 
- The `x[f()]` property access on this assignment
has now finished evaluating;
its result is a variable property reference: `x[2]`.

- Then the function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` is now assigned to `x[2]`.
(This step will succeed only if `x` is assigned to an object .)

 
- The assignment expression `x[f()] = g()` has now finished evaluating;
its result is the new value of `x[2]` – which happens to be `3`.
`x[2]` is now assigned to `3`,
and the console has printed "F!" then "G!".

 
 

### Avoid assignment chains 

 
 

Chaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
 chaining assignments in the same statement is discouraged .

In particular, putting a variable chain in a `const` , `let` , or `var` statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the `const`/`let`/`var` statement.
For example:

 js 

```
const z = y = x = f();
```

 

This statement seemingly declares the variables `x`, `y`, and `z`.
However, it only actually declares the variable `z`.
`y` and `x` are either invalid references to nonexistent variables (in strict mode ) or, worse, would implicitly create global variables for `x` and `y` in sloppy mode .

 
 

## Comparison operators 

 
 

A comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the `===` and `!==` operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:

 js 

```
const var1 = 3;
const var2 = 4;
```

 
 
 
 Comparison operators
 
 
 
 Operator 
 Description 
 Examples returning true 
 
 
 
 
 
 Equal (`==`)
 
 Returns `true` if the operands are equal. 
 
 `3 == var1`
 

`"3" == var1`

 `3 == '3'`
 
 
 
 
 Not equal (`!=`)
 
 Returns `true` if the operands are not equal. 
 
 `var1 != 4var2 != "3"`
 
 
 
 
 Strict equal (`===`)
 
 
 Returns `true` if the operands are equal and of the same
 type. See also `Object.is` and
 sameness in JS .
 
 `3 === var1` 
 
 
 
 Strict not equal (`!==`)
 
 
 Returns `true` if the operands are of the same type but not equal, or are of different type.
 
 
 `var1 !== "3"3 !== '3'`
 
 
 
 
 Greater than (`>`)
 
 
 Returns `true` if the left operand is greater than the right operand.
 
 
 `var2 > var1"12" > 2`
 
 
 
 
 Greater than or equal 
 (`>=`)
 
 
 Returns `true` if the left operand is greater than or equal to the right operand.
 
 
 `var2 >= var1var1 >= 3`
 
 
 
 
 Less than 
 (` 
 
 Returns `true` if the left operand is less than the right operand.
 
 
 `var1 
 
 
 
 Less than or equal 
 (` 
 
 Returns `true` if the left operand is less than or equal to the right operand.
 
 
 `var1 
 
 
 
 

 Note: 
`=>` is not a comparison operator but rather is the notation
for Arrow functions .

 
 
 

## Arithmetic operators 

 
 

An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces `Infinity` ). For example:

 js 

```
1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true
```

 

In addition to the standard arithmetic operations (`+`, `-`, `*`, `/`), JavaScript provides the arithmetic operators listed in the following table:

 
 
 Arithmetic operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Remainder (`%`)
 
 
 Binary operator. Returns the integer remainder of dividing the two operands.
 
 12 % 5 returns 2. 
 
 
 
 Increment (`++`)
 
 
 Unary operator. Adds one to its operand. If used as a prefix operator
 (`++x`), returns the value of its operand after adding one;
 if used as a postfix operator (`x++`), returns the value of
 its operand before adding one.
 
 
 If `x` is 3, then `++x` sets `x` to 4
 and returns 4, whereas `x++` returns 3 and, only then, sets `x` to 4.
 
 
 
 
 Decrement (`--`)
 
 
 Unary operator. Subtracts one from its operand.
 The return value is analogous to that for the increment operator.
 
 
 If `x` is 3, then `--x` sets `x` to 2
 and returns 2, whereas `x--` returns 3 and, only then, sets `x` to 2.
 
 
 
 
 Unary negation (`-`)
 
 Unary operator. Returns the negation of its operand. 
 If `x` is 3, then `-x` returns -3. 
 
 
 
 Unary plus (`+`)
 
 
 Unary operator. Attempts to convert the operand to a number , if it is not already.
 
 
 

`+"3"` returns `3`.

 

`+true` returns `1`.

 
 
 
 
 Exponentiation operator (`**`)
 
 
 Calculates the `base` to the `exponent` power,
 that is, `base^exponent`
 
 
 `2 ** 3` returns `8`.
`10 ** -1`
 returns `0.1`.
 
 
 
 
 
 

## Bitwise operators 

 
 

A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.

The following table summarizes JavaScript's bitwise operators.

 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 Bitwise AND 
 `a & b` 
 Returns a one in each bit position for which the corresponding bits of both operands are ones. 
 
 
 Bitwise OR 
 `a | b` 
 Returns a zero in each bit position for which the corresponding bits of both operands are zeros. 
 
 
 Bitwise XOR 
 `a ^ b` 
 Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.] 
 
 
 Bitwise NOT 
 `~ a` 
 Inverts the bits of its operand. 
 
 
 Left shift 
 `a 
 Shifts `a` in binary representation `b` bits to the left, shifting in zeros from the right. 
 
 
 Sign-propagating right shift 
 `a >> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off. 
 
 
 Zero-fill right shift 
 `a >>> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off, and shifting in zeros from the left. 
 
 
 
 
 

### Bitwise logical operators 

 
 

Conceptually, the bitwise logical operators work as follows:

- 

The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:



```
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001
```



- 

Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.

- 

The operator is applied to each pair of bits, and the result is constructed bitwise.

For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:

 
 
 
 Expression 
 Result 
 Binary Description 
 
 
 
 
 `15 & 9` 
 `9` 
 `1111 & 1001 = 1001` 
 
 
 `15 | 9` 
 `15` 
 `1111 | 1001 = 1111` 
 
 
 `15 ^ 9` 
 `6` 
 `1111 ^ 1001 = 0110` 
 
 
 `~15` 
 `-16` 
 `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` 
 
 
 `~9` 
 `-10` 
 `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` 
 
 
 

Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). `~x` evaluates to the same value that
`-x - 1` evaluates to.

 
 

### Bitwise shift operators 

 
 

The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.

Shift operators convert their operands to thirty-two-bit integers and return a result of either type `Number` or `BigInt` : specifically, if the type
of the left operand is `BigInt` , they return `BigInt` ;
otherwise, they return `Number` .

The shift operators are listed in the following table.

 
 
 Bitwise shift operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Left shift 
(` 
 
 This operator shifts the first operand the specified number of bits to
 the left. Excess bits shifted off to the left are discarded. Zero bits
 are shifted in from the right.
 
 
 `9 
 
 
 
 Sign-propagating right shift (`>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Copies of
 the leftmost bit are shifted in from the left.
 
 
 `9>>2` yields 2, because 1001 shifted 2 bits to the right
 becomes 10, which is 2. Likewise, `-9>>2` yields -3, because the sign is preserved.
 
 
 
 
 Zero-fill right shift (`>>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Zero bits
 are shifted in from the left.
 
 
 `19>>>2` yields 4, because 10011 shifted 2 bits to the right
 becomes 100, which is 4. For non-negative numbers, zero-fill right shift
 and sign-propagating right shift yield the same result.
 
 
 
 
 
 

## Logical operators 

 
 

Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the `&&`, `||`, and `??` operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

 
 
 Logical operators
 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 
 Logical AND (`&&`)
 
 `expr1 && expr2` 
 
 Returns `expr1` if it can be converted to `false`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `&&` returns `true` if both
 operands are true; otherwise, returns `false`.
 
 
 
 
 Logical OR (`||`)
 
 `expr1 || expr2` 
 
 Returns `expr1` if it can be converted to `true`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `||` returns `true` if either operand is
 true; if both are false, returns `false`.
 
 
 
 
 Nullish coalescing operator (`??`)
 
 `expr1 ?? expr2` 
 
 Returns `expr1` if it is neither `null` nor
 `undefined`; otherwise, returns `expr2`.
 
 
 
 
 Logical NOT (`!`)
 
 `!expr` 
 
 Returns `false` if its single operand can be converted
 to `true`; otherwise, returns `true`.
 
 
 
 

Examples of expressions that can be converted to `false` are those that evaluate to `null`, `0`, `0n`, `NaN`, the empty string (`""`), or `undefined`.

The following code shows examples of the `&&` (logical AND) operator.

 js 

```
const a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false
```

 

The following code shows examples of the `||` (logical OR) operator.

 js 

```
const o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat
```

 

The following code shows examples of the `??` (nullish coalescing) operator.

 js 

```
const n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0
```

 

Note how `??` works like `||`, but it only returns the second expression when the first one is " nullish ", i.e., `null` or `undefined` . `??` is a better alternative than `||` for setting defaults for values that might be `null` or `undefined`, in particular when values like `''` or `0` are valid values and the default should not apply.

The following code shows examples of the `!` (logical NOT) operator.

 js 

```
const n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
```

 
 
 

### Short-circuit evaluation 

 
 

As logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

- `falsy && anything` is short-circuit evaluated to the falsy value.

- `truthy || anything` is short-circuit evaluated to the truthy value.

- `nonNullish ?? anything` is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
 anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.

 
 

## BigInt operators 

 
 

Most operators that can be used between numbers can be used between `BigInt` values as well.

 js 

```
// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n
```

 

One exception is unsigned right shift (`>>>`) , which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".

 js 

```
const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

 

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.

 js 

```
const a = 1n + 2; // TypeError: Cannot mix BigInt and other types
```

 

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.

 js 

```
const a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n
```

 

You can compare BigInts with numbers.

 js 

```
const a = 1n > 2; // false
const b = 3 > 2n; // true
```

 
 
 

## String operators 

 
 

In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.

For example,

 js 

```
console.log("my " + "string"); // console logs the string "my string".
```

 

The shorthand assignment operator `+=` can also be used to concatenate strings.

For example,

 js 

```
let myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
```

 
 
 

## Conditional (ternary) operator 

 
 

The conditional operator 
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:

 js 

```
condition ? val1 : val2
```

 

If `condition` is true, the operator has the value of `val1`.
Otherwise it has the value of `val2`. You can use the conditional operator anywhere you would use a standard operator.

For example,

 js 

```
const status = age >= 18 ? "adult" : "minor";
```

 

This statement assigns the value "adult" to the variable `status` if
`age` is eighteen or more. Otherwise, it assigns the value "minor" to
`status`.

 
 

## Comma operator 

 
 

The comma operator (`,`)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a `for` loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.

For example, if `a` is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:

 js 

```
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

 
 
 

## Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 

### delete 

 
 

The `delete` operator deletes an object's property.
The syntax is:

 js 

```
delete object.property;
delete object[propertyKey];
delete objectName[index];
```

 

where `object` is the name of an object, `property` is an existing property, and `propertyKey` is a string or symbol referring to an existing property.

If the `delete` operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield `undefined`.
The `delete` operator returns `true` if the operation is possible; it returns `false` if the operation is not possible.

 js 

```
delete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)
```

 

#### Deleting array elements

Since arrays are just objects, it's technically possible to `delete` elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value `undefined`.
To actually manipulate the array, use the various array methods such as `splice` .

 
 

### typeof 

 
 

The `typeof` operator returns a string indicating the type of the unevaluated operand.
`operand` is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.

Suppose you define the following variables:

 js 

```
const myFun = () => 5 + 2;
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();
```

 

The `typeof` operator returns the following results for these variables:

 js 

```
typeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"
```

 

For the keywords `true` and `null`, the `typeof`
operator returns the following results:

 js 

```
typeof true; // returns "boolean"
typeof null; // returns "object"
```

 

For a number or string, the `typeof` operator returns the following results:

 js 

```
typeof 62; // returns "number"
typeof "Hello world"; // returns "string"
```

 

For property values, the `typeof` operator returns the type of value the
property contains:

 js 

```
typeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"
```

 

For methods and functions, the `typeof` operator returns results as follows:

 js 

```
typeof blur; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"
```

 

For predefined objects, the `typeof` operator returns results as follows:

 js 

```
typeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
```

 
 
 

### void 

 
 

The `void` operator specifies an expression to be evaluated without returning a value. `expression` is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.

 
 

## Relational operators 

 
 

A relational operator compares its operands and returns a Boolean value based on whether the comparison is true.

 
 

### in 

 
 

The `in` operator returns `true` if the specified property is in the specified object.
The syntax is:

 js 

```
propNameOrNumber in objectName
```

 

where `propNameOrNumber` is a string, numeric, or symbol expression representing a property name or array index, and `objectName` is the name of an object.

The following examples show some uses of the `in` operator.

 js 

```
// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
```

 
 
 

### instanceof 

 
 

The `instanceof` operator returns `true`
if the specified object is of the specified object type. The syntax is:

 js 

```
object instanceof objectType
```

 

where `object` is the object to test against `objectType`, and `objectType` is a constructor representing a type, such as `Map` or `Array` .

Use `instanceof` when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.

For example, the following code uses `instanceof` to determine whether `obj` is a `Map` object. Because `obj` is a `Map` object, the statements inside the `if` block execute.

 js 

```
const obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
```

 
 
 

## Basic expressions 

 
 

All operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals , but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.

 
 

### this 

 
 

The `this` keyword is usually used within a function. In general, when the function is attached to an object as a method, `this` refers to the object that the method is called on. It functions like a hidden parameter that is passed to the function. `this` is an expression that evaluates to the object, so you can use all the object operations we introduced.

 js 

```
this["propertyName"];
this.propertyName;
doSomething(this);
```

 

For example, suppose a function is defined as follows:

 js 

```
function getFullName() {
  return `${this.firstName} ${this.lastName}`;
}
```

 

We can now attach this function to an object, and it will use the properties of that object when called:

 js 

```
const person1 = {
  firstName: "Chris",
  lastName: "Martin",
};

const person2 = {
  firstName: "Chester",
  lastName: "Bennington",
};

// Attach the same function
person1.getFullName = getFullName;
person2.getFullName = getFullName;

console.log(person1.getFullName()); // "Chris Martin"
console.log(person2.getFullName()); // "Chester Bennington"
```

 
 
 

### Grouping operator 

 
 

The grouping operator `( )` controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.

 js 

```
const a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7

// now overriding precedence
// addition before multiplication
(a + b) * c; // 9

// which is equivalent to
a * c + b * c; // 9
```

 
 
 

### Property accessor 

 
 

The property accessor syntax gets property values on objects, using either dot notation or bracket notation.

 js 

```
object.property;
object["property"];
```

 

The working with objects guide goes into more details about object properties.

 
 

### Optional chaining 

 
 

The optional chaining syntax (`?.`) performs the chained operation on an object if it is defined and non-`null`, and otherwise short-circuits the operation and returns `undefined`.
This allows you to operate on a value that may be `null` or `undefined` without causing a `TypeError`.

 js 

```
maybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
```

 
 
 

### new 

 
 

You can use the `new` operator to create an instance of a user-defined object type or of one of the built-in object types. Use `new` as follows:

 js 

```
const objectName = new ObjectType(param1, param2, /* …, */ paramN);
```

 
 
 

### super 

 
 

The `super` keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.

 js 

```
super(args); // calls the parent constructor.
super.functionOnParent(args);
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#comparison_operators

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 
- Previous 
- Next 

This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.

At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate .

The expression `x = 7` is an example of the first type. This expression uses the `=` operator to assign the value seven to the variable `x`. The expression itself evaluates to `7`.

The expression `3 + 4` is an example of the second type. This expression uses the `+` operator to add `3` and `4` together and produces a value, `7`. However, if it's not eventually part of a bigger construct (for example, a variable declaration like `const z = 3 + 4`), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.

As the examples above also illustrate, all complex expressions are joined by operators , such as `=` and `+`. In this section, we will introduce the following operators:

- Assignment operators 

- Comparison operators 

- Arithmetic operators 

- Bitwise operators 

- Logical operators 

- BigInt operators 

- String operators 

- Conditional (ternary) operator 

- Comma operator 

- Unary operators 

- Relational operators 

These operators join operands either formed by higher-precedence operators or one of the basic expressions . A complete and detailed list of operators and expressions is also available in the reference .

The precedence of operators determines the order they are applied when evaluating an expression. For example:

 js 

```
const x = 1 + 2 * 3;
const y = 2 * 3 + 1;
```

 

Despite `*` and `+` coming in different orders, both expressions would result in `7` because `*` has precedence over `+`, so the `*`-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.

JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:



```
operand1 operator operand2
```



For example, `3 + 4` or `x * y`. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.

A unary operator requires a single operand, either before or after the operator:



```
operator operand
operand operator
```



For example, `x++` or `++x`. The `operator operand` form is called a prefix unary operator, and the `operand operator` form is called a postfix unary operator. `++` and `--` are the only postfix operators in JavaScript — all other operators, like `!`, `typeof`, etc. are prefix.

 
 
 
 
 
 

## Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (`=`), which assigns the value of its right operand to its left operand.
That is, `x = f()` is an assignment expression that assigns the value of `f()` to `x`.

There are also compound assignment operators that are shorthand for the operations listed in the following table:

 
 
 
 Name 
 Shorthand operator 
 Meaning 
 
 
 
 
 Assignment 
 `x = f()` 
 `x = f()` 
 
 
 Addition assignment 
 `x += f()` 
 `x = x + f()` 
 
 
 Subtraction assignment 
 `x -= f()` 
 `x = x - f()` 
 
 
 Multiplication assignment 
 `x *= f()` 
 `x = x * f()` 
 
 
 Division assignment 
 `x /= f()` 
 `x = x / f()` 
 
 
 Remainder assignment 
 `x %= f()` 
 `x = x % f()` 
 
 
 Exponentiation assignment 
 `x **= f()` 
 `x = x ** f()` 
 
 
 Left shift assignment 
 `x 
 `x = x 
 
 
 Right shift assignment 
 `x >>= f()` 
 `x = x >> f()` 
 
 
 Unsigned right shift assignment 
 `x >>>= f()` 
 `x = x >>> f()` 
 
 
 Bitwise AND assignment 
 `x &= f()` 
 `x = x & f()` 
 
 
 Bitwise XOR assignment 
 `x ^= f()` 
 `x = x ^ f()` 
 
 
 Bitwise OR assignment 
 `x |= f()` 
 `x = x | f()` 
 
 
 Logical AND assignment 
 `x &&= f()` 
 `x && (x = f())` 
 
 
 Logical OR assignment 
 `x ||= f()` 
 `x || (x = f())` 
 
 
 Nullish coalescing assignment 
 `x ??= f()` 
 `x ?? (x = f())` 
 
 
 
 
 

### Assigning to properties 

 
 

If an expression evaluates to an object , then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:

 js 

```
const obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.
```

 

For more information about objects, read Working with Objects .

If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:

 js 

```
const val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.
```

 

In strict mode , the code above throws, because one cannot assign properties to primitives.

It is an error to assign values to unmodifiable properties or to properties of an expression without properties (`null` or `undefined`).

 
 

### Destructuring 

 
 

For more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.

Without destructuring, it takes multiple statements to extract values from arrays and objects:

 js 

```
const foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];
```

 

With destructuring, you can extract multiple values into distinct variables using a single statement:

 js 

```
const [one, two, three] = foo;
```

 
 
 

### Evaluation and nesting 

 
 

In general, assignments are used within a variable declaration (i.e., with `const` , `let` , or `var` ) or as standalone statements.

 js 

```
// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().
```

 

However, like other expressions, assignment expressions like `x = f()` evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.

Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments .
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.

By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.

 js 

```
let x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

 

The evaluation result matches the expression to the right of the `=` sign in the
"Meaning" column of the table above. That means that `x = f()` evaluates into
whatever `f()`'s result is, `x += f()` evaluates into the resulting sum `x + f()`,
`x **= f()` evaluates into the resulting power `x ** f()`, and so on.

In the case of logical assignments, `x &&= f()`,
`x ||= f()`, and `x ??= f()`, the return value is that of the
logical operation without the assignment, so `x && f()`,
`x || f()`, and `x ?? f()`, respectively.

When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left 
(they are right-associative ), but they are evaluated left to right .

Note that, for all assignment operators other than `=` itself,
the resulting values are always based on the operands' values before 
the operation.

For example, assume that the following functions `f` and `g`
and the variables `x` and `y` have been declared:

 js 

```
function f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;
```

 

Consider these three examples:

 js 

```
y = x = f();
y = [f(), x = g()];
x[f()] = g();
```

 

#### Evaluation example 1

`y = x = f()` is equivalent to `y = (x = f())`,
because the assignment operator `=` is right-associative .
However, it evaluates from left to right:

- The assignment expression `y = x = f()` starts to evaluate.

 The `y` on this assignment's left-hand side evaluates
into a reference to the variable named `y`.

- The assignment expression `x = f()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- That `2` result from `f()` is assigned to `x`.

 
- The assignment expression `x = f()` has now finished evaluating;
its result is the new value of `x`, which is `2`.

- That `2` result in turn is also assigned to `y`.

 
- The assignment expression `y = x = f()` has now finished evaluating;
its result is the new value of `y` – which happens to be `2`.
`x` and `y` are assigned to `2`,
and the console has printed "F!".

#### Evaluation example 2

`y = [ f(), x = g() ]` also evaluates from left to right:

- The assignment expression `y = [ f(), x = g() ]` starts to evaluate.

 The `y` on this assignment's left-hand evaluates
into a reference to the variable named `y`.

- The inner array literal `[ f(), x = g() ]` starts to evaluate.

 The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- The assignment expression `x = g()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` result from `g()` is assigned to `x`.

 
- The assignment expression `x = g()` has now finished evaluating;
its result is the new value of `x`, which is `3`.
That `3` result becomes the next element
in the inner array literal (after the `2` from the `f()`).

 
- The inner array literal `[ f(), x = g() ]`
has now finished evaluating;
its result is an array with two values: `[ 2, 3 ]`.

- That `[ 2, 3 ]` array is now assigned to `y`.

 
- The assignment expression `y = [ f(), x = g() ]` has
now finished evaluating;
its result is the new value of `y` – which happens to be `[ 2, 3 ]`.
`x` is now assigned to `3`,
`y` is now assigned to `[ 2, 3 ]`,
and the console has printed "F!" then "G!".

#### Evaluation example 3

`x[f()] = g()` also evaluates from left to right.
(This example assumes that `x` is already assigned to some object.
For more information about objects, read Working with Objects .)

- The assignment expression `x[f()] = g()` starts to evaluate.

 The `x[f()]` property access on this assignment's left-hand
starts to evaluate.

 The `x` in this property access evaluates
into a reference to the variable named `x`.

- Then the function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

 
- The `x[f()]` property access on this assignment
has now finished evaluating;
its result is a variable property reference: `x[2]`.

- Then the function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` is now assigned to `x[2]`.
(This step will succeed only if `x` is assigned to an object .)

 
- The assignment expression `x[f()] = g()` has now finished evaluating;
its result is the new value of `x[2]` – which happens to be `3`.
`x[2]` is now assigned to `3`,
and the console has printed "F!" then "G!".

 
 

### Avoid assignment chains 

 
 

Chaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
 chaining assignments in the same statement is discouraged .

In particular, putting a variable chain in a `const` , `let` , or `var` statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the `const`/`let`/`var` statement.
For example:

 js 

```
const z = y = x = f();
```

 

This statement seemingly declares the variables `x`, `y`, and `z`.
However, it only actually declares the variable `z`.
`y` and `x` are either invalid references to nonexistent variables (in strict mode ) or, worse, would implicitly create global variables for `x` and `y` in sloppy mode .

 
 

## Comparison operators 

 
 

A comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the `===` and `!==` operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:

 js 

```
const var1 = 3;
const var2 = 4;
```

 
 
 
 Comparison operators
 
 
 
 Operator 
 Description 
 Examples returning true 
 
 
 
 
 
 Equal (`==`)
 
 Returns `true` if the operands are equal. 
 
 `3 == var1`
 

`"3" == var1`

 `3 == '3'`
 
 
 
 
 Not equal (`!=`)
 
 Returns `true` if the operands are not equal. 
 
 `var1 != 4var2 != "3"`
 
 
 
 
 Strict equal (`===`)
 
 
 Returns `true` if the operands are equal and of the same
 type. See also `Object.is` and
 sameness in JS .
 
 `3 === var1` 
 
 
 
 Strict not equal (`!==`)
 
 
 Returns `true` if the operands are of the same type but not equal, or are of different type.
 
 
 `var1 !== "3"3 !== '3'`
 
 
 
 
 Greater than (`>`)
 
 
 Returns `true` if the left operand is greater than the right operand.
 
 
 `var2 > var1"12" > 2`
 
 
 
 
 Greater than or equal 
 (`>=`)
 
 
 Returns `true` if the left operand is greater than or equal to the right operand.
 
 
 `var2 >= var1var1 >= 3`
 
 
 
 
 Less than 
 (` 
 
 Returns `true` if the left operand is less than the right operand.
 
 
 `var1 
 
 
 
 Less than or equal 
 (` 
 
 Returns `true` if the left operand is less than or equal to the right operand.
 
 
 `var1 
 
 
 
 

 Note: 
`=>` is not a comparison operator but rather is the notation
for Arrow functions .

 
 
 

## Arithmetic operators 

 
 

An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces `Infinity` ). For example:

 js 

```
1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true
```

 

In addition to the standard arithmetic operations (`+`, `-`, `*`, `/`), JavaScript provides the arithmetic operators listed in the following table:

 
 
 Arithmetic operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Remainder (`%`)
 
 
 Binary operator. Returns the integer remainder of dividing the two operands.
 
 12 % 5 returns 2. 
 
 
 
 Increment (`++`)
 
 
 Unary operator. Adds one to its operand. If used as a prefix operator
 (`++x`), returns the value of its operand after adding one;
 if used as a postfix operator (`x++`), returns the value of
 its operand before adding one.
 
 
 If `x` is 3, then `++x` sets `x` to 4
 and returns 4, whereas `x++` returns 3 and, only then, sets `x` to 4.
 
 
 
 
 Decrement (`--`)
 
 
 Unary operator. Subtracts one from its operand.
 The return value is analogous to that for the increment operator.
 
 
 If `x` is 3, then `--x` sets `x` to 2
 and returns 2, whereas `x--` returns 3 and, only then, sets `x` to 2.
 
 
 
 
 Unary negation (`-`)
 
 Unary operator. Returns the negation of its operand. 
 If `x` is 3, then `-x` returns -3. 
 
 
 
 Unary plus (`+`)
 
 
 Unary operator. Attempts to convert the operand to a number , if it is not already.
 
 
 

`+"3"` returns `3`.

 

`+true` returns `1`.

 
 
 
 
 Exponentiation operator (`**`)
 
 
 Calculates the `base` to the `exponent` power,
 that is, `base^exponent`
 
 
 `2 ** 3` returns `8`.
`10 ** -1`
 returns `0.1`.
 
 
 
 
 
 

## Bitwise operators 

 
 

A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.

The following table summarizes JavaScript's bitwise operators.

 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 Bitwise AND 
 `a & b` 
 Returns a one in each bit position for which the corresponding bits of both operands are ones. 
 
 
 Bitwise OR 
 `a | b` 
 Returns a zero in each bit position for which the corresponding bits of both operands are zeros. 
 
 
 Bitwise XOR 
 `a ^ b` 
 Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.] 
 
 
 Bitwise NOT 
 `~ a` 
 Inverts the bits of its operand. 
 
 
 Left shift 
 `a 
 Shifts `a` in binary representation `b` bits to the left, shifting in zeros from the right. 
 
 
 Sign-propagating right shift 
 `a >> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off. 
 
 
 Zero-fill right shift 
 `a >>> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off, and shifting in zeros from the left. 
 
 
 
 
 

### Bitwise logical operators 

 
 

Conceptually, the bitwise logical operators work as follows:

- 

The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:



```
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001
```



- 

Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.

- 

The operator is applied to each pair of bits, and the result is constructed bitwise.

For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:

 
 
 
 Expression 
 Result 
 Binary Description 
 
 
 
 
 `15 & 9` 
 `9` 
 `1111 & 1001 = 1001` 
 
 
 `15 | 9` 
 `15` 
 `1111 | 1001 = 1111` 
 
 
 `15 ^ 9` 
 `6` 
 `1111 ^ 1001 = 0110` 
 
 
 `~15` 
 `-16` 
 `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` 
 
 
 `~9` 
 `-10` 
 `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` 
 
 
 

Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). `~x` evaluates to the same value that
`-x - 1` evaluates to.

 
 

### Bitwise shift operators 

 
 

The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.

Shift operators convert their operands to thirty-two-bit integers and return a result of either type `Number` or `BigInt` : specifically, if the type
of the left operand is `BigInt` , they return `BigInt` ;
otherwise, they return `Number` .

The shift operators are listed in the following table.

 
 
 Bitwise shift operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Left shift 
(` 
 
 This operator shifts the first operand the specified number of bits to
 the left. Excess bits shifted off to the left are discarded. Zero bits
 are shifted in from the right.
 
 
 `9 
 
 
 
 Sign-propagating right shift (`>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Copies of
 the leftmost bit are shifted in from the left.
 
 
 `9>>2` yields 2, because 1001 shifted 2 bits to the right
 becomes 10, which is 2. Likewise, `-9>>2` yields -3, because the sign is preserved.
 
 
 
 
 Zero-fill right shift (`>>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Zero bits
 are shifted in from the left.
 
 
 `19>>>2` yields 4, because 10011 shifted 2 bits to the right
 becomes 100, which is 4. For non-negative numbers, zero-fill right shift
 and sign-propagating right shift yield the same result.
 
 
 
 
 
 

## Logical operators 

 
 

Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the `&&`, `||`, and `??` operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

 
 
 Logical operators
 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 
 Logical AND (`&&`)
 
 `expr1 && expr2` 
 
 Returns `expr1` if it can be converted to `false`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `&&` returns `true` if both
 operands are true; otherwise, returns `false`.
 
 
 
 
 Logical OR (`||`)
 
 `expr1 || expr2` 
 
 Returns `expr1` if it can be converted to `true`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `||` returns `true` if either operand is
 true; if both are false, returns `false`.
 
 
 
 
 Nullish coalescing operator (`??`)
 
 `expr1 ?? expr2` 
 
 Returns `expr1` if it is neither `null` nor
 `undefined`; otherwise, returns `expr2`.
 
 
 
 
 Logical NOT (`!`)
 
 `!expr` 
 
 Returns `false` if its single operand can be converted
 to `true`; otherwise, returns `true`.
 
 
 
 

Examples of expressions that can be converted to `false` are those that evaluate to `null`, `0`, `0n`, `NaN`, the empty string (`""`), or `undefined`.

The following code shows examples of the `&&` (logical AND) operator.

 js 

```
const a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false
```

 

The following code shows examples of the `||` (logical OR) operator.

 js 

```
const o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat
```

 

The following code shows examples of the `??` (nullish coalescing) operator.

 js 

```
const n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0
```

 

Note how `??` works like `||`, but it only returns the second expression when the first one is " nullish ", i.e., `null` or `undefined` . `??` is a better alternative than `||` for setting defaults for values that might be `null` or `undefined`, in particular when values like `''` or `0` are valid values and the default should not apply.

The following code shows examples of the `!` (logical NOT) operator.

 js 

```
const n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
```

 
 
 

### Short-circuit evaluation 

 
 

As logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

- `falsy && anything` is short-circuit evaluated to the falsy value.

- `truthy || anything` is short-circuit evaluated to the truthy value.

- `nonNullish ?? anything` is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
 anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.

 
 

## BigInt operators 

 
 

Most operators that can be used between numbers can be used between `BigInt` values as well.

 js 

```
// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n
```

 

One exception is unsigned right shift (`>>>`) , which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".

 js 

```
const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

 

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.

 js 

```
const a = 1n + 2; // TypeError: Cannot mix BigInt and other types
```

 

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.

 js 

```
const a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n
```

 

You can compare BigInts with numbers.

 js 

```
const a = 1n > 2; // false
const b = 3 > 2n; // true
```

 
 
 

## String operators 

 
 

In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.

For example,

 js 

```
console.log("my " + "string"); // console logs the string "my string".
```

 

The shorthand assignment operator `+=` can also be used to concatenate strings.

For example,

 js 

```
let myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
```

 
 
 

## Conditional (ternary) operator 

 
 

The conditional operator 
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:

 js 

```
condition ? val1 : val2
```

 

If `condition` is true, the operator has the value of `val1`.
Otherwise it has the value of `val2`. You can use the conditional operator anywhere you would use a standard operator.

For example,

 js 

```
const status = age >= 18 ? "adult" : "minor";
```

 

This statement assigns the value "adult" to the variable `status` if
`age` is eighteen or more. Otherwise, it assigns the value "minor" to
`status`.

 
 

## Comma operator 

 
 

The comma operator (`,`)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a `for` loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.

For example, if `a` is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:

 js 

```
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

 
 
 

## Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 

### delete 

 
 

The `delete` operator deletes an object's property.
The syntax is:

 js 

```
delete object.property;
delete object[propertyKey];
delete objectName[index];
```

 

where `object` is the name of an object, `property` is an existing property, and `propertyKey` is a string or symbol referring to an existing property.

If the `delete` operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield `undefined`.
The `delete` operator returns `true` if the operation is possible; it returns `false` if the operation is not possible.

 js 

```
delete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)
```

 

#### Deleting array elements

Since arrays are just objects, it's technically possible to `delete` elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value `undefined`.
To actually manipulate the array, use the various array methods such as `splice` .

 
 

### typeof 

 
 

The `typeof` operator returns a string indicating the type of the unevaluated operand.
`operand` is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.

Suppose you define the following variables:

 js 

```
const myFun = () => 5 + 2;
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();
```

 

The `typeof` operator returns the following results for these variables:

 js 

```
typeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"
```

 

For the keywords `true` and `null`, the `typeof`
operator returns the following results:

 js 

```
typeof true; // returns "boolean"
typeof null; // returns "object"
```

 

For a number or string, the `typeof` operator returns the following results:

 js 

```
typeof 62; // returns "number"
typeof "Hello world"; // returns "string"
```

 

For property values, the `typeof` operator returns the type of value the
property contains:

 js 

```
typeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"
```

 

For methods and functions, the `typeof` operator returns results as follows:

 js 

```
typeof blur; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"
```

 

For predefined objects, the `typeof` operator returns results as follows:

 js 

```
typeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
```

 
 
 

### void 

 
 

The `void` operator specifies an expression to be evaluated without returning a value. `expression` is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.

 
 

## Relational operators 

 
 

A relational operator compares its operands and returns a Boolean value based on whether the comparison is true.

 
 

### in 

 
 

The `in` operator returns `true` if the specified property is in the specified object.
The syntax is:

 js 

```
propNameOrNumber in objectName
```

 

where `propNameOrNumber` is a string, numeric, or symbol expression representing a property name or array index, and `objectName` is the name of an object.

The following examples show some uses of the `in` operator.

 js 

```
// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
```

 
 
 

### instanceof 

 
 

The `instanceof` operator returns `true`
if the specified object is of the specified object type. The syntax is:

 js 

```
object instanceof objectType
```

 

where `object` is the object to test against `objectType`, and `objectType` is a constructor representing a type, such as `Map` or `Array` .

Use `instanceof` when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.

For example, the following code uses `instanceof` to determine whether `obj` is a `Map` object. Because `obj` is a `Map` object, the statements inside the `if` block execute.

 js 

```
const obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
```

 
 
 

## Basic expressions 

 
 

All operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals , but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.

 
 

### this 

 
 

The `this` keyword is usually used within a function. In general, when the function is attached to an object as a method, `this` refers to the object that the method is called on. It functions like a hidden parameter that is passed to the function. `this` is an expression that evaluates to the object, so you can use all the object operations we introduced.

 js 

```
this["propertyName"];
this.propertyName;
doSomething(this);
```

 

For example, suppose a function is defined as follows:

 js 

```
function getFullName() {
  return `${this.firstName} ${this.lastName}`;
}
```

 

We can now attach this function to an object, and it will use the properties of that object when called:

 js 

```
const person1 = {
  firstName: "Chris",
  lastName: "Martin",
};

const person2 = {
  firstName: "Chester",
  lastName: "Bennington",
};

// Attach the same function
person1.getFullName = getFullName;
person2.getFullName = getFullName;

console.log(person1.getFullName()); // "Chris Martin"
console.log(person2.getFullName()); // "Chester Bennington"
```

 
 
 

### Grouping operator 

 
 

The grouping operator `( )` controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.

 js 

```
const a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7

// now overriding precedence
// addition before multiplication
(a + b) * c; // 9

// which is equivalent to
a * c + b * c; // 9
```

 
 
 

### Property accessor 

 
 

The property accessor syntax gets property values on objects, using either dot notation or bracket notation.

 js 

```
object.property;
object["property"];
```

 

The working with objects guide goes into more details about object properties.

 
 

### Optional chaining 

 
 

The optional chaining syntax (`?.`) performs the chained operation on an object if it is defined and non-`null`, and otherwise short-circuits the operation and returns `undefined`.
This allows you to operate on a value that may be `null` or `undefined` without causing a `TypeError`.

 js 

```
maybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
```

 
 
 

### new 

 
 

You can use the `new` operator to create an instance of a user-defined object type or of one of the built-in object types. Use `new` as follows:

 js 

```
const objectName = new ObjectType(param1, param2, /* …, */ paramN);
```

 
 
 

### super 

 
 

The `super` keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.

 js 

```
super(args); // calls the parent constructor.
super.functionOnParent(args);
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Expressions and operators - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_operators#arithmetic_operators

Expressions and operators - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Expressions and operators

 
 
 
- Previous 
- Next 

This chapter describes JavaScript's expressions and operators, including assignment, comparison, arithmetic, bitwise, logical, string, ternary and more.

At a high level, an expression is a valid unit of code that resolves to a value. There are two types of expressions: those that have side effects (such as assigning values) and those that purely evaluate .

The expression `x = 7` is an example of the first type. This expression uses the `=` operator to assign the value seven to the variable `x`. The expression itself evaluates to `7`.

The expression `3 + 4` is an example of the second type. This expression uses the `+` operator to add `3` and `4` together and produces a value, `7`. However, if it's not eventually part of a bigger construct (for example, a variable declaration like `const z = 3 + 4`), its result will be immediately discarded — this is usually a programmer mistake because the evaluation doesn't produce any effects.

As the examples above also illustrate, all complex expressions are joined by operators , such as `=` and `+`. In this section, we will introduce the following operators:

- Assignment operators 

- Comparison operators 

- Arithmetic operators 

- Bitwise operators 

- Logical operators 

- BigInt operators 

- String operators 

- Conditional (ternary) operator 

- Comma operator 

- Unary operators 

- Relational operators 

These operators join operands either formed by higher-precedence operators or one of the basic expressions . A complete and detailed list of operators and expressions is also available in the reference .

The precedence of operators determines the order they are applied when evaluating an expression. For example:

 js 

```
const x = 1 + 2 * 3;
const y = 2 * 3 + 1;
```

 

Despite `*` and `+` coming in different orders, both expressions would result in `7` because `*` has precedence over `+`, so the `*`-joined expression will always be evaluated first. You can override operator precedence by using parentheses (which creates a grouped expression — the basic expression). To see a complete table of operator precedence as well as various caveats, see the Operator Precedence Reference page.

JavaScript has both binary and unary operators, and one special ternary operator, the conditional operator.
A binary operator requires two operands, one before the operator and one after the operator:



```
operand1 operator operand2
```



For example, `3 + 4` or `x * y`. This form is called an infix binary operator, because the operator is placed between two operands. All binary operators in JavaScript are infix.

A unary operator requires a single operand, either before or after the operator:



```
operator operand
operand operator
```



For example, `x++` or `++x`. The `operator operand` form is called a prefix unary operator, and the `operand operator` form is called a postfix unary operator. `++` and `--` are the only postfix operators in JavaScript — all other operators, like `!`, `typeof`, etc. are prefix.

 
 
 
 
 
 

## Assignment operators 

 
 

An assignment operator assigns a value to its left operand based on the value of its right operand.
The simple assignment operator is equal (`=`), which assigns the value of its right operand to its left operand.
That is, `x = f()` is an assignment expression that assigns the value of `f()` to `x`.

There are also compound assignment operators that are shorthand for the operations listed in the following table:

 
 
 
 Name 
 Shorthand operator 
 Meaning 
 
 
 
 
 Assignment 
 `x = f()` 
 `x = f()` 
 
 
 Addition assignment 
 `x += f()` 
 `x = x + f()` 
 
 
 Subtraction assignment 
 `x -= f()` 
 `x = x - f()` 
 
 
 Multiplication assignment 
 `x *= f()` 
 `x = x * f()` 
 
 
 Division assignment 
 `x /= f()` 
 `x = x / f()` 
 
 
 Remainder assignment 
 `x %= f()` 
 `x = x % f()` 
 
 
 Exponentiation assignment 
 `x **= f()` 
 `x = x ** f()` 
 
 
 Left shift assignment 
 `x 
 `x = x 
 
 
 Right shift assignment 
 `x >>= f()` 
 `x = x >> f()` 
 
 
 Unsigned right shift assignment 
 `x >>>= f()` 
 `x = x >>> f()` 
 
 
 Bitwise AND assignment 
 `x &= f()` 
 `x = x & f()` 
 
 
 Bitwise XOR assignment 
 `x ^= f()` 
 `x = x ^ f()` 
 
 
 Bitwise OR assignment 
 `x |= f()` 
 `x = x | f()` 
 
 
 Logical AND assignment 
 `x &&= f()` 
 `x && (x = f())` 
 
 
 Logical OR assignment 
 `x ||= f()` 
 `x || (x = f())` 
 
 
 Nullish coalescing assignment 
 `x ??= f()` 
 `x ?? (x = f())` 
 
 
 
 
 

### Assigning to properties 

 
 

If an expression evaluates to an object , then the left-hand side of an assignment expression may make assignments to properties of that expression.
For example:

 js 

```
const obj = {};

obj.x = 3;
console.log(obj.x); // Prints 3.
console.log(obj); // Prints { x: 3 }.

const key = "y";
obj[key] = 5;
console.log(obj[key]); // Prints 5.
console.log(obj); // Prints { x: 3, y: 5 }.
```

 

For more information about objects, read Working with Objects .

If an expression does not evaluate to an object, then assignments to properties of that expression do not assign:

 js 

```
const val = 0;
val.x = 3;

console.log(val.x); // Prints undefined.
console.log(val); // Prints 0.
```

 

In strict mode , the code above throws, because one cannot assign properties to primitives.

It is an error to assign values to unmodifiable properties or to properties of an expression without properties (`null` or `undefined`).

 
 

### Destructuring 

 
 

For more complex assignments, the destructuring syntax is a JavaScript expression that makes it possible to extract data from arrays or objects using a syntax that mirrors the construction of array and
object literals.

Without destructuring, it takes multiple statements to extract values from arrays and objects:

 js 

```
const foo = ["one", "two", "three"];

const one = foo[0];
const two = foo[1];
const three = foo[2];
```

 

With destructuring, you can extract multiple values into distinct variables using a single statement:

 js 

```
const [one, two, three] = foo;
```

 
 
 

### Evaluation and nesting 

 
 

In general, assignments are used within a variable declaration (i.e., with `const` , `let` , or `var` ) or as standalone statements.

 js 

```
// Declares a variable x and initializes it to the result of f().
// The result of the x = f() assignment expression is discarded.
let x = f();

x = g(); // Reassigns the variable x to the result of g().
```

 

However, like other expressions, assignment expressions like `x = f()` evaluate into a result value.
Although this result value is usually not used, it can then be used by another expression.

Chaining assignments or nesting assignments in other expressions can result in surprising behavior.
For this reason, some JavaScript style guides discourage chaining or nesting assignments .
Nevertheless, assignment chaining and nesting may occur sometimes, so it is important to be able to understand how they work.

By chaining or nesting an assignment expression, its result can itself be assigned to another variable.
It can be logged, it can be put inside an array literal or function call, and so on.

 js 

```
let x;
const y = (x = f()); // Or equivalently: const y = x = f();
console.log(y); // Logs the return value of the assignment x = f().

console.log(x = f()); // Logs the return value directly.

// An assignment expression can be nested in any place
// where expressions are generally allowed,
// such as array literals' elements or as function calls' arguments.
console.log([0, x = f(), 0]);
console.log(f(0, x = f(), 0));
```

 

The evaluation result matches the expression to the right of the `=` sign in the
"Meaning" column of the table above. That means that `x = f()` evaluates into
whatever `f()`'s result is, `x += f()` evaluates into the resulting sum `x + f()`,
`x **= f()` evaluates into the resulting power `x ** f()`, and so on.

In the case of logical assignments, `x &&= f()`,
`x ||= f()`, and `x ??= f()`, the return value is that of the
logical operation without the assignment, so `x && f()`,
`x || f()`, and `x ?? f()`, respectively.

When chaining these expressions without parentheses or other grouping operators
like array literals, the assignment expressions are grouped right to left 
(they are right-associative ), but they are evaluated left to right .

Note that, for all assignment operators other than `=` itself,
the resulting values are always based on the operands' values before 
the operation.

For example, assume that the following functions `f` and `g`
and the variables `x` and `y` have been declared:

 js 

```
function f() {
  console.log("F!");
  return 2;
}
function g() {
  console.log("G!");
  return 3;
}
let x, y;
```

 

Consider these three examples:

 js 

```
y = x = f();
y = [f(), x = g()];
x[f()] = g();
```

 

#### Evaluation example 1

`y = x = f()` is equivalent to `y = (x = f())`,
because the assignment operator `=` is right-associative .
However, it evaluates from left to right:

- The assignment expression `y = x = f()` starts to evaluate.

 The `y` on this assignment's left-hand side evaluates
into a reference to the variable named `y`.

- The assignment expression `x = f()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- That `2` result from `f()` is assigned to `x`.

 
- The assignment expression `x = f()` has now finished evaluating;
its result is the new value of `x`, which is `2`.

- That `2` result in turn is also assigned to `y`.

 
- The assignment expression `y = x = f()` has now finished evaluating;
its result is the new value of `y` – which happens to be `2`.
`x` and `y` are assigned to `2`,
and the console has printed "F!".

#### Evaluation example 2

`y = [ f(), x = g() ]` also evaluates from left to right:

- The assignment expression `y = [ f(), x = g() ]` starts to evaluate.

 The `y` on this assignment's left-hand evaluates
into a reference to the variable named `y`.

- The inner array literal `[ f(), x = g() ]` starts to evaluate.

 The function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

- The assignment expression `x = g()` starts to evaluate.

 The `x` on this assignment's left-hand side evaluates
into a reference to the variable named `x`.

- The function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` result from `g()` is assigned to `x`.

 
- The assignment expression `x = g()` has now finished evaluating;
its result is the new value of `x`, which is `3`.
That `3` result becomes the next element
in the inner array literal (after the `2` from the `f()`).

 
- The inner array literal `[ f(), x = g() ]`
has now finished evaluating;
its result is an array with two values: `[ 2, 3 ]`.

- That `[ 2, 3 ]` array is now assigned to `y`.

 
- The assignment expression `y = [ f(), x = g() ]` has
now finished evaluating;
its result is the new value of `y` – which happens to be `[ 2, 3 ]`.
`x` is now assigned to `3`,
`y` is now assigned to `[ 2, 3 ]`,
and the console has printed "F!" then "G!".

#### Evaluation example 3

`x[f()] = g()` also evaluates from left to right.
(This example assumes that `x` is already assigned to some object.
For more information about objects, read Working with Objects .)

- The assignment expression `x[f()] = g()` starts to evaluate.

 The `x[f()]` property access on this assignment's left-hand
starts to evaluate.

 The `x` in this property access evaluates
into a reference to the variable named `x`.

- Then the function call `f()` prints "F!" to the console and
then evaluates to the number `2`.

 
- The `x[f()]` property access on this assignment
has now finished evaluating;
its result is a variable property reference: `x[2]`.

- Then the function call `g()` prints "G!" to the console and
then evaluates to the number `3`.

- That `3` is now assigned to `x[2]`.
(This step will succeed only if `x` is assigned to an object .)

 
- The assignment expression `x[f()] = g()` has now finished evaluating;
its result is the new value of `x[2]` – which happens to be `3`.
`x[2]` is now assigned to `3`,
and the console has printed "F!" then "G!".

 
 

### Avoid assignment chains 

 
 

Chaining assignments or nesting assignments in other expressions can
result in surprising behavior. For this reason,
 chaining assignments in the same statement is discouraged .

In particular, putting a variable chain in a `const` , `let` , or `var` statement often does not work. Only the outermost/leftmost variable would get declared; other variables within the assignment chain are not declared by the `const`/`let`/`var` statement.
For example:

 js 

```
const z = y = x = f();
```

 

This statement seemingly declares the variables `x`, `y`, and `z`.
However, it only actually declares the variable `z`.
`y` and `x` are either invalid references to nonexistent variables (in strict mode ) or, worse, would implicitly create global variables for `x` and `y` in sloppy mode .

 
 

## Comparison operators 

 
 

A comparison operator compares its operands and returns a logical value based on whether the comparison is true.
The operands can be numerical, string, logical, or object values.
Strings are compared based on standard lexicographical ordering, using Unicode values.
In most cases, if the two operands are not of the same type, JavaScript attempts to convert them to an appropriate type for the comparison.
This behavior generally results in comparing the operands numerically.
The sole exceptions to type conversion within comparisons involve the `===` and `!==` operators, which perform strict equality and inequality comparisons.
These operators do not attempt to convert the operands to compatible types before checking equality.
The following table describes the comparison operators in terms of this sample code:

 js 

```
const var1 = 3;
const var2 = 4;
```

 
 
 
 Comparison operators
 
 
 
 Operator 
 Description 
 Examples returning true 
 
 
 
 
 
 Equal (`==`)
 
 Returns `true` if the operands are equal. 
 
 `3 == var1`
 

`"3" == var1`

 `3 == '3'`
 
 
 
 
 Not equal (`!=`)
 
 Returns `true` if the operands are not equal. 
 
 `var1 != 4var2 != "3"`
 
 
 
 
 Strict equal (`===`)
 
 
 Returns `true` if the operands are equal and of the same
 type. See also `Object.is` and
 sameness in JS .
 
 `3 === var1` 
 
 
 
 Strict not equal (`!==`)
 
 
 Returns `true` if the operands are of the same type but not equal, or are of different type.
 
 
 `var1 !== "3"3 !== '3'`
 
 
 
 
 Greater than (`>`)
 
 
 Returns `true` if the left operand is greater than the right operand.
 
 
 `var2 > var1"12" > 2`
 
 
 
 
 Greater than or equal 
 (`>=`)
 
 
 Returns `true` if the left operand is greater than or equal to the right operand.
 
 
 `var2 >= var1var1 >= 3`
 
 
 
 
 Less than 
 (` 
 
 Returns `true` if the left operand is less than the right operand.
 
 
 `var1 
 
 
 
 Less than or equal 
 (` 
 
 Returns `true` if the left operand is less than or equal to the right operand.
 
 
 `var1 
 
 
 
 

 Note: 
`=>` is not a comparison operator but rather is the notation
for Arrow functions .

 
 
 

## Arithmetic operators 

 
 

An arithmetic operator takes numerical values (either literals or variables) as their operands and returns a single numerical value.
The standard arithmetic operators are addition (`+`), subtraction (`-`), multiplication (`*`), and division (`/`).
These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces `Infinity` ). For example:

 js 

```
1 / 2; // 0.5
1 / 2 === 1.0 / 2.0; // this is true
```

 

In addition to the standard arithmetic operations (`+`, `-`, `*`, `/`), JavaScript provides the arithmetic operators listed in the following table:

 
 
 Arithmetic operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Remainder (`%`)
 
 
 Binary operator. Returns the integer remainder of dividing the two operands.
 
 12 % 5 returns 2. 
 
 
 
 Increment (`++`)
 
 
 Unary operator. Adds one to its operand. If used as a prefix operator
 (`++x`), returns the value of its operand after adding one;
 if used as a postfix operator (`x++`), returns the value of
 its operand before adding one.
 
 
 If `x` is 3, then `++x` sets `x` to 4
 and returns 4, whereas `x++` returns 3 and, only then, sets `x` to 4.
 
 
 
 
 Decrement (`--`)
 
 
 Unary operator. Subtracts one from its operand.
 The return value is analogous to that for the increment operator.
 
 
 If `x` is 3, then `--x` sets `x` to 2
 and returns 2, whereas `x--` returns 3 and, only then, sets `x` to 2.
 
 
 
 
 Unary negation (`-`)
 
 Unary operator. Returns the negation of its operand. 
 If `x` is 3, then `-x` returns -3. 
 
 
 
 Unary plus (`+`)
 
 
 Unary operator. Attempts to convert the operand to a number , if it is not already.
 
 
 

`+"3"` returns `3`.

 

`+true` returns `1`.

 
 
 
 
 Exponentiation operator (`**`)
 
 
 Calculates the `base` to the `exponent` power,
 that is, `base^exponent`
 
 
 `2 ** 3` returns `8`.
`10 ** -1`
 returns `0.1`.
 
 
 
 
 
 

## Bitwise operators 

 
 

A bitwise operator treats their operands as a set of 32 bits (zeros and ones), rather
than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has
a binary representation of 1001. Bitwise operators perform their operations on such
binary representations, but they return standard JavaScript numerical values.

The following table summarizes JavaScript's bitwise operators.

 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 Bitwise AND 
 `a & b` 
 Returns a one in each bit position for which the corresponding bits of both operands are ones. 
 
 
 Bitwise OR 
 `a | b` 
 Returns a zero in each bit position for which the corresponding bits of both operands are zeros. 
 
 
 Bitwise XOR 
 `a ^ b` 
 Returns a zero in each bit position for which the corresponding bits are the same. [Returns a one in each bit position for which the corresponding bits are different.] 
 
 
 Bitwise NOT 
 `~ a` 
 Inverts the bits of its operand. 
 
 
 Left shift 
 `a 
 Shifts `a` in binary representation `b` bits to the left, shifting in zeros from the right. 
 
 
 Sign-propagating right shift 
 `a >> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off. 
 
 
 Zero-fill right shift 
 `a >>> b` 
 Shifts `a` in binary representation `b` bits to the right, discarding bits shifted off, and shifting in zeros from the left. 
 
 
 
 
 

### Bitwise logical operators 

 
 

Conceptually, the bitwise logical operators work as follows:

- 

The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).
Numbers with more than 32 bits get their most significant bits discarded.
For example, the following integer with more than 32 bits will be converted to a 32-bit integer:



```
Before: 1110 0110 1111 1010 0000 0000 0000 0110 0000 0000 0001
After:                 1010 0000 0000 0000 0110 0000 0000 0001
```



- 

Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.

- 

The operator is applied to each pair of bits, and the result is constructed bitwise.

For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111.
So, when the bitwise operators are applied to these values, the results are as follows:

 
 
 
 Expression 
 Result 
 Binary Description 
 
 
 
 
 `15 & 9` 
 `9` 
 `1111 & 1001 = 1001` 
 
 
 `15 | 9` 
 `15` 
 `1111 | 1001 = 1111` 
 
 
 `15 ^ 9` 
 `6` 
 `1111 ^ 1001 = 0110` 
 
 
 `~15` 
 `-16` 
 `~ 0000 0000 … 0000 1111 = 1111 1111 … 1111 0000` 
 
 
 `~9` 
 `-10` 
 `~ 0000 0000 … 0000 1001 = 1111 1111 … 1111 0110` 
 
 
 

Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with
the most significant (left-most) bit set to 1 represent negative numbers
(two's-complement representation). `~x` evaluates to the same value that
`-x - 1` evaluates to.

 
 

### Bitwise shift operators 

 
 

The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be
shifted.
The direction of the shift operation is controlled by the operator used.

Shift operators convert their operands to thirty-two-bit integers and return a result of either type `Number` or `BigInt` : specifically, if the type
of the left operand is `BigInt` , they return `BigInt` ;
otherwise, they return `Number` .

The shift operators are listed in the following table.

 
 
 Bitwise shift operators
 
 
 
 Operator 
 Description 
 Example 
 
 
 
 
 
 Left shift 
(` 
 
 This operator shifts the first operand the specified number of bits to
 the left. Excess bits shifted off to the left are discarded. Zero bits
 are shifted in from the right.
 
 
 `9 
 
 
 
 Sign-propagating right shift (`>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Copies of
 the leftmost bit are shifted in from the left.
 
 
 `9>>2` yields 2, because 1001 shifted 2 bits to the right
 becomes 10, which is 2. Likewise, `-9>>2` yields -3, because the sign is preserved.
 
 
 
 
 Zero-fill right shift (`>>>`)
 
 
 This operator shifts the first operand the specified number of bits to
 the right. Excess bits shifted off to the right are discarded. Zero bits
 are shifted in from the left.
 
 
 `19>>>2` yields 4, because 10011 shifted 2 bits to the right
 becomes 100, which is 4. For non-negative numbers, zero-fill right shift
 and sign-propagating right shift yield the same result.
 
 
 
 
 
 

## Logical operators 

 
 

Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value.
However, the `&&`, `||`, and `??` operators actually return the value of one of the specified operands, so if these
operators are used with non-Boolean values, they may return a non-Boolean value. As such, they are more adequately called "value selection operators".
The logical operators are described in the following table.

 
 
 Logical operators
 
 
 
 Operator 
 Usage 
 Description 
 
 
 
 
 
 Logical AND (`&&`)
 
 `expr1 && expr2` 
 
 Returns `expr1` if it can be converted to `false`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `&&` returns `true` if both
 operands are true; otherwise, returns `false`.
 
 
 
 
 Logical OR (`||`)
 
 `expr1 || expr2` 
 
 Returns `expr1` if it can be converted to `true`;
 otherwise, returns `expr2`. Thus, when used with Boolean
 values, `||` returns `true` if either operand is
 true; if both are false, returns `false`.
 
 
 
 
 Nullish coalescing operator (`??`)
 
 `expr1 ?? expr2` 
 
 Returns `expr1` if it is neither `null` nor
 `undefined`; otherwise, returns `expr2`.
 
 
 
 
 Logical NOT (`!`)
 
 `!expr` 
 
 Returns `false` if its single operand can be converted
 to `true`; otherwise, returns `true`.
 
 
 
 

Examples of expressions that can be converted to `false` are those that evaluate to `null`, `0`, `0n`, `NaN`, the empty string (`""`), or `undefined`.

The following code shows examples of the `&&` (logical AND) operator.

 js 

```
const a1 = true && true; // t && t returns true
const a2 = true && false; // t && f returns false
const a3 = false && true; // f && t returns false
const a4 = false && 3 === 4; // f && f returns false
const a5 = "Cat" && "Dog"; // t && t returns Dog
const a6 = false && "Cat"; // f && t returns false
const a7 = "Cat" && false; // t && f returns false
```

 

The following code shows examples of the `||` (logical OR) operator.

 js 

```
const o1 = true || true; // t || t returns true
const o2 = false || true; // f || t returns true
const o3 = true || false; // t || f returns true
const o4 = false || 3 === 4; // f || f returns false
const o5 = "Cat" || "Dog"; // t || t returns Cat
const o6 = false || "Cat"; // f || t returns Cat
const o7 = "Cat" || false; // t || f returns Cat
```

 

The following code shows examples of the `??` (nullish coalescing) operator.

 js 

```
const n1 = null ?? 1; // 1
const n2 = undefined ?? 2; // 2
const n3 = false ?? 3; // false
const n4 = 0 ?? 4; // 0
```

 

Note how `??` works like `||`, but it only returns the second expression when the first one is " nullish ", i.e., `null` or `undefined` . `??` is a better alternative than `||` for setting defaults for values that might be `null` or `undefined`, in particular when values like `''` or `0` are valid values and the default should not apply.

The following code shows examples of the `!` (logical NOT) operator.

 js 

```
const n1 = !true; // !t returns false
const n2 = !false; // !f returns true
const n3 = !"Cat"; // !t returns false
```

 
 
 

### Short-circuit evaluation 

 
 

As logical expressions are evaluated left to right, they are tested for possible
"short-circuit" evaluation using the following rules:

- `falsy && anything` is short-circuit evaluated to the falsy value.

- `truthy || anything` is short-circuit evaluated to the truthy value.

- `nonNullish ?? anything` is short-circuit evaluated to the non-nullish value.

The rules of logic guarantee that these evaluations are always correct. Note that the
 anything part of the above expressions is not evaluated, so any side effects of
doing so do not take effect.

 
 

## BigInt operators 

 
 

Most operators that can be used between numbers can be used between `BigInt` values as well.

 js 

```
// BigInt addition
const a = 1n + 2n; // 3n
// Division with BigInts round towards zero
const b = 1n / 2n; // 0n
// Bitwise operations with BigInts do not truncate either side
const c = 40000000000000000n >> 2n; // 10000000000000000n
```

 

One exception is unsigned right shift (`>>>`) , which is not defined for BigInt values. This is because a BigInt does not have a fixed width, so technically it does not have a "highest bit".

 js 

```
const d = 8n >>> 2n; // TypeError: BigInts have no unsigned right shift, use >> instead
```

 

BigInts and numbers are not mutually replaceable — you cannot mix them in calculations.

 js 

```
const a = 1n + 2; // TypeError: Cannot mix BigInt and other types
```

 

This is because BigInt is neither a subset nor a superset of numbers. BigInts have higher precision than numbers when representing large integers, but cannot represent decimals, so implicit conversion on either side might lose precision. Use explicit conversion to signal whether you wish the operation to be a number operation or a BigInt one.

 js 

```
const a = Number(1n) + 2; // 3
const b = 1n + BigInt(2); // 3n
```

 

You can compare BigInts with numbers.

 js 

```
const a = 1n > 2; // false
const b = 3 > 2n; // true
```

 
 
 

## String operators 

 
 

In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings.

For example,

 js 

```
console.log("my " + "string"); // console logs the string "my string".
```

 

The shorthand assignment operator `+=` can also be used to concatenate strings.

For example,

 js 

```
let myString = "alpha";
myString += "bet"; // evaluates to "alphabet" and assigns this value to myString.
```

 
 
 

## Conditional (ternary) operator 

 
 

The conditional operator 
is the only JavaScript operator that takes three operands.
The operator can have one of two values based on a condition.
The syntax is:

 js 

```
condition ? val1 : val2
```

 

If `condition` is true, the operator has the value of `val1`.
Otherwise it has the value of `val2`. You can use the conditional operator anywhere you would use a standard operator.

For example,

 js 

```
const status = age >= 18 ? "adult" : "minor";
```

 

This statement assigns the value "adult" to the variable `status` if
`age` is eighteen or more. Otherwise, it assigns the value "minor" to
`status`.

 
 

## Comma operator 

 
 

The comma operator (`,`)
evaluates both of its operands and returns the value of the last operand.
This operator is primarily used inside a `for` loop, to allow multiple variables to be updated each time through the loop.
It is regarded bad style to use it elsewhere, when it is not necessary.
Often two separate statements can and should be used instead.

For example, if `a` is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to update two variables at once.
The code prints the values of the diagonal elements in the array:

 js 

```
const x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
const a = [x, x, x, x, x];

for (let i = 0, j = 9; i <= j; i++, j--) {
  //                              ^
  console.log(`a[${i}][${j}]= ${a[i][j]}`);
}
```

 
 
 

## Unary operators 

 
 

A unary operation is an operation with only one operand.

 
 

### delete 

 
 

The `delete` operator deletes an object's property.
The syntax is:

 js 

```
delete object.property;
delete object[propertyKey];
delete objectName[index];
```

 

where `object` is the name of an object, `property` is an existing property, and `propertyKey` is a string or symbol referring to an existing property.

If the `delete` operator succeeds, it removes the property from the object.
Trying to access it afterwards will yield `undefined`.
The `delete` operator returns `true` if the operation is possible; it returns `false` if the operation is not possible.

 js 

```
delete Math.PI; // returns false (cannot delete non-configurable properties)

const myObj = { h: 4 };
delete myObj.h; // returns true (can delete user-defined properties)
```

 

#### Deleting array elements

Since arrays are just objects, it's technically possible to `delete` elements from them.
This is, however, regarded as a bad practice — try to avoid it.
When you delete an array property, the array length is not affected and other elements are not re-indexed.
To achieve that behavior, it is much better to just overwrite the element with the value `undefined`.
To actually manipulate the array, use the various array methods such as `splice` .

 
 

### typeof 

 
 

The `typeof` operator returns a string indicating the type of the unevaluated operand.
`operand` is the string, variable, keyword, or object for which the type is to be returned.
The parentheses are optional.

Suppose you define the following variables:

 js 

```
const myFun = () => 5 + 2;
const shape = "round";
const size = 1;
const foo = ["Apple", "Mango", "Orange"];
const today = new Date();
```

 

The `typeof` operator returns the following results for these variables:

 js 

```
typeof myFun; // returns "function"
typeof shape; // returns "string"
typeof size; // returns "number"
typeof foo; // returns "object"
typeof today; // returns "object"
typeof doesntExist; // returns "undefined"
```

 

For the keywords `true` and `null`, the `typeof`
operator returns the following results:

 js 

```
typeof true; // returns "boolean"
typeof null; // returns "object"
```

 

For a number or string, the `typeof` operator returns the following results:

 js 

```
typeof 62; // returns "number"
typeof "Hello world"; // returns "string"
```

 

For property values, the `typeof` operator returns the type of value the
property contains:

 js 

```
typeof document.lastModified; // returns "string"
typeof window.length; // returns "number"
typeof Math.LN2; // returns "number"
```

 

For methods and functions, the `typeof` operator returns results as follows:

 js 

```
typeof blur; // returns "function"
typeof parseInt; // returns "function"
typeof shape.split; // returns "function"
```

 

For predefined objects, the `typeof` operator returns results as follows:

 js 

```
typeof Date; // returns "function"
typeof Function; // returns "function"
typeof Math; // returns "object"
typeof Option; // returns "function"
typeof String; // returns "function"
```

 
 
 

### void 

 
 

The `void` operator specifies an expression to be evaluated without returning a value. `expression` is a JavaScript expression to evaluate.
The parentheses surrounding the expression are optional, but it is good style to use them to avoid precedence issues.

 
 

## Relational operators 

 
 

A relational operator compares its operands and returns a Boolean value based on whether the comparison is true.

 
 

### in 

 
 

The `in` operator returns `true` if the specified property is in the specified object.
The syntax is:

 js 

```
propNameOrNumber in objectName
```

 

where `propNameOrNumber` is a string, numeric, or symbol expression representing a property name or array index, and `objectName` is the name of an object.

The following examples show some uses of the `in` operator.

 js 

```
// Arrays
const trees = ["redwood", "bay", "cedar", "oak", "maple"];
0 in trees; // returns true
3 in trees; // returns true
6 in trees; // returns false
"bay" in trees; // returns false
// (you must specify the index number, not the value at that index)
"length" in trees; // returns true (length is an Array property)

// built-in objects
"PI" in Math; // returns true
const myString = new String("coral");
"length" in myString; // returns true

// Custom objects
const myCar = { make: "Honda", model: "Accord", year: 1998 };
"make" in myCar; // returns true
"model" in myCar; // returns true
```

 
 
 

### instanceof 

 
 

The `instanceof` operator returns `true`
if the specified object is of the specified object type. The syntax is:

 js 

```
object instanceof objectType
```

 

where `object` is the object to test against `objectType`, and `objectType` is a constructor representing a type, such as `Map` or `Array` .

Use `instanceof` when you need to confirm the type of an object at runtime.
For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.

For example, the following code uses `instanceof` to determine whether `obj` is a `Map` object. Because `obj` is a `Map` object, the statements inside the `if` block execute.

 js 

```
const obj = new Map();
if (obj instanceof Map) {
  // statements to execute
}
```

 
 
 

## Basic expressions 

 
 

All operators eventually operate on one or more basic expressions. These basic expressions include identifiers and literals , but there are a few other kinds as well. They are briefly introduced below, and their semantics are described in detail in their respective reference sections.

 
 

### this 

 
 

The `this` keyword is usually used within a function. In general, when the function is attached to an object as a method, `this` refers to the object that the method is called on. It functions like a hidden parameter that is passed to the function. `this` is an expression that evaluates to the object, so you can use all the object operations we introduced.

 js 

```
this["propertyName"];
this.propertyName;
doSomething(this);
```

 

For example, suppose a function is defined as follows:

 js 

```
function getFullName() {
  return `${this.firstName} ${this.lastName}`;
}
```

 

We can now attach this function to an object, and it will use the properties of that object when called:

 js 

```
const person1 = {
  firstName: "Chris",
  lastName: "Martin",
};

const person2 = {
  firstName: "Chester",
  lastName: "Bennington",
};

// Attach the same function
person1.getFullName = getFullName;
person2.getFullName = getFullName;

console.log(person1.getFullName()); // "Chris Martin"
console.log(person2.getFullName()); // "Chester Bennington"
```

 
 
 

### Grouping operator 

 
 

The grouping operator `( )` controls the precedence of evaluation in
expressions. For example, you can override multiplication and division first, then
addition and subtraction to evaluate addition first.

 js 

```
const a = 1;
const b = 2;
const c = 3;

// default precedence
a + b * c; // 7
// evaluated by default like this
a + (b * c); // 7

// now overriding precedence
// addition before multiplication
(a + b) * c; // 9

// which is equivalent to
a * c + b * c; // 9
```

 
 
 

### Property accessor 

 
 

The property accessor syntax gets property values on objects, using either dot notation or bracket notation.

 js 

```
object.property;
object["property"];
```

 

The working with objects guide goes into more details about object properties.

 
 

### Optional chaining 

 
 

The optional chaining syntax (`?.`) performs the chained operation on an object if it is defined and non-`null`, and otherwise short-circuits the operation and returns `undefined`.
This allows you to operate on a value that may be `null` or `undefined` without causing a `TypeError`.

 js 

```
maybeObject?.property;
maybeObject?.[property];
maybeFunction?.();
```

 
 
 

### new 

 
 

You can use the `new` operator to create an instance of a user-defined object type or of one of the built-in object types. Use `new` as follows:

 js 

```
const objectName = new ObjectType(param1, param2, /* …, */ paramN);
```

 
 
 

### super 

 
 

The `super` keyword is used to call functions on an object's parent.
It is useful with classes to call the parent constructor, for example.

 js 

```
super(args); // calls the parent constructor.
super.functionOnParent(args);
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#while_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#labeled_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#break_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#continue_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...in_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#content

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#search

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#defining_functions

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#calling_functions

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#function_scopes_and_closures

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#using_the_arguments_object

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#function_parameters

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Functions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#arrow_functions

Functions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Functions

 
 
 
- Previous 
- Next 

Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it.

See also the exhaustive reference chapter about JavaScript functions to get to know the details.

 
 
 
 
 
 

## Defining functions 

 
 
 
 

### Function declarations 

 
 

A function definition (also called a function declaration , or function statement ) consists of the `function` keyword, followed by:

- The name of the function.

- A list of parameters to the function, enclosed in parentheses and separated by commas.

- The JavaScript statements that define the function, enclosed in curly braces, `{ /* … */ }`.

For example, the following code defines a function named `square`:

 js 

```
function square(number) {
  return number * number;
}
```

 

The function `square` takes one parameter, called `number`. The function consists of one statement that says to return the parameter of the function (that is, `number`) multiplied by itself. The `return` statement specifies the value returned by the function, which is `number * number`.

Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function .

When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theObject) {
  theObject.make = "Toyota";
}

const myCar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(myCar.make); // "Honda"
myFunc(myCar);
console.log(myCar.make); // "Toyota"
```

 

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

 js 

```
function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
```

 

Function declarations and expressions can be nested, which forms a scope chain . For example:

 js 

```
function addSquares(a, b) {
  function square(x) {
    return x * x;
  }
  return square(a) + square(b);
}
```

 

See function scopes and closures for more information.

 
 

### Function expressions 

 
 

While the function declaration above is syntactically a statement, functions can also be created by a function expression .

Such a function can be anonymous ; it does not have to have a name. For example, the function `square` could have been defined as:

 js 

```
const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16
```

 

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

 js 

```
const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6
```

 

Function expressions are convenient when passing a function as an argument to another function. The following example defines a `map` function that should receive a function as first argument and an array as second argument. Then, it is called with a function defined by a function expression:

 js 

```
function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const numbers = [0, 1, 2, 5, 10];
const cubedNumbers = map(function (x) {
  return x * x * x;
}, numbers);
console.log(cubedNumbers); // [0, 1, 8, 125, 1000]
```

 

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines `myFunc` only if `num` equals `0`:

 js 

```
let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}
```

 

In addition to defining functions as described here, you can also use the `Function` constructor to create functions from a string at runtime, much like `eval()` .

A method is a function that is a property of an object. Read more about objects and methods in Working with objects .

 
 

## Calling functions 

 
 

 Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called.

 Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function `square`, you could call it as follows:

 js 

```
square(5);
```

 

The preceding statement calls the function with an argument of `5`. The function executes its statements and returns the value `25`.

Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).

The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The `showProps()` function (defined in Working with objects ) is an example of a function that takes an object as an argument.

A function can call itself. For example, here is a function that computes factorials recursively:

 js 

```
function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  }
  return n * factorial(n - 1);
}
```

 

You could then compute the factorials of `1` through `5` as follows:

 js 

```
console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120
```

 

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime.

It turns out that functions are themselves objects — and in turn, these objects have methods. (See the `Function` object.) The `call()` and `apply()` methods can be used to achieve this goal.

 
 

### Function hoisting 

 
 

Consider the example below:

 js 

```
console.log(square(5)); // 25

function square(n) {
  return n * n;
}
```

 

This code runs without any error, despite the `square()` function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the current scope, so the code above is equivalent to:

 js 

```
// All function declarations are effectively at the top of the scope
function square(n) {
  return n * n;
}

console.log(square(5)); // 25
```

 

Function hoisting only works with function declarations — not with function expressions . The following code will not work:

 js 

```
console.log(square(5)); // ReferenceError: Cannot access 'square' before initialization
const square = function (n) {
  return n * n;
};
```

 
 
 

### Recursion 

 
 

A function can refer to and call itself. It can be referred to either by the function expression or declaration's name, or via any in-scope variable that refers to the function object. For example, consider the following function definition:

 js 

```
const foo = function bar() {
  // statements go here
};
```

 

Within the function body, you can refer to the function itself either as `bar` or `foo`, and call itself using `bar()` or `foo()`.

A function that calls itself is called a recursive function . In some ways, recursion is analogous to a loop. Both execute the same code multiple times, and both require a condition (to avoid an infinite loop, or rather, infinite recursion in this case).

For example, consider the following loop:

 js 

```
let x = 0;
// "x < 10" is the loop condition
while (x < 10) {
  // do stuff
  x++;
}
```

 

It can be converted into a recursive function declaration, followed by a call to that function:

 js 

```
function loop(x) {
  // "x >= 10" is the exit condition (equivalent to "!(x < 10)")
  if (x >= 10) {
    return;
  }
  // do stuff
  loop(x + 1); // the recursive call
}
loop(0);
```

 

However, some algorithms cannot be simple iterative loops. For example, getting all the nodes of a tree structure (such as the DOM ) is easier via recursion:

 js 

```
function walkTree(node) {
  if (node === null) {
    return;
  }
  // do something with node
  for (const child of node.childNodes) {
    walkTree(child);
  }
}
```

 

Compared to the function `loop`, each recursive call itself makes many recursive calls here.

It is possible to convert any recursive algorithm to a non-recursive one, but the logic is often much more complex, and doing so requires the use of a stack.

In fact, recursion itself uses a stack: the function stack. The stack-like behavior can be seen in the following example:

 js 

```
function foo(i) {
  if (i < 0) {
    return;
  }
  console.log(`begin: ${i}`);
  foo(i - 1);
  console.log(`end: ${i}`);
}
foo(3);

// Logs:
// begin: 3
// begin: 2
// begin: 1
// begin: 0
// end: 0
// end: 1
// end: 2
// end: 3
```

 
 
 

### Immediately Invoked Function Expressions (IIFE) 

 
 

An Immediately Invoked Function Expression (IIFE) is a code pattern that directly calls a function defined as an expression. It looks like this:

 js 

```
(function () {
  // Do something
})();

const value = (function () {
  // Do something
  return someValue;
})();
```

 

Instead of saving the function in a variable, the function is immediately invoked. This is almost equivalent to just writing the function body, but there are a few unique benefits:

- It creates an extra scope of variables, which helps to confine variables to the place where they are useful.

- It is now an expression instead of a sequence of statements . This allows you to write complex computation logic when initializing variables.

For more information, see the IIFE glossary entry.

 
 

## Function scopes and closures 

 
 

Functions form a scope for variables—this means variables defined inside a function cannot be accessed from anywhere outside the function. The function scope inherits from all the upper scopes. For example, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function, and any other variables to which the parent function has access. On the other hand, the parent function (and any other parent scope) does not have access to the variables and functions defined inside the inner function. This provides a sort of encapsulation for the variables in the inner function.

 js 

```
// The following variables are defined in the global scope
const num1 = 20;
const num2 = 3;
const name = "Chamakh";

// This function is defined in the global scope
function multiply() {
  return num1 * num2;
}

console.log(multiply()); // 60

// A nested function example
function getScore() {
  const num1 = 2;
  const num2 = 3;

  function add() {
    return `${name} scored ${num1 + num2}`;
  }

  return add();
}

console.log(getScore()); // "Chamakh scored 5"
```

 
 
 

### Closures 

 
 

We also refer to the function body as a closure . A closure is any piece of source code (most commonly, a function) that refers to some variables, and the closure "remembers" these variables even when the scope in which these variables were declared has exited.

Closures are usually illustrated with nested functions to show that they remember variables beyond the lifetime of its parent scope; but in fact, nested functions are unnecessary. Technically speaking, all functions in JavaScript form closures—some just don't capture anything, and closures don't even have to be functions. The key ingredients for a useful closure are the following:

- A parent scope that defines some variables or functions. It should have a clear lifetime, which means it should finish execution at some point. Any scope that's not the global scope satisfies this requirement; this includes blocks, functions, modules, and more.

- An inner scope defined within the parent scope, which refers to some variables or functions defined in the parent scope.

- The inner scope manages to survive beyond the lifetime of the parent scope. For example, it is saved to a variable that's defined outside the parent scope, or it's returned from the parent scope (if the parent scope is a function).

- Then, when you call the function outside of the parent scope, you can still access the variables or functions that were defined in the parent scope, even though the parent scope has finished execution.

The following is a typical example of a closure:

 js 

```
// The outer function defines a variable called "name"
const pet = function (name) {
  const getName = function () {
    // The inner function has access to the "name" variable of the outer function
    return name;
  };
  return getName; // Return the inner function, thereby exposing it to outer scopes
};
const myPet = pet("Vivie");

console.log(myPet()); // "Vivie"
```

 

It can be much more complex than the code above. An object containing methods for manipulating the inner variables of the outer function can be returned.

 js 

```
const createPet = function (name) {
  let sex;

  const pet = {
    // setName(newName) is equivalent to setName: function (newName)
    // in this context
    setName(newName) {
      name = newName;
    },

    getName() {
      return name;
    },

    getSex() {
      return sex;
    },

    setSex(newSex) {
      if (
        typeof newSex === "string" &&
        (newSex.toLowerCase() === "male" || newSex.toLowerCase() === "female")
      ) {
        sex = newSex;
      }
    },
  };

  return pet;
};

const pet = createPet("Vivie");
console.log(pet.getName()); // Vivie

pet.setName("Oliver");
pet.setSex("male");
console.log(pet.getSex()); // male
console.log(pet.getName()); // Oliver
```

 

In the code above, the `name` variable of the outer function is accessible to the inner functions, and there is no other way to access the inner variables except through the inner functions. The inner variables of the inner functions act as safe stores for the outer arguments and variables. They hold "persistent" and "encapsulated" data for the inner functions to work with. The functions do not even have to be assigned to a variable, or have a name.

 js 

```
const getCode = (function () {
  const apiCode = "0]Eal(eh&2"; // A code we do not want outsiders to be able to modify…

  return function () {
    return apiCode;
  };
})();

console.log(getCode()); // "0]Eal(eh&2"
```

 

In the code above, we use the IIFE pattern. Within this IIFE scope, two values exist: a variable `apiCode` and an unnamed function that gets returned and gets assigned to the variable `getCode`. `apiCode` is in the scope of the returned unnamed function but not in the scope of any other part of the program, so there is no way for reading the value of `apiCode` apart from via the `getCode` function.

 
 

### Multiply-nested functions 

 
 

Functions can be multiply-nested. For example:

- A function (`A`) contains a function (`B`), which itself contains a function (`C`).

- Both functions `B` and `C` form closures here. So, `B` can access `A`, and `C` can access `B`.

- In addition, since `C` can access `B` which can access `A`, `C` can also access `A`.

Thus, the closures can contain multiple scopes; they recursively contain the scope of the functions containing it. This is called scope chaining . Consider the following example:

 js 

```
function A(x) {
  function B(y) {
    function C(z) {
      console.log(x + y + z);
    }
    C(3);
  }
  B(2);
}
A(1); // Logs 6 (which is 1 + 2 + 3)
```

 

In this example, `C` accesses `B`'s `y` and `A`'s `x`. This can be done because:

- `B` forms a closure including `A` (i.e., `B` can access `A`'s arguments and variables).

- `C` forms a closure including `B`.

- Because `C`'s closure includes `B` and `B`'s closure includes `A`, then `C`'s closure also includes `A`. This means `C` can access both `B` and `A`'s arguments and variables. In other words, `C` chains the scopes of `B` and `A`, in that order .

The reverse, however, is not true. `A` cannot access `C`, because `A` cannot access any argument or variable of `B`, which `C` is a variable of. Thus, `C` remains private to only `B`.

 
 

### Name conflicts 

 
 

When two arguments or variables in the scopes of a closure have the same name, there is a name conflict . More nested scopes take precedence. So, the innermost scope takes the highest precedence, while the outermost scope takes the lowest. This is the scope chain. The first on the chain is the innermost scope, and the last is the outermost scope. Consider the following:

 js 

```
function outside() {
  const x = 5;
  function inside(x) {
    return x * 2;
  }
  return inside;
}

console.log(outside()(10)); // 20 (instead of 10)
```

 

The name conflict happens at the statement `return x * 2` and is between `inside`'s parameter `x` and `outside`'s variable `x`. The scope chain here is `inside` => `outside` => global object. Therefore, `inside`'s `x` takes precedences over `outside`'s `x`, and `20` (`inside`'s `x`) is returned instead of `10` (`outside`'s `x`).

 
 

## Using the arguments object 

 
 

The arguments of a function are maintained in an array-like object. Within a function, you can address the arguments passed to it as follows:

 js 

```
arguments[i];
```

 

where `i` is the ordinal number of the argument, starting at `0`. So, the first argument passed to a function would be `arguments[0]`. The total number of arguments is indicated by `arguments.length`.

Using the `arguments` object, you can call a function with more arguments than it is formally declared to accept. This is often useful if you don't know in advance how many arguments will be passed to the function. You can use `arguments.length` to determine the number of arguments actually passed to the function, and then access each argument using the `arguments` object.

For example, consider a function that concatenates several strings. The only formal argument for the function is a string that specifies the characters that separate the items to concatenate. The function is defined as follows:

 js 

```
function myConcat(separator) {
  let result = ""; // initialize list
  // iterate through arguments
  for (let i = 1; i < arguments.length; i++) {
    result += arguments[i] + separator;
  }
  return result;
}
```

 

You can pass any number of arguments to this function, and it concatenates each argument into a string "list":

 js 

```
console.log(myConcat(", ", "red", "orange", "blue"));
// "red, orange, blue, "

console.log(myConcat("; ", "elephant", "giraffe", "lion", "cheetah"));
// "elephant; giraffe; lion; cheetah; "

console.log(myConcat(". ", "sage", "basil", "oregano", "pepper", "parsley"));
// "sage. basil. oregano. pepper. parsley. "
```

 
 

 Note: 
The `arguments` variable is "array-like", but not an array. It is array-like in that it has a numbered index and a `length` property. However, it does not possess all of the array-manipulation methods.

 

See the `Function` object in the JavaScript reference for more information.

 
 

## Function parameters 

 
 

There are two special kinds of parameter syntax: default parameters and rest parameters .

 
 

### Default parameters 

 
 

In JavaScript, parameters of functions default to `undefined`. However, in some situations it might be useful to set a different default value. This is exactly what default parameters do.

In the past, the general strategy for setting defaults was to test parameter values in the body of the function and assign a value if they are `undefined`.

In the following example, if no value is provided for `b`, its value would be `undefined` when evaluating `a*b`, and a call to `multiply` would normally have returned `NaN`. However, this is prevented by the second line in this example:

 js 

```
function multiply(a, b) {
  b = typeof b !== "undefined" ? b : 1;
  return a * b;
}

console.log(multiply(5)); // 5
```

 

With default parameters , a manual check in the function body is no longer necessary. You can put `1` as the default value for `b` in the function head:

 js 

```
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5)); // 5
```

 

For more details, see default parameters in the reference.

 
 

### Rest parameters 

 
 

The rest parameter syntax allows us to represent an indefinite number of arguments as an array.

In the following example, the function `multiply` uses rest parameters to collect arguments from the second one to the end. The function then multiplies these by the first argument.

 js 

```
function multiply(multiplier, ...theArgs) {
  return theArgs.map((x) => multiplier * x);
}

const arr = multiply(2, 1, 2, 3);
console.log(arr); // [2, 4, 6]
```

 
 
 

## Arrow functions 

 
 

An arrow function expression (also called a fat arrow to distinguish from a hypothetical `->` syntax in future JavaScript) has a shorter syntax compared to function expressions and does not have its own `this` , `arguments` , `super` , or `new.target` . Arrow functions are always anonymous.

Two factors influenced the introduction of arrow functions: shorter functions and non-binding of `this`.

 
 

### Shorter functions 

 
 

In some functional patterns, shorter functions are welcome. Compare:

 js 

```
const a = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

const a2 = a.map(function (s) {
  return s.length;
});

console.log(a2); // [8, 6, 7, 9]

const a3 = a.map((s) => s.length);

console.log(a3); // [8, 6, 7, 9]
```

 
 
 

### No separate this 

 
 

Until arrow functions, every new function defined its own `this` value (a new object in the case of a constructor, undefined in strict mode function calls, the base object if the function is called as an "object method", etc.). This proved to be less than ideal with an object-oriented style of programming.

 js 

```
function Person() {
  // The Person() constructor defines `this` as itself.
  this.age = 0;

  setInterval(function growUp() {
    // In nonstrict mode, the growUp() function defines `this`
    // as the global object, which is different from the `this`
    // defined by the Person() constructor.
    this.age++;
  }, 1000);
}

const p = new Person();
```

 

In ECMAScript 3/5, this issue was fixed by assigning the value in `this` to a variable that could be closed over.

 js 

```
function Person() {
  // Some choose `that` instead of `self`.
  // Choose one and be consistent.
  const self = this;
  self.age = 0;

  setInterval(function growUp() {
    // The callback refers to the `self` variable of which
    // the value is the expected object.
    self.age++;
  }, 1000);
}
```

 

Alternatively, a bound function could be created so that the proper `this` value would be passed to the `growUp()` function.

An arrow function does not have its own `this`; the `this` value of the enclosing execution context is used. Thus, in the following code, the `this` within the function that is passed to `setInterval` has the same value as `this` in the enclosing function:

 js 

```
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // `this` properly refers to the person object
  }, 1000);
}

const p = new Person();
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Loops and iteration - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration#for...of_statement

Loops and iteration - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Loops and iteration

 
 
 
- Previous 
- Next 

Loops offer a quick and easy way to do something repeatedly. This
chapter of the JavaScript Guide 
introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to
take X steps in one direction, then Y steps in another. For example,
the idea "Go five steps to the east" could be expressed this way as a loop:

 js 

```
for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}
```

 

There are many different kinds of loops, but they all essentially do the same thing:
they repeat an action some number of times. (Note that it's possible that number could
be zero!)

The various loop mechanisms offer different ways to determine the start and end points
of the loop. There are various situations that are more easily served by one type of
loop over the others.

The statements for loops provided in JavaScript are:

- for statement 

- do...while statement 

- while statement 

- labeled statement 

- break statement 

- continue statement 

- for...in statement 

- for...of statement 

 
 
 
 
 
 

## for statement 

 
 

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

 js 

```
for (initialization; condition; afterthought)
  statement
```

 

When a `for` loop executes, the following occurs:

- The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.

- The `condition` expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the `condition` expression is omitted entirely, the condition is assumed to be true.)

- The `statement` executes. To execute multiple statements, use a block statement (`{ }`) to group those statements.

- If present, the update expression `afterthought` is executed.

- Control returns to Step 2.

 
 

### Example 

 
 

In the example below, the function contains a `for` statement that counts
the number of selected options in a scrolling list (a ` ` 
element that allows multiple selections).

#### HTML

 html 

```
<form name="selectForm">
  <label for="musicTypes"
    >Choose some music types, then click the button below:</label
  >
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>
```

 

#### JavaScript

Here, the `for` statement declares the variable `i` and initializes it to `0`. It checks that `i` is less than the number of options in the ` ` element, performs the succeeding `if` statement, and increments `i` by 1 after each pass through the loop.

 js 

```
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
```

 
 
 

## do...while statement 

 
 

The `do...while` statement repeats until a
specified condition evaluates to false.

A `do...while` statement looks as follows:

 js 

```
do
  statement
while (condition);
```

 

`statement` is always executed once before the condition is
checked. (To execute multiple statements, use a block statement (`{ }`)
to group those statements.)

If `condition` is `true`, the statement executes again. At the
end of every execution, the condition is checked. When the condition is
`false`, execution stops, and control passes to the statement following
`do...while`.

 
 

### Example 

 
 

In the following example, the `do` loop iterates at least once and
reiterates until `i` is no longer less than `5`.

 js 

```
let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);
```

 
 
 

## while statement 

 
 

A `while` statement executes its statements as long as a
specified condition evaluates to `true`. A `while` statement looks
as follows:

 js 

```
while (condition)
  statement
```

 

If the `condition` becomes `false`,
`statement` within the loop stops executing and control passes to the
statement following the loop.

The condition test occurs before `statement` in the loop is
executed. If the condition returns `true`, `statement` is executed
and the `condition` is tested again. If the condition returns
`false`, execution stops, and control is passed to the statement following
`while`.

To execute multiple statements, use a block statement (`{ }`) to group
those statements.

 
 

### Example 1 

 
 

The following `while` loop iterates as long as `n` is
less than `3`:

 js 

```
let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}
```

 

With each iteration, the loop increments `n` and adds that value to
`x`. Therefore, `x` and `n` take on the following
values:

- After the first pass: `n` = `1` and `x` =
`1`

- After the second pass: `n` = `2` and `x` =
`3`

- After the third pass: `n` = `3` and `x` =
`6`

After completing the third pass, the condition `n 
 

### Example 2 

 
 

Avoid infinite loops. Make sure the condition in a loop eventually becomes
`false`—otherwise, the loop will never terminate! The statements in the
following `while` loop execute forever because the condition never becomes
`false`:

 js 

```
// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}
```

 
 
 

## labeled statement 

 
 

A `label` provides a statement with an identifier that
lets you refer to it elsewhere in your program. For example, you can use a label to
identify a loop, and then use the `break` or `continue` statements
to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

 js 

```
label:
  statement
```

 

The value of `label` may be any JavaScript identifier that is not a
reserved word. The `statement` that you identify with a label may be
any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

 
 

## break statement 

 
 

Use the `break` statement to terminate a loop,
`switch`, or in conjunction with a labeled statement.

- When you use `break` without a label, it terminates the innermost
enclosing `while`, `do-while`, `for`, or
`switch` immediately and transfers control to the following statement.

- When you use `break` with a label, it terminates the specified labeled
statement.

The syntax of the `break` statement looks like this:

 js 

```
break;
break label;
```

 

- The first form of the syntax terminates the innermost enclosing loop or `switch`.

- The second form of the syntax terminates the specified enclosing labeled statement.

 
 

### Example 1 

 
 

The following example iterates through the elements in an array until it finds the
index of an element whose value is `theValue`:

 js 

```
for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}
```

 
 
 

### Example 2: Breaking to a label 

 
 js 

```
let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

 
 
 

## continue statement 

 
 

The `continue` statement can be used to restart a
`while`, `do-while`, `for`, or `label`
statement.

- When you use `continue` without a label, it terminates the current
iteration of the innermost enclosing `while`, `do-while`, or
`for` statement and continues execution of the loop with the next
iteration. In contrast to the `break` statement, `continue` does
not terminate the execution of the loop entirely. In a `while` loop, it
jumps back to the condition. In a `for` loop, it jumps to the
`increment-expression`.

- When you use `continue` with a label, it applies to the looping statement
identified with that label.

The syntax of the `continue` statement looks like the following:

 js 

```
continue;
continue label;
```

 
 
 

### Example 1 

 
 

The following example shows a `while` loop with a `continue`
statement that executes when the value of `i` is `3`. Thus,
`n` takes on the values `1`, `3`, `7`, and
`12`.

 js 

```
let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12
```

 

If you comment out the `continue;`, the loop would run till the end and you would see `1,3,6,10,15`.

 
 

### Example 2 

 
 

A statement labeled `checkIandJ` contains a statement labeled
`checkJ`. If `continue` is encountered, the program
terminates the current iteration of `checkJ` and begins the next
iteration. Each time `continue` is encountered, `checkJ`
reiterates until its condition returns `false`. When `false` is
returned, the remainder of the `checkIandJ` statement is completed,
and `checkIandJ` reiterates until its condition returns
`false`. When `false` is returned, the program continues at the
statement following `checkIandJ`.

If `continue` had a label of `checkIandJ`, the program
would continue at the top of the `checkIandJ` statement.

 js 

```
let i = 0;
let j = 10;
checkIandJ: while (i < 4) {
  console.log(i);
  i += 1;
  checkJ: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

 
 
 

## for...in statement 

 
 

The `for...in` statement iterates a specified
variable over all the enumerable properties of an object. For each distinct property,
JavaScript executes the specified statements. A `for...in` statement looks as
follows:

 js 

```
for (variable in object)
  statement
```

 
 
 

### Example 

 
 

The following function takes as its argument an object and the object's name. It then
iterates over all the object's properties and returns a string that lists the property
names and their values.

 js 

```
function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}
```

 

For an object `car` with properties `make` and `model`, `result` would be:



```
car.make = Ford
car.model = Mustang
```


 
 

### Arrays 

 
 

Although it may be tempting to use this as a way to iterate over `Array` 
elements, the `for...in` statement will return the name of your user-defined
properties in addition to the numeric indexes.

Therefore, it is better to use a traditional `for` loop
with a numeric index when iterating over arrays, because the `for...in`
statement iterates over user-defined properties in addition to the array elements, if
you modify the Array object (such as adding custom properties or methods).

 
 

## for...of statement 

 
 

The `for...of` statement creates a loop Iterating
over iterable objects (including
 `Array` , `Map` , `Set` ,
 `arguments` object and so on), invoking a custom
iteration hook with statements to be executed for the value of each distinct property.

 js 

```
for (variable of iterable)
  statement
```

 

The following example shows the difference between a `for...of` loop and a
 `for...in` loop. While `for...in` iterates
over property names, `for...of` iterates over property values:

 js 

```
const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7
```

 

The `for...of` and `for...in` statements can also be used with destructuring . For example, you can simultaneously loop over the keys and values of an object using `Object.entries()` .

 js 

```
const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Nov 3, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### for - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for

for - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# for

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `for` statement creates a loop that consists of three optional expressions, enclosed in parentheses and separated by semicolons, followed by a statement (usually a block statement ) to be executed in the loop.

 
 
 
 
 
 

## Try it 

 
 
 

```
let str = "";

for (let i = 0; i < 9; i++) {
  str += i;
}

console.log(str);
// Expected output: "012345678"
```

 
 
 

## Syntax 

 
 js 

```
for (initialization; condition; afterthought)
  statement
```

 
 
 `initialization` Optional 
 

An expression (including assignment expressions ) or variable declaration evaluated once before the loop begins. Typically used to initialize a counter variable. This expression may optionally declare new variables with `var` or `let` keywords. Variables declared with `var` are not local to the loop, i.e., they are in the same scope the `for` loop is in. Variables declared with `let` are local to the statement.

The result of this expression is discarded.

 
 `condition` Optional 
 

An expression to be evaluated before each loop iteration. If this expression evaluates to true , `statement` is executed. If the expression evaluates to false , execution exits the loop and goes to the first statement after the `for` construct.

This conditional test is optional. If omitted, the condition always evaluates to true.

 
 `afterthought` Optional 
 

An expression to be evaluated at the end of each loop iteration. This occurs before the next evaluation of `condition`. Generally used to update or increment the counter variable.

 
 `statement` 
 

A statement that is executed as long as the condition evaluates to true. You can use a block statement to execute multiple statements. To execute no statement within the loop, use an empty statement (`;`).

 
 
 
 

## Description 

 
 

Like other looping statements, you can use control flow statements inside `statement`:

- `break` stops `statement` execution and goes to the first statement after the loop.

- `continue` stops `statement` execution and re-evaluates `afterthought` then `condition`.

 
 

## Examples 

 
 
 
 

### Using for 

 
 

The following `for` statement starts by declaring the variable `i` and initializing it to `0`. It checks that `i` is less than nine, performs the two succeeding statements, and increments `i` by 1 after each pass through the loop.

 js 

```
for (let i = 0; i < 9; i++) {
  console.log(i);
  // more statements
}
```

 
 
 

### Initialization block syntax 

 
 

The initialization block accepts both expressions and variable declarations. However, expressions cannot use the `in` operator unparenthesized, because that is ambiguous with a `for...in` loop.

 js 

```
for (let i = "start" in window ? window.start : 0; i < 9; i++) {
  console.log(i);
}
// SyntaxError: 'for-in' loop variable declaration may not have an initializer.
```

 
 js 

```
// Parenthesize the whole initializer
for (let i = ("start" in window ? window.start : 0); i < 9; i++) {
  console.log(i);
}

// Parenthesize the `in` expression
for (let i = ("start" in window) ? window.start : 0; i < 9; i++) {
  console.log(i);
}
```

 
 
 

### Optional for expressions 

 
 

All three expressions in the head of the `for` loop are optional. For example, it is not required to use the `initialization` block to initialize variables:

 js 

```
let i = 0;
for (; i < 9; i++) {
  console.log(i);
  // more statements
}
```

 

Like the `initialization` block, the `condition` part is also optional. If you are omitting this expression, you must make sure to break the loop in the body in order to not create an infinite loop.

 js 

```
for (let i = 0; ; i++) {
  console.log(i);
  if (i > 3) break;
  // more statements
}
```

 

You can also omit all three expressions. Again, make sure to use a `break` statement to end the loop and also modify (increase) a variable, so that the condition for the break statement is true at some point.

 js 

```
let i = 0;

for (;;) {
  if (i > 3) break;
  console.log(i);
  i++;
}
```

 

However, in the case where you are not fully using all three expression positions — especially if you are not declaring variables with the first expression but mutating something in the upper scope — consider using a `while` loop instead, which makes the intention clearer.

 js 

```
let i = 0;

while (i <= 3) {
  console.log(i);
  i++;
}
```

 
 
 

### Lexical declarations in the initialization block 

 
 

Declaring a variable within the initialization block has important differences from declaring it in the upper scope , especially when creating a closure within the loop body. For example, for the code below:

 js 

```
for (let i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

 

It logs `0`, `1`, and `2`, as expected. However, if the variable is defined in the upper scope:

 js 

```
let i = 0;
for (; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
```

 

It logs `3`, `3`, and `3`. The reason is that each `setTimeout` creates a new closure that closes over the `i` variable, but if the `i` is not scoped to the loop body, all closures will reference the same variable when they eventually get called — and due to the asynchronous nature of `setTimeout()` , it will happen after the loop has already exited, causing the value of `i` in all queued callbacks' bodies to have the value of `3`.

This also happens if you use a `var` statement as the initialization, because variables declared with `var` are only function-scoped, but not lexically scoped (i.e., they can't be scoped to the loop body).

 js 

```
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
// Logs 3, 3, 3
```

 

The scoping effect of the initialization block can be understood as if the declaration happens within the loop body, but just happens to be accessible within the `condition` and `afterthought` parts. More precisely, `let` declarations are special-cased by `for` loops — if `initialization` is a `let` declaration, then every time, after the loop body is evaluated, the following happens:

- A new lexical scope is created with new `let`-declared variables.

- The binding values from the last iteration are used to re-initialize the new variables.

- `afterthought` is evaluated in the new scope.

So re-assigning the new variables within `afterthought` does not affect the bindings from the previous iteration.

A new lexical scope is also created after `initialization`, just before `condition` is evaluated for the first time. These details can be observed by creating closures, which allow to get hold of a binding at any particular point. For example, in this code a closure created within the `initialization` section does not get updated by re-assignments of `i` in the `afterthought`:

 js 

```
for (let i = 0, getI = () => i; i < 3; i++) {
  console.log(getI());
}
// Logs 0, 0, 0
```

 

This does not log "0, 1, 2", like what would happen if `getI` is declared in the loop body. This is because `getI` is not re-evaluated on each iteration — rather, the function is created once and closes over the `i` variable, which refers to the variable declared when the loop was first initialized. Subsequent updates to the value of `i` actually create new variables called `i`, which `getI` does not see. A way to fix this is to re-compute `getI` every time `i` updates:

 js 

```
for (let i = 0, getI = () => i; i < 3; i++, getI = () => i) {
  console.log(getI());
}
// Logs 0, 1, 2
```

 

The `i` variable inside the `initialization` is distinct from the `i` variable inside every iteration, including the first. So, in this example, `getI` returns 0, even though the value of `i` inside the iteration is incremented beforehand:

 js 

```
for (let i = 0, getI = () => i; i < 3; ) {
  i++;
  console.log(getI());
}
// Logs 0, 0, 0
```

 

In fact, you can capture this initial binding of the `i` variable and re-assign it later, and this updated value will not be visible to the loop body, which sees the next new binding of `i`.

 js 

```
for (
  let i = 0, getI = () => i, incrementI = () => i++;
  getI() < 3;
  incrementI()
) {
  console.log(i);
}
// Logs 0, 0, 0
```

 

This logs "0, 0, 0", because the `i` variable in each loop evaluation is actually a separate variable, but `getI` and `incrementI` both read and write the initial binding of `i`, not what was subsequently declared.

 
 

### Using for without a body 

 
 

The following `for` cycle calculates the offset position of a node in the `afterthought` section, and therefore it does not require the use of a `statement` section, a semicolon is used instead.

 js 

```
function showOffsetPos(id) {
  let left = 0;
  let top = 0;
  for (
    let itNode = document.getElementById(id); // initialization
    itNode; // condition
    left += itNode.offsetLeft,
      top += itNode.offsetTop,
      itNode = itNode.offsetParent // afterthought
  ); // semicolon

  console.log(
    `Offset position of "${id}" element:
left: ${left}px;
top: ${top}px;`,
  );
}

showOffsetPos("content");

// Logs:
// Offset position of "content" element:
// left: 0px;
// top: 153px;
```

 

Note that the semicolon after the `for` statement is mandatory, because it stands as an empty statement . Otherwise, the `for` statement acquires the following `console.log` line as its `statement` section, which makes the `log` execute multiple times.

 
 

### Using for with two iterating variables 

 
 

You can create two counters that are updated simultaneously in a for loop using the comma operator . Multiple `let` and `var` declarations can also be joined with commas.

 js 

```
const arr = [1, 2, 3, 4, 5, 6];
for (let l = 0, r = arr.length - 1; l < r; l++, r--) {
  console.log(arr[l], arr[r]);
}
// 1 6
// 2 5
// 3 4
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-for-statement 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Empty statement 

- `break` 

- `continue` 

- `while` 

- `do...while` 

- `for...in` 

- `for...of` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Block statement - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block

Block statement - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Block statement

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

A block statement is used to group zero or more statements. The block is delimited by a pair of braces ("curly braces") and contains a list of zero or more statements and declarations.

 
 
 
 
 
 

## Try it 

 
 
 

```
var x = 1;
let y = 1;

if (true) {
  var x = 2;
  let y = 2;
}

console.log(x);
// Expected output: 2

console.log(y);
// Expected output: 1
```

 
 
 

## Syntax 

 
 js 

```
{
  StatementList
}
```

 
 
 `StatementList` 
 

Statements and declarations grouped within the block statement.

 
 
 
 

## Description 

 
 

The block statement is often called the compound statement in other languages. It allows you to use multiple statements where JavaScript expects only one statement. Combining statements into blocks is a common practice in JavaScript, especially when used in association with control flow statements like `if...else` and `for` . The opposite behavior is possible using an empty statement , where you provide no statement, although one is required.

In addition, combined with block-scoped declarations like `let` , `const` , and `class` , blocks can prevent temporary variables from polluting the global namespace, just like IIFEs do.

 
 

### Block scoping rules with var or function declaration in non-strict mode 

 
 

Variables declared with `var` or created by function declarations in non-strict mode do not have block scope. Variables introduced within a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. For example:

 js 

```
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
```

 

This logs 2 because the `var x` statement within the block is in the same scope as the `var x` statement before the block.

In non-strict code, function declarations inside blocks behave strangely. Do not use them.

 
 

### Block scoping rules with let, const, class, or function declaration in strict mode 

 
 

By contrast, identifiers declared with `let` , `const` , and `class` do have block scope:

 js 

```
let x = 1;
{
  let x = 2;
}
console.log(x); // 1
```

 

The `x = 2` is limited in scope to the block in which it was defined.

The same is true of `const`:

 js 

```
const c = 1;
{
  const c = 2;
}
console.log(c); // 1; does not throw SyntaxError
```

 

Note that the block-scoped `const c = 2` does not throw a 

```
SyntaxError: Identifier 'c' has already been declared
```

 because it can be declared uniquely within the block.

In strict mode , function declarations inside blocks are scoped to that block and are hoisted to the top of the block.

 js 

```
"use strict";

{
  foo(); // Logs "foo"
  function foo() {
    console.log("foo");
  }
}

foo(); // ReferenceError: foo is not defined
```

 
 
 

## Examples 

 
 
 
 

### Using a block statement as the body of a for loop 

 
 

A `for` loop accepts a single statement as its body.

 js 

```
for (let i = 0; i < 10; i++) console.log(i);
```

 

If you want to use more than one statement in the loop body, you can group them into one block statement:

 js 

```
for (let i = 0; i < 10; i++) {
  console.log(i);
  console.log(i ** 2);
}
```

 
 
 

### Using a block statement to encapsulate data 

 
 

`let` and `const` declarations are scoped to the containing block. This allows you to hide data from the global scope without wrapping it in a function.

 js 

```
let sector;
{
  // These variables are scoped to this block and are not
  // accessible after the block
  const angle = Math.PI / 3;
  const radius = 10;
  sector = {
    radius,
    angle,
    area: (angle / 2) * radius ** 2,
    perimeter: 2 * radius + angle * radius,
  };
}
console.log(sector);
// {
//   radius: 10,
//   angle: 1.0471975511965976,
//   area: 52.35987755982988,
//   perimeter: 30.471975511965976
// }
console.log(typeof radius); // "undefined"
```

 
 
 

### `using` declarations in a block 

 
 

You can declare variables with `using` or `await using` in a block, which causes the object stored in the variable to be disposed when control exits the block. For more information, see resource management .

 js 

```
{
  using reader1 = stream1.getReader();
  using reader2 = stream2.getReader();

  // do something with reader1 and reader2

  // Before we exit the block, reader1 and reader2 are automatically released
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-block 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `while` 

- `if...else` 

- `let` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#defining_methods

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#defining_getters_and_setters

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#comparing_objects

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#see_also

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Keyed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections#content

Keyed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Keyed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are indexed by a key; `Map` and `Set` objects contain elements which are iterable in the order of insertion.

 
 
 
 
 
 

## Maps 

 
 
 
 

### Map object 

 
 

A `Map` object is a key/value map that can iterate its elements in insertion order.

The following code shows some basic operations with a `Map`. See also the `Map` reference page for more examples and the complete API. You can use a `for...of` loop to return an array of `[key, value]` for each iteration.

 js 

```
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
```

 
 
 

### Object and Map compared 

 
 

Traditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. `Map` objects, however, have a few more advantages that make them better maps.

- The keys of an `Object` are strings or symbols , whereas they can be of any value for a `Map`.

- You can get the `size` of a `Map` easily, while you have to manually keep track of size for an `Object`.

- The iteration of maps is in insertion order of the elements.

- An `Object` has a prototype, so there are default keys in the map. (This can be bypassed using `map = Object.create(null)`.)

These three tips can help you to decide whether to use a `Map` or an `Object`:

- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.

- Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.

- Use objects when there is logic that operates on individual elements.

 
 

### WeakMap object 

 
 

A `WeakMap` is a collection of key/value pairs whose keys must be objects or non-registered symbols , with values of any arbitrary JavaScript type , and which does not create strong references to its keys. That is, an object's presence as a key in a `WeakMap` does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any `WeakMap` become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a `WeakMap` key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.

The `WeakMap` API is essentially the same as the `Map` API. However, a `WeakMap` doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a `WeakMap`. If there were, the list would depend on the state of garbage collection, introducing non-determinism.

For more information and example code, see also "Why WeakMap?" on the `WeakMap` reference page.

One use case of `WeakMap` objects is to store private data for an object, or to hide implementation details. In the following example, the private data and methods belong inside the object and are stored in the `privates` object, which is a `WeakMap`. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because `privates` is not exported from the module.

 js 

```
const privates = new WeakMap();

export default function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};
```

 
 

 Note: 
This use case can now be implemented with classes and private fields .

 
 
 

## Sets 

 
 
 
 

### Set object 

 
 

 `Set` objects are collections of unique values. You can iterate its elements in insertion order. A value in a `Set` may only occur once; it is unique in the `Set`'s collection.

The following code shows some basic operations with a `Set`. See also the `Set` reference page for more examples and the complete API.

 js 

```
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
```

 
 
 

### Converting between Array and Set 

 
 

You can create an `Array` from a Set using `Array.from` or the spread syntax . Also, the `Set` constructor accepts an `Array` to convert in the other direction.

 

 Note: 
`Set` objects store unique values —so any duplicate elements from an Array are deleted when converting!

 
 js 

```
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
```

 
 
 

### Array and Set compared 

 
 

Traditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The `Set` object, however, has some advantages:

- Deleting Array elements by value (`arr.splice(arr.indexOf(val), 1)`) is very slow.

- `Set` objects let you delete elements by their value. With an array, you would have to `splice` based on an element's index.

- The value `NaN` cannot be found with `indexOf` in an array.

- `Set` objects store unique values. You don't have to manually keep track of duplicates.

 
 

### WeakSet object 

 
 

 `WeakSet` objects are collections of garbage-collectable values, including objects and non-registered symbols . A value in the `WeakSet` may only occur once. It is unique in the `WeakSet`'s collection.

The main differences to the `Set` object are:

- In contrast to `Sets`, `WeakSets` are collections of objects or symbols only , and not of arbitrary values of any type.

- The `WeakSet` is weak : References to objects in the collection are held weakly. If there is no other reference to an object stored in the `WeakSet`, they can be garbage collected. That also means that there is no list of current objects stored in the collection.

- `WeakSets` are not enumerable.

The use cases of `WeakSet` objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.

 
 

## Key and value equality of Map and Set 

 
 

Both the key equality of `Map` objects and the value equality of `Set` objects are based on the SameValueZero algorithm :

- Equality works like the identity comparison operator `===`.

- `-0` and `+0` are considered equal.

- `NaN` is considered equal to itself (contrary to `===`).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Keyed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections#search

Keyed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Keyed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are indexed by a key; `Map` and `Set` objects contain elements which are iterable in the order of insertion.

 
 
 
 
 
 

## Maps 

 
 
 
 

### Map object 

 
 

A `Map` object is a key/value map that can iterate its elements in insertion order.

The following code shows some basic operations with a `Map`. See also the `Map` reference page for more examples and the complete API. You can use a `for...of` loop to return an array of `[key, value]` for each iteration.

 js 

```
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
```

 
 
 

### Object and Map compared 

 
 

Traditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. `Map` objects, however, have a few more advantages that make them better maps.

- The keys of an `Object` are strings or symbols , whereas they can be of any value for a `Map`.

- You can get the `size` of a `Map` easily, while you have to manually keep track of size for an `Object`.

- The iteration of maps is in insertion order of the elements.

- An `Object` has a prototype, so there are default keys in the map. (This can be bypassed using `map = Object.create(null)`.)

These three tips can help you to decide whether to use a `Map` or an `Object`:

- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.

- Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.

- Use objects when there is logic that operates on individual elements.

 
 

### WeakMap object 

 
 

A `WeakMap` is a collection of key/value pairs whose keys must be objects or non-registered symbols , with values of any arbitrary JavaScript type , and which does not create strong references to its keys. That is, an object's presence as a key in a `WeakMap` does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any `WeakMap` become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a `WeakMap` key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.

The `WeakMap` API is essentially the same as the `Map` API. However, a `WeakMap` doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a `WeakMap`. If there were, the list would depend on the state of garbage collection, introducing non-determinism.

For more information and example code, see also "Why WeakMap?" on the `WeakMap` reference page.

One use case of `WeakMap` objects is to store private data for an object, or to hide implementation details. In the following example, the private data and methods belong inside the object and are stored in the `privates` object, which is a `WeakMap`. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because `privates` is not exported from the module.

 js 

```
const privates = new WeakMap();

export default function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};
```

 
 

 Note: 
This use case can now be implemented with classes and private fields .

 
 
 

## Sets 

 
 
 
 

### Set object 

 
 

 `Set` objects are collections of unique values. You can iterate its elements in insertion order. A value in a `Set` may only occur once; it is unique in the `Set`'s collection.

The following code shows some basic operations with a `Set`. See also the `Set` reference page for more examples and the complete API.

 js 

```
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
```

 
 
 

### Converting between Array and Set 

 
 

You can create an `Array` from a Set using `Array.from` or the spread syntax . Also, the `Set` constructor accepts an `Array` to convert in the other direction.

 

 Note: 
`Set` objects store unique values —so any duplicate elements from an Array are deleted when converting!

 
 js 

```
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
```

 
 
 

### Array and Set compared 

 
 

Traditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The `Set` object, however, has some advantages:

- Deleting Array elements by value (`arr.splice(arr.indexOf(val), 1)`) is very slow.

- `Set` objects let you delete elements by their value. With an array, you would have to `splice` based on an element's index.

- The value `NaN` cannot be found with `indexOf` in an array.

- `Set` objects store unique values. You don't have to manually keep track of duplicates.

 
 

### WeakSet object 

 
 

 `WeakSet` objects are collections of garbage-collectable values, including objects and non-registered symbols . A value in the `WeakSet` may only occur once. It is unique in the `WeakSet`'s collection.

The main differences to the `Set` object are:

- In contrast to `Sets`, `WeakSets` are collections of objects or symbols only , and not of arbitrary values of any type.

- The `WeakSet` is weak : References to objects in the collection are held weakly. If there is no other reference to an object stored in the `WeakSet`, they can be garbage collected. That also means that there is no list of current objects stored in the collection.

- `WeakSets` are not enumerable.

The use cases of `WeakSet` objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.

 
 

## Key and value equality of Map and Set 

 
 

Both the key equality of `Map` objects and the value equality of `Set` objects are based on the SameValueZero algorithm :

- Equality works like the identity comparison operator `===`.

- `-0` and `+0` are considered equal.

- `NaN` is considered equal to itself (contrary to `===`).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Indexed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections

Indexed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Indexed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are ordered by an index value. This includes arrays and array-like constructs such as `Array` objects and `TypedArray` objects.

An array is an ordered list of values that you refer to with a name and an index.

For example, consider an array called `emp`, which contains employees' names indexed by their numerical employee number. So `emp[0]` would be employee number zero, `emp[1]` employee number one, and so on.

JavaScript does not have an explicit array data type. However, you can use the predefined `Array` object and its methods to work with arrays in your applications. The `Array` object has methods for manipulating arrays in various ways, such as joining, reversing, and sorting them. It has a property for determining the array length and other properties for use with regular expressions.

We will be focusing on arrays in this article, but many of the same concepts apply to typed arrays as well, since arrays and typed arrays share many similar methods. For more information on typed arrays, see the typed array guide .

 
 
 
 
 
 

## Creating an array 

 
 

The following statements create equivalent arrays:

 js 

```
const arr1 = new Array(element0, element1, /* …, */ elementN);
const arr2 = Array(element0, element1, /* …, */ elementN);
const arr3 = [element0, element1, /* …, */ elementN];
```

 

`element0, element1, …, elementN` is a list of values for the array's elements. When these values are specified, the array is initialized with them as the array's elements. The array's `length` property is set to the number of arguments.

The bracket syntax is called an "array literal" or "array initializer." It's shorter than other forms of array creation, and so is generally preferred. See Array literals for details.

To create an array with non-zero length, but without any items, either of the following can be used:

 js 

```
// This...
const arr1 = new Array(arrayLength);

// … results in the same array as this
const arr2 = Array(arrayLength);

// This has exactly the same effect
const arr3 = [];
arr3.length = arrayLength;
```

 
 

 Note: 
In the above code, `arrayLength` must be a `Number`. Otherwise, an array with a single element (the provided value) will be created. Calling `arr.length` will return `arrayLength`, but the array doesn't contain any elements. A `for...in` loop will not find any property on the array.

 

In addition to a newly defined variable as shown above, arrays can also be assigned as a property of a new or an existing object:

 js 

```
const obj = {};
// …
obj.prop = [element0, element1, /* …, */ elementN];

// OR
const obj = { prop: [element0, element1, /* …, */ elementN] };
```

 

If you wish to initialize an array with a single element, and the element happens to be a `Number`, you must use the bracket syntax. When a single `Number` value is passed to the `Array()` constructor or function, it is interpreted as an `arrayLength`, not as a single element.

This creates an array with only one element: the number 42.

 js 

```
const arr = [42];
```

 

This creates an array with no elements and `arr.length` set to 42.

 js 

```
const arr = Array(42);
```

 

This is equivalent to:

 js 

```
const arr = [];
arr.length = 42;
```

 

Calling `Array(N)` results in a `RangeError`, if `N` is a non-whole number whose fractional portion is non-zero. The following example illustrates this behavior.

 js 

```
const arr = Array(9.3); // RangeError: Invalid array length
```

 

If your code needs to create arrays with single elements of an arbitrary data type, it is safer to use array literals. Alternatively, create an empty array first before adding the single element to it.

You can also use the `Array.of` static method to create arrays with single element.

 js 

```
const arr = Array.of(9.3); // arr contains only one element 9.3
```

 
 
 

## Referring to array elements 

 
 

Because elements are also properties, you can access them using property accessors . Suppose you define the following array:

 js 

```
const myArray = ["Wind", "Rain", "Fire"];
```

 

You can refer to the first element of the array as `myArray[0]`, the second element of the array as `myArray[1]`, etc… The index of the elements begins with zero.

 

 Note: 
You can also use property accessors to access other properties of the array, like with an object.

 js 

```
const arr = ["one", "two", "three"];
arr[2]; // three
arr["length"]; // 3
```

 
 
 
 

## Populating an array 

 
 

You can populate an array by assigning values to its elements. For example:

 js 

```
const emp = [];
emp[0] = "Casey Jones";
emp[1] = "Phil Lesh";
emp[2] = "August West";
```

 
 

 Note: 
If you supply a non-integer value to the array operator in the code above, a property will be created in the object representing the array, instead of an array element.

 js 

```
const arr = [];
arr[3.4] = "Oranges";
console.log(arr.length); // 0
console.log(Object.hasOwn(arr, 3.4)); // true
```

 
 

You can also populate an array when you create it:

 js 

```
const myArray = new Array("Hello", myVar, 3.14159);
// OR
const myArray = ["Mango", "Apple", "Orange"];
```

 
 
 

### Understanding length 

 
 

At the implementation level, JavaScript's arrays actually store their elements as standard object properties, using the array index as the property name.

The `length` property is special. Its value is always a positive integer greater than the index of the last element if one exists. (In the example below, `'Dusty'` is indexed at `30`, so `cats.length` returns `30 + 1`).

Remember, JavaScript Array indexes are 0-based: they start at `0`, not `1`. This means that the `length` property will be one more than the highest index stored in the array:

 js 

```
const cats = [];
cats[30] = ["Dusty"];
console.log(cats.length); // 31
```

 

You can also assign to the `length` property.

Writing a value that is shorter than the number of stored items truncates the array. Writing `0` empties it entirely:

 js 

```
const cats = ["Dusty", "Misty", "Twiggy"];
console.log(cats.length); // 3

cats.length = 2;
console.log(cats); // [ 'Dusty', 'Misty' ] - Twiggy has been removed

cats.length = 0;
console.log(cats); // []; the cats array is empty

cats.length = 3;
console.log(cats); // [ <3 empty items> ]
```

 
 
 

### Iterating over arrays 

 
 

A common operation is to iterate over the values of an array, processing each one in some way, as follows:

 js 

```
const colors = ["red", "green", "blue"];
for (let i = 0; i < colors.length; i++) {
  console.log(colors[i]);
}
```

 

If you know that none of the elements in your array evaluate to `false` in a boolean context—if your array consists only of DOM nodes, for example—you can use a more efficient idiom:

 js 

```
const divs = document.getElementsByTagName("div");
for (let i = 0, div; (div = divs[i]); i++) {
  /* Process div in some way */
}
```

 

This avoids the overhead of checking the length of the array, and ensures that the `div` variable is reassigned to the current item each time around the loop for added convenience.

The `forEach()` method provides another way of iterating over an array:

 js 

```
const colors = ["red", "green", "blue"];
colors.forEach((color) => console.log(color));
// red
// green
// blue
```

 

The function passed to `forEach` is executed once for every item in the array, with the array item passed as the argument to the function. Unassigned values are not iterated in a `forEach` loop.

Note that the elements of an array that are omitted when the array is defined are not listed when iterating by `forEach`, but are listed when `undefined` has been manually assigned to the element:

 js 

```
const sparseArray = ["first", "second", , "fourth"];

sparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// fourth

if (sparseArray[2] === undefined) {
  console.log("sparseArray[2] is undefined"); // true
}

const nonsparseArray = ["first", "second", undefined, "fourth"];

nonsparseArray.forEach((element) => {
  console.log(element);
});
// Logs:
// first
// second
// undefined
// fourth
```

 

Since JavaScript array elements are saved as standard object properties, it is not advisable to iterate through JavaScript arrays using `for...in` loops, because normal elements and all enumerable properties will be listed.

 
 

### Array methods 

 
 

The `Array` object has the following methods:

The `concat()` method joins two or more arrays and returns a new array.

 js 

```
let myArray = ["1", "2", "3"];
myArray = myArray.concat("a", "b", "c");
// myArray is now ["1", "2", "3", "a", "b", "c"]
```

 

The `join()` method joins all elements of an array into a string.

 js 

```
const myArray = ["Wind", "Rain", "Fire"];
const list = myArray.join(" - "); // list is "Wind - Rain - Fire"
```

 

The `push()` method adds one or more elements to the end of an array and returns the resulting `length` of the array.

 js 

```
const myArray = ["1", "2"];
myArray.push("3"); // myArray is now ["1", "2", "3"]
```

 

The `pop()` method removes the last element from an array and returns that element.

 js 

```
const myArray = ["1", "2", "3"];
const last = myArray.pop();
// myArray is now ["1", "2"], last = "3"
```

 

The `shift()` method removes the first element from an array and returns that element.

 js 

```
const myArray = ["1", "2", "3"];
const first = myArray.shift();
// myArray is now ["2", "3"], first is "1"
```

 

The `unshift()` method adds one or more elements to the front of an array and returns the new length of the array.

 js 

```
const myArray = ["1", "2", "3"];
myArray.unshift("4", "5");
// myArray becomes ["4", "5", "1", "2", "3"]
```

 

The `slice()` method extracts a section of an array and returns a new array.

 js 

```
let myArray = ["a", "b", "c", "d", "e"];
myArray = myArray.slice(1, 4); // [ "b", "c", "d"]
// starts at index 1 and extracts all elements
// until index 3
```

 

The `at()` method returns the element at the specified index in the array, or `undefined` if the index is out of range. It's notably used for negative indices that access elements from the end of the array.

 js 

```
const myArray = ["a", "b", "c", "d", "e"];
myArray.at(-2); // "d", the second-last element of myArray
```

 

The `splice()` method removes elements from an array and (optionally) replaces them. It returns the items which were removed from the array.

 js 

```
const myArray = ["1", "2", "3", "4", "5"];
myArray.splice(1, 3, "a", "b", "c", "d");
// myArray is now ["1", "a", "b", "c", "d", "5"]
// This code started at index one (or where the "2" was),
// removed 3 elements there, and then inserted all consecutive
// elements in its place.
```

 

The `reverse()` method transposes the elements of an array, in place: the first array element becomes the last and the last becomes the first. It returns a reference to the array.

 js 

```
const myArray = ["1", "2", "3"];
myArray.reverse();
// transposes the array so that myArray = ["3", "2", "1"]
```

 

The `flat()` method returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

 js 

```
let myArray = [1, 2, [3, 4]];
myArray = myArray.flat();
// myArray is now [1, 2, 3, 4], since the [3, 4] subarray is flattened
```

 

The `sort()` method sorts the elements of an array in place, and returns a reference to the array.

 js 

```
const myArray = ["Wind", "Rain", "Fire"];
myArray.sort();
// sorts the array so that myArray = ["Fire", "Rain", "Wind"]
```

 

`sort()` can also take a callback function to determine how array elements are compared. The callback function is called with two arguments, which are two values from the array. The function compares these two values and returns a positive number, negative number, or zero, indicating the order of the two values. For instance, the following will sort the array by the last letter of a string:

 js 

```
const sortFn = (a, b) => {
  if (a[a.length - 1] < b[b.length - 1]) {
    return -1; // Negative number => a < b, a comes before b
  } else if (a[a.length - 1] > b[b.length - 1]) {
    return 1; // Positive number => a > b, a comes after b
  }
  return 0; // Zero => a = b, a and b keep their original order
};
myArray.sort(sortFn);
// sorts the array so that myArray = ["Wind","Fire","Rain"]
```

 

- if `a` is less than `b` by the sorting system, return `-1` (or any negative number)

- if `a` is greater than `b` by the sorting system, return `1` (or any positive number)

- if `a` and `b` are considered equivalent, return `0`.

The `indexOf()` method searches the array for `searchElement` and returns the index of the first match.

 js 

```
const a = ["a", "b", "a", "b", "a"];
console.log(a.indexOf("b")); // 1

// Now try again, starting from after the last match
console.log(a.indexOf("b", 2)); // 3
console.log(a.indexOf("z")); // -1, because 'z' was not found
```

 

The `lastIndexOf()` method works like `indexOf`, but starts at the end and searches backwards.

 js 

```
const a = ["a", "b", "c", "d", "a", "b"];
console.log(a.lastIndexOf("b")); // 5

// Now try again, starting from before the last match
console.log(a.lastIndexOf("b", 4)); // 1
console.log(a.lastIndexOf("z")); // -1
```

 

The `forEach()` method executes `callback` on every array item and returns `undefined`.

 js 

```
const a = ["a", "b", "c"];
a.forEach((element) => {
  console.log(element);
});
// Logs:
// a
// b
// c
```

 

The `forEach` method (and others below) that take a callback are known as iterative methods , because they iterate over the entire array in some fashion. Each one takes an optional second argument called `thisArg`. If provided, `thisArg` becomes the value of the `this` keyword inside the body of the callback function. If not provided, as with other cases where a function is invoked outside of an explicit object context, `this` will refer to the global object ( `window` , `globalThis` , etc.) when the function is not strict , or `undefined` when the function is strict.

 

 Note: 
The `sort()` method introduced above is not an iterative method, because its callback function is only used for comparison and may not be called in any particular order based on element order. `sort()` does not accept the `thisArg` parameter either.

 

The `map()` method returns a new array of the return value from executing `callback` on every array item.

 js 

```
const a1 = ["a", "b", "c"];
const a2 = a1.map((item) => item.toUpperCase());
console.log(a2); // ['A', 'B', 'C']
```

 

The `flatMap()` method runs `map()` followed by a `flat()` of depth 1.

 js 

```
const a1 = ["a", "b", "c"];
const a2 = a1.flatMap((item) => [item.toUpperCase(), item.toLowerCase()]);
console.log(a2); // ['A', 'a', 'B', 'b', 'C', 'c']
```

 

The `filter()` method returns a new array containing the items for which `callback` returned `true`.

 js 

```
const a1 = ["a", 10, "b", 20, "c", 30];
const a2 = a1.filter((item) => typeof item === "number");
console.log(a2); // [10, 20, 30]
```

 

The `find()` method returns the first item for which `callback` returned `true`.

 js 

```
const a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.find((item) => typeof item === "number");
console.log(i); // 10
```

 

The `findLast()` method returns the last item for which `callback` returned `true`.

 js 

```
const a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLast((item) => typeof item === "number");
console.log(i); // 30
```

 

The `findIndex()` method returns the index of the first item for which `callback` returned `true`.

 js 

```
const a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findIndex((item) => typeof item === "number");
console.log(i); // 1
```

 

The `findLastIndex()` method returns the index of the last item for which `callback` returned `true`.

 js 

```
const a1 = ["a", 10, "b", 20, "c", 30];
const i = a1.findLastIndex((item) => typeof item === "number");
console.log(i); // 5
```

 

The `every()` method returns `true` if `callback` returns `true` for every item in the array.

 js 

```
function isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.every(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.every(isNumber)); // false
```

 

The `some()` method returns `true` if `callback` returns `true` for at least one item in the array.

 js 

```
function isNumber(value) {
  return typeof value === "number";
}
const a1 = [1, 2, 3];
console.log(a1.some(isNumber)); // true
const a2 = [1, "2", 3];
console.log(a2.some(isNumber)); // true
const a3 = ["1", "2", "3"];
console.log(a3.some(isNumber)); // false
```

 

The `reduce()` method applies 

```
callback(accumulator, currentValue, currentIndex, array)
```

 for each value in the array for the purpose of reducing the list of items down to a single value. The `reduce` function returns the final value returned by `callback` function.

If `initialValue` is specified, then `callback` is called with `initialValue` as the first parameter value and the value of the first item in the array as the second parameter value.

If `initialValue` is not specified, then `callback`'s first two parameter values will be the first and second elements of the array. On every subsequent call, the first parameter's value will be whatever `callback` returned on the previous call, and the second parameter's value will be the next value in the array.

If `callback` needs access to the index of the item being processed, or access to the entire array, they are available as optional parameters.

 js 

```
const a = [10, 20, 30];
const total = a.reduce(
  (accumulator, currentValue) => accumulator + currentValue,
  0,
);
console.log(total); // 60
```

 

The `reduceRight()` method works like `reduce()`, but starts with the last element.

`reduce` and `reduceRight` are the least obvious of the iterative array methods. They should be used for algorithms that combine two values recursively in order to reduce a sequence down to a single value.

 
 

## Array transformations 

 
 

You can transform back and forth between arrays and other data structures.

 
 

### Grouping the elements of an array 

 
 

The `Object.groupBy()` method can be used to group the elements of an array, using a test function that returns a string indicating the group of the current element.

Here we have an inventory array that contains "food" objects that have a `name` and a `type`.

 js 

```
const inventory = [
  { name: "asparagus", type: "vegetables" },
  { name: "bananas", type: "fruit" },
  { name: "goat", type: "meat" },
  { name: "cherries", type: "fruit" },
  { name: "fish", type: "meat" },
];
```

 

To use `Object.groupBy()`, you supply a callback function that is called with the current element, and optionally the current index and array, and returns a string indicating the group of the element.

The code below uses an arrow function to return the `type` of each array element (this uses object destructuring syntax for function arguments to unpack the `type` element from the passed object). The result is an object that has properties named after the unique strings returned by the callback. Each property is assigned an array containing the elements in the group.

 js 

```
const result = Object.groupBy(inventory, ({ type }) => type);
console.log(result);
// Logs
// {
//   vegetables: [{ name: 'asparagus', type: 'vegetables' }],
//   fruit: [
//     { name: 'bananas', type: 'fruit' },
//     { name: 'cherries', type: 'fruit' }
//   ],
//   meat: [
//     { name: 'goat', type: 'meat' },
//     { name: 'fish', type: 'meat' }
//   ]
// }
```

 

Note that the returned object references the same elements as the original array (not deep copies ). Changing the internal structure of these elements will be reflected in both the original array and the returned object.

If you can't use a string as the key, for example, if the information to group is associated with an object that might change, then you can instead use `Map.groupBy()` . This is very similar to `Object.groupBy()` except that it groups the elements of the array into a `Map` that can use an arbitrary value ( object or primitive ) as a key.

 
 

## Sparse arrays 

 
 

Arrays can contain "empty slots", which are not the same as slots filled with the value `undefined`. Empty slots can be created in one of the following ways:

 js 

```
// Array constructor:
const a = Array(5); // [ <5 empty items> ]

// Consecutive commas in array literal:
const b = [1, 2, , , 5]; // [ 1, 2, <2 empty items>, 5 ]

// Directly setting a slot with index greater than array.length:
const c = [1, 2];
c[4] = 5; // [ 1, 2, <2 empty items>, 5 ]

// Elongating an array by directly setting .length:
const d = [1, 2];
d.length = 5; // [ 1, 2, <3 empty items> ]

// Deleting an element:
const e = [1, 2, 3, 4, 5];
delete e[2]; // [ 1, 2, <1 empty item>, 4, 5 ]
```

 

In some operations, empty slots behave as if they are filled with `undefined`.

 js 

```
const arr = [1, 2, , , 5]; // Create a sparse array

// Indexed access
console.log(arr[2]); // undefined

// For...of
for (const i of arr) {
  console.log(i);
}
// Logs: 1 2 undefined undefined 5

// Spreading
const another = [...arr]; // "another" is [ 1, 2, undefined, undefined, 5 ]
```

 

But in others (most notably array iteration methods), empty slots are skipped.

 js 

```
const mapped = arr.map((i) => i + 1); // [ 2, 3, <2 empty items>, 6 ]
arr.forEach((i) => console.log(i)); // 1 2 5
const filtered = arr.filter(() => true); // [ 1, 2, 5 ]
const hasFalsy = arr.some((k) => !k); // false

// Property enumeration
const keys = Object.keys(arr); // [ '0', '1', '4' ]
for (const key in arr) {
  console.log(key);
}
// Logs: '0' '1' '4'
// Spreading into an object uses property enumeration, not the array's iterator
const objectSpread = { ...arr }; // { '0': 1, '1': 2, '4': 5 }
```

 

For a complete list of how array methods behave with sparse arrays, see the `Array` reference page .

 
 

## Multi-dimensional arrays 

 
 

Arrays can be nested, meaning that an array can contain another array as an element. Using this characteristic of JavaScript arrays, multi-dimensional arrays can be created.

The following code creates a two-dimensional array.

 js 

```
const a = new Array(4);
for (let i = 0; i < 4; i++) {
  a[i] = new Array(4);
  for (let j = 0; j < 4; j++) {
    a[i][j] = `[${i}, ${j}]`;
  }
}
```

 

This example creates an array with the following rows:



```
Row 0: [0, 0] [0, 1] [0, 2] [0, 3]
Row 1: [1, 0] [1, 1] [1, 2] [1, 3]
Row 2: [2, 0] [2, 1] [2, 2] [2, 3]
Row 3: [3, 0] [3, 1] [3, 2] [3, 3]
```


 
 

## Using arrays to store other properties 

 
 

Arrays can also be used like objects, to store related information.

 js 

```
const arr = [1, 2, 3];
arr.property = "value";
console.log(arr.property); // "value"
```

 

For example, when an array is the result of a match between a regular expression and a string, the array returns properties and elements that provide information about the match. An array is the return value of `RegExp.prototype.exec()` , `String.prototype.match()` , and `String.prototype.split()` . For information on using arrays with regular expressions, see Regular Expressions .

 
 

## Working with array-like objects 

 
 

Some JavaScript objects, such as the `NodeList` returned by `document.getElementsByTagName()` or the `arguments` object made available within the body of a function, look and behave like arrays on the surface but do not share all of their methods. The `arguments` object provides a `length` attribute but does not implement array methods like `forEach()` .

Array methods cannot be called directly on array-like objects.

 js 

```
function printArguments() {
  arguments.forEach((item) => {
    console.log(item);
  }); // TypeError: arguments.forEach is not a function
}
```

 

But you can call them indirectly using `Function.prototype.call()` .

 js 

```
function printArguments() {
  Array.prototype.forEach.call(arguments, (item) => {
    console.log(item);
  });
}
```

 

Array prototype methods can be used on strings as well, since they provide sequential access to their characters in a similar way to arrays:

 js 

```
Array.prototype.forEach.call("a string", (chr) => {
  console.log(chr);
});
```

 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Keyed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections#maps

Keyed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Keyed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are indexed by a key; `Map` and `Set` objects contain elements which are iterable in the order of insertion.

 
 
 
 
 
 

## Maps 

 
 
 
 

### Map object 

 
 

A `Map` object is a key/value map that can iterate its elements in insertion order.

The following code shows some basic operations with a `Map`. See also the `Map` reference page for more examples and the complete API. You can use a `for...of` loop to return an array of `[key, value]` for each iteration.

 js 

```
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
```

 
 
 

### Object and Map compared 

 
 

Traditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. `Map` objects, however, have a few more advantages that make them better maps.

- The keys of an `Object` are strings or symbols , whereas they can be of any value for a `Map`.

- You can get the `size` of a `Map` easily, while you have to manually keep track of size for an `Object`.

- The iteration of maps is in insertion order of the elements.

- An `Object` has a prototype, so there are default keys in the map. (This can be bypassed using `map = Object.create(null)`.)

These three tips can help you to decide whether to use a `Map` or an `Object`:

- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.

- Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.

- Use objects when there is logic that operates on individual elements.

 
 

### WeakMap object 

 
 

A `WeakMap` is a collection of key/value pairs whose keys must be objects or non-registered symbols , with values of any arbitrary JavaScript type , and which does not create strong references to its keys. That is, an object's presence as a key in a `WeakMap` does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any `WeakMap` become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a `WeakMap` key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.

The `WeakMap` API is essentially the same as the `Map` API. However, a `WeakMap` doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a `WeakMap`. If there were, the list would depend on the state of garbage collection, introducing non-determinism.

For more information and example code, see also "Why WeakMap?" on the `WeakMap` reference page.

One use case of `WeakMap` objects is to store private data for an object, or to hide implementation details. In the following example, the private data and methods belong inside the object and are stored in the `privates` object, which is a `WeakMap`. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because `privates` is not exported from the module.

 js 

```
const privates = new WeakMap();

export default function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};
```

 
 

 Note: 
This use case can now be implemented with classes and private fields .

 
 
 

## Sets 

 
 
 
 

### Set object 

 
 

 `Set` objects are collections of unique values. You can iterate its elements in insertion order. A value in a `Set` may only occur once; it is unique in the `Set`'s collection.

The following code shows some basic operations with a `Set`. See also the `Set` reference page for more examples and the complete API.

 js 

```
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
```

 
 
 

### Converting between Array and Set 

 
 

You can create an `Array` from a Set using `Array.from` or the spread syntax . Also, the `Set` constructor accepts an `Array` to convert in the other direction.

 

 Note: 
`Set` objects store unique values —so any duplicate elements from an Array are deleted when converting!

 
 js 

```
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
```

 
 
 

### Array and Set compared 

 
 

Traditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The `Set` object, however, has some advantages:

- Deleting Array elements by value (`arr.splice(arr.indexOf(val), 1)`) is very slow.

- `Set` objects let you delete elements by their value. With an array, you would have to `splice` based on an element's index.

- The value `NaN` cannot be found with `indexOf` in an array.

- `Set` objects store unique values. You don't have to manually keep track of duplicates.

 
 

### WeakSet object 

 
 

 `WeakSet` objects are collections of garbage-collectable values, including objects and non-registered symbols . A value in the `WeakSet` may only occur once. It is unique in the `WeakSet`'s collection.

The main differences to the `Set` object are:

- In contrast to `Sets`, `WeakSets` are collections of objects or symbols only , and not of arbitrary values of any type.

- The `WeakSet` is weak : References to objects in the collection are held weakly. If there is no other reference to an object stored in the `WeakSet`, they can be garbage collected. That also means that there is no list of current objects stored in the collection.

- `WeakSets` are not enumerable.

The use cases of `WeakSet` objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.

 
 

## Key and value equality of Map and Set 

 
 

Both the key equality of `Map` objects and the value equality of `Set` objects are based on the SameValueZero algorithm :

- Equality works like the identity comparison operator `===`.

- `-0` and `+0` are considered equal.

- `NaN` is considered equal to itself (contrary to `===`).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Keyed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections#sets

Keyed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Keyed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are indexed by a key; `Map` and `Set` objects contain elements which are iterable in the order of insertion.

 
 
 
 
 
 

## Maps 

 
 
 
 

### Map object 

 
 

A `Map` object is a key/value map that can iterate its elements in insertion order.

The following code shows some basic operations with a `Map`. See also the `Map` reference page for more examples and the complete API. You can use a `for...of` loop to return an array of `[key, value]` for each iteration.

 js 

```
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
```

 
 
 

### Object and Map compared 

 
 

Traditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. `Map` objects, however, have a few more advantages that make them better maps.

- The keys of an `Object` are strings or symbols , whereas they can be of any value for a `Map`.

- You can get the `size` of a `Map` easily, while you have to manually keep track of size for an `Object`.

- The iteration of maps is in insertion order of the elements.

- An `Object` has a prototype, so there are default keys in the map. (This can be bypassed using `map = Object.create(null)`.)

These three tips can help you to decide whether to use a `Map` or an `Object`:

- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.

- Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.

- Use objects when there is logic that operates on individual elements.

 
 

### WeakMap object 

 
 

A `WeakMap` is a collection of key/value pairs whose keys must be objects or non-registered symbols , with values of any arbitrary JavaScript type , and which does not create strong references to its keys. That is, an object's presence as a key in a `WeakMap` does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any `WeakMap` become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a `WeakMap` key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.

The `WeakMap` API is essentially the same as the `Map` API. However, a `WeakMap` doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a `WeakMap`. If there were, the list would depend on the state of garbage collection, introducing non-determinism.

For more information and example code, see also "Why WeakMap?" on the `WeakMap` reference page.

One use case of `WeakMap` objects is to store private data for an object, or to hide implementation details. In the following example, the private data and methods belong inside the object and are stored in the `privates` object, which is a `WeakMap`. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because `privates` is not exported from the module.

 js 

```
const privates = new WeakMap();

export default function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};
```

 
 

 Note: 
This use case can now be implemented with classes and private fields .

 
 
 

## Sets 

 
 
 
 

### Set object 

 
 

 `Set` objects are collections of unique values. You can iterate its elements in insertion order. A value in a `Set` may only occur once; it is unique in the `Set`'s collection.

The following code shows some basic operations with a `Set`. See also the `Set` reference page for more examples and the complete API.

 js 

```
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
```

 
 
 

### Converting between Array and Set 

 
 

You can create an `Array` from a Set using `Array.from` or the spread syntax . Also, the `Set` constructor accepts an `Array` to convert in the other direction.

 

 Note: 
`Set` objects store unique values —so any duplicate elements from an Array are deleted when converting!

 
 js 

```
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
```

 
 
 

### Array and Set compared 

 
 

Traditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The `Set` object, however, has some advantages:

- Deleting Array elements by value (`arr.splice(arr.indexOf(val), 1)`) is very slow.

- `Set` objects let you delete elements by their value. With an array, you would have to `splice` based on an element's index.

- The value `NaN` cannot be found with `indexOf` in an array.

- `Set` objects store unique values. You don't have to manually keep track of duplicates.

 
 

### WeakSet object 

 
 

 `WeakSet` objects are collections of garbage-collectable values, including objects and non-registered symbols . A value in the `WeakSet` may only occur once. It is unique in the `WeakSet`'s collection.

The main differences to the `Set` object are:

- In contrast to `Sets`, `WeakSets` are collections of objects or symbols only , and not of arbitrary values of any type.

- The `WeakSet` is weak : References to objects in the collection are held weakly. If there is no other reference to an object stored in the `WeakSet`, they can be garbage collected. That also means that there is no list of current objects stored in the collection.

- `WeakSets` are not enumerable.

The use cases of `WeakSet` objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.

 
 

## Key and value equality of Map and Set 

 
 

Both the key equality of `Map` objects and the value equality of `Set` objects are based on the SameValueZero algorithm :

- Equality works like the identity comparison operator `===`.

- `-0` and `+0` are considered equal.

- `NaN` is considered equal to itself (contrary to `===`).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Keyed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections#key_and_value_equality_of_map_and_set

Keyed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Keyed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are indexed by a key; `Map` and `Set` objects contain elements which are iterable in the order of insertion.

 
 
 
 
 
 

## Maps 

 
 
 
 

### Map object 

 
 

A `Map` object is a key/value map that can iterate its elements in insertion order.

The following code shows some basic operations with a `Map`. See also the `Map` reference page for more examples and the complete API. You can use a `for...of` loop to return an array of `[key, value]` for each iteration.

 js 

```
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
```

 
 
 

### Object and Map compared 

 
 

Traditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. `Map` objects, however, have a few more advantages that make them better maps.

- The keys of an `Object` are strings or symbols , whereas they can be of any value for a `Map`.

- You can get the `size` of a `Map` easily, while you have to manually keep track of size for an `Object`.

- The iteration of maps is in insertion order of the elements.

- An `Object` has a prototype, so there are default keys in the map. (This can be bypassed using `map = Object.create(null)`.)

These three tips can help you to decide whether to use a `Map` or an `Object`:

- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.

- Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.

- Use objects when there is logic that operates on individual elements.

 
 

### WeakMap object 

 
 

A `WeakMap` is a collection of key/value pairs whose keys must be objects or non-registered symbols , with values of any arbitrary JavaScript type , and which does not create strong references to its keys. That is, an object's presence as a key in a `WeakMap` does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any `WeakMap` become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a `WeakMap` key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.

The `WeakMap` API is essentially the same as the `Map` API. However, a `WeakMap` doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a `WeakMap`. If there were, the list would depend on the state of garbage collection, introducing non-determinism.

For more information and example code, see also "Why WeakMap?" on the `WeakMap` reference page.

One use case of `WeakMap` objects is to store private data for an object, or to hide implementation details. In the following example, the private data and methods belong inside the object and are stored in the `privates` object, which is a `WeakMap`. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because `privates` is not exported from the module.

 js 

```
const privates = new WeakMap();

export default function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};
```

 
 

 Note: 
This use case can now be implemented with classes and private fields .

 
 
 

## Sets 

 
 
 
 

### Set object 

 
 

 `Set` objects are collections of unique values. You can iterate its elements in insertion order. A value in a `Set` may only occur once; it is unique in the `Set`'s collection.

The following code shows some basic operations with a `Set`. See also the `Set` reference page for more examples and the complete API.

 js 

```
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
```

 
 
 

### Converting between Array and Set 

 
 

You can create an `Array` from a Set using `Array.from` or the spread syntax . Also, the `Set` constructor accepts an `Array` to convert in the other direction.

 

 Note: 
`Set` objects store unique values —so any duplicate elements from an Array are deleted when converting!

 
 js 

```
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
```

 
 
 

### Array and Set compared 

 
 

Traditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The `Set` object, however, has some advantages:

- Deleting Array elements by value (`arr.splice(arr.indexOf(val), 1)`) is very slow.

- `Set` objects let you delete elements by their value. With an array, you would have to `splice` based on an element's index.

- The value `NaN` cannot be found with `indexOf` in an array.

- `Set` objects store unique values. You don't have to manually keep track of duplicates.

 
 

### WeakSet object 

 
 

 `WeakSet` objects are collections of garbage-collectable values, including objects and non-registered symbols . A value in the `WeakSet` may only occur once. It is unique in the `WeakSet`'s collection.

The main differences to the `Set` object are:

- In contrast to `Sets`, `WeakSets` are collections of objects or symbols only , and not of arbitrary values of any type.

- The `WeakSet` is weak : References to objects in the collection are held weakly. If there is no other reference to an object stored in the `WeakSet`, they can be garbage collected. That also means that there is no list of current objects stored in the collection.

- `WeakSets` are not enumerable.

The use cases of `WeakSet` objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.

 
 

## Key and value equality of Map and Set 

 
 

Both the key equality of `Map` objects and the value equality of `Set` objects are based on the SameValueZero algorithm :

- Equality works like the identity comparison operator `===`.

- `-0` and `+0` are considered equal.

- `NaN` is considered equal to itself (contrary to `===`).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Keyed collections - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Keyed_collections#map_object

Keyed collections - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Keyed collections

 
 
 
- Previous 
- Next 

This chapter introduces collections of data which are indexed by a key; `Map` and `Set` objects contain elements which are iterable in the order of insertion.

 
 
 
 
 
 

## Maps 

 
 
 
 

### Map object 

 
 

A `Map` object is a key/value map that can iterate its elements in insertion order.

The following code shows some basic operations with a `Map`. See also the `Map` reference page for more examples and the complete API. You can use a `for...of` loop to return an array of `[key, value]` for each iteration.

 js 

```
const sayings = new Map();
sayings.set("dog", "woof");
sayings.set("cat", "meow");
sayings.set("elephant", "toot");
sayings.size; // 3
sayings.get("dog"); // woof
sayings.get("fox"); // undefined
sayings.has("bird"); // false
sayings.delete("dog");
sayings.has("dog"); // false

for (const [key, value] of sayings) {
  console.log(`${key} goes ${value}`);
}
// "cat goes meow"
// "elephant goes toot"

sayings.clear();
sayings.size; // 0
```

 
 
 

### Object and Map compared 

 
 

Traditionally, objects have been used to map strings to values. Objects allow you to set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. `Map` objects, however, have a few more advantages that make them better maps.

- The keys of an `Object` are strings or symbols , whereas they can be of any value for a `Map`.

- You can get the `size` of a `Map` easily, while you have to manually keep track of size for an `Object`.

- The iteration of maps is in insertion order of the elements.

- An `Object` has a prototype, so there are default keys in the map. (This can be bypassed using `map = Object.create(null)`.)

These three tips can help you to decide whether to use a `Map` or an `Object`:

- Use maps over objects when keys are unknown until run time, and when all keys are the same type and all values are the same type.

- Use maps if there is a need to store primitive values as keys because object treats each key as a string whether it's a number value, boolean value or any other primitive value.

- Use objects when there is logic that operates on individual elements.

 
 

### WeakMap object 

 
 

A `WeakMap` is a collection of key/value pairs whose keys must be objects or non-registered symbols , with values of any arbitrary JavaScript type , and which does not create strong references to its keys. That is, an object's presence as a key in a `WeakMap` does not prevent the object from being garbage collected. Once an object used as a key has been collected, its corresponding values in any `WeakMap` become candidates for garbage collection as well — as long as they aren't strongly referred to elsewhere. The only primitive type that can be used as a `WeakMap` key is symbol — more specifically, non-registered symbols — because non-registered symbols are guaranteed to be unique and cannot be re-created.

The `WeakMap` API is essentially the same as the `Map` API. However, a `WeakMap` doesn't allow observing the liveness of its keys, which is why it doesn't allow enumeration. So there is no method to obtain a list of the keys in a `WeakMap`. If there were, the list would depend on the state of garbage collection, introducing non-determinism.

For more information and example code, see also "Why WeakMap?" on the `WeakMap` reference page.

One use case of `WeakMap` objects is to store private data for an object, or to hide implementation details. In the following example, the private data and methods belong inside the object and are stored in the `privates` object, which is a `WeakMap`. Everything exposed on the instance and prototype is public; everything else is inaccessible from the outside world because `privates` is not exported from the module.

 js 

```
const privates = new WeakMap();

export default function Public() {
  const me = {
    // Private data goes here
  };
  privates.set(this, me);
}

Public.prototype.method = function () {
  const me = privates.get(this);
  // Do stuff with private data in `me`
  // …
};
```

 
 

 Note: 
This use case can now be implemented with classes and private fields .

 
 
 

## Sets 

 
 
 
 

### Set object 

 
 

 `Set` objects are collections of unique values. You can iterate its elements in insertion order. A value in a `Set` may only occur once; it is unique in the `Set`'s collection.

The following code shows some basic operations with a `Set`. See also the `Set` reference page for more examples and the complete API.

 js 

```
const mySet = new Set();
mySet.add(1);
mySet.add("some text");
mySet.add("foo");

mySet.has(1); // true
mySet.delete("foo");
mySet.size; // 2

for (const item of mySet) {
  console.log(item);
}
// 1
// "some text"
```

 
 
 

### Converting between Array and Set 

 
 

You can create an `Array` from a Set using `Array.from` or the spread syntax . Also, the `Set` constructor accepts an `Array` to convert in the other direction.

 

 Note: 
`Set` objects store unique values —so any duplicate elements from an Array are deleted when converting!

 
 js 

```
Array.from(mySet);
[...mySet2];

mySet2 = new Set([1, 2, 3, 4]);
```

 
 
 

### Array and Set compared 

 
 

Traditionally, a set of elements has been stored in arrays in JavaScript in a lot of situations. The `Set` object, however, has some advantages:

- Deleting Array elements by value (`arr.splice(arr.indexOf(val), 1)`) is very slow.

- `Set` objects let you delete elements by their value. With an array, you would have to `splice` based on an element's index.

- The value `NaN` cannot be found with `indexOf` in an array.

- `Set` objects store unique values. You don't have to manually keep track of duplicates.

 
 

### WeakSet object 

 
 

 `WeakSet` objects are collections of garbage-collectable values, including objects and non-registered symbols . A value in the `WeakSet` may only occur once. It is unique in the `WeakSet`'s collection.

The main differences to the `Set` object are:

- In contrast to `Sets`, `WeakSets` are collections of objects or symbols only , and not of arbitrary values of any type.

- The `WeakSet` is weak : References to objects in the collection are held weakly. If there is no other reference to an object stored in the `WeakSet`, they can be garbage collected. That also means that there is no list of current objects stored in the collection.

- `WeakSets` are not enumerable.

The use cases of `WeakSet` objects are limited. They will not leak memory, so it can be safe to use DOM elements as a key and mark them for tracking purposes, for example.

 
 

## Key and value equality of Map and Set 

 
 

Both the key equality of `Map` objects and the value equality of `Set` objects are based on the SameValueZero algorithm :

- Equality works like the identity comparison operator `===`.

- `-0` and `+0` are considered equal.

- `NaN` is considered equal to itself (contrary to `===`).

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 19, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Map - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map

Map - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Map

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `Map` object holds key-value pairs and remembers the original insertion order of the keys.
Any value (both objects and primitive values ) may be used as either a key or a value.

 
 
 
 
 
 

## Try it 

 
 
 

```
const map = new Map();

map.set("a", 1);
map.set("b", 2);
map.set("c", 3);

console.log(map.get("a"));
// Expected output: 1

map.set("a", 97);

console.log(map.get("a"));
// Expected output: 97

console.log(map.size);
// Expected output: 3

map.delete("b");

console.log(map.size);
// Expected output: 2
```

 
 
 

## Description 

 
 

`Map` objects are collections of key-value pairs. A key in the `Map` may only occur once ; it is unique in the `Map`'s collection. A `Map` object is iterated by key-value pairs — a `for...of` loop returns a 2-member array of `[key, value]` for each iteration. Iteration happens in insertion order , which corresponds to the order in which each key-value pair was first inserted into the map by the `set()` method (that is, there wasn't a key with the same value already in the map when `set()` was called).

The specification requires maps to be implemented "that, on average, provide access times that are sublinear on the number of elements in the collection". Therefore, it could be represented internally as a hash table (with O(1) lookup), a search tree (with O(log(N)) lookup), or any other data structure, as long as the complexity is better than O(N).

 
 

### Key equality 

 
 

Value equality is based on the SameValueZero algorithm. (It used to use SameValue , which treated `0` and `-0` as different. Check browser compatibility .) This means `NaN` is considered the same as `NaN` (even though `NaN !== NaN`) and all other values are considered equal according to the semantics of the `===` operator. Also, for object keys, equality is based on object identity. They are compared by reference, not by value. See Using the Map object for examples.

 
 

### Objects vs. Maps 

 
 

 `Object` is similar to `Map`—both let you set keys to
values, retrieve those values, delete keys, and detect whether something is
stored at a key. For this reason (and because there were no built-in
alternatives), `Object` has been used as `Map` historically.

However, there are important differences that make `Map` preferable in some
cases:

 
 
 
 
 Map 
 Object 
 
 
 
 
 Accidental Keys 
 
 A `Map` does not contain any keys by default. It only
 contains what is explicitly put into it.
 
 
 

 An `Object` has a prototype, so it contains default keys
 that could collide with your own keys if you're not careful.
 

 
 

 Note: This can be bypassed by using
 `Object.create(null)` ,
 but this is seldom done.
 

 
 
 
 
 Security 
 
 A `Map` is safe to use with user-provided keys and values.
 
 
 

 Setting user-provided key-value pairs on an `Object` may allow
 an attacker to override the object's prototype, which can lead to
 
 object injection attacks
 or prototype pollution attacks . Like the accidental keys issue, this can also be mitigated by using
 a `null`-prototype object.
 

 
 
 
 Key Types 
 
 A `Map`'s keys can be any value (including functions,
 objects, or any primitive).
 
 
 The keys of an `Object` must be either a
 `String` or a `Symbol` .
 
 
 
 Key Order 
 
 

 The keys in `Map` are ordered in a straightforward
 way: A `Map` object iterates entries, keys, and values in
 the order of entry insertion.
 

 
 
 

 Although the keys of an ordinary `Object` are ordered now,
 this was not always the case, and the order is complex. As a result,
 it's best not to rely on property order.
 

 

 The order was first defined for own properties only in ECMAScript
 2015; ECMAScript 2020 defines order for inherited properties as well.
 But note that no single mechanism
 iterates
 all of an object's properties; the various mechanisms
 each include different subsets of properties.
 ( `for-in` 
 includes only enumerable string-keyed properties;
 `Object.keys` includes only own, enumerable,
 string-keyed properties;
 `Object.getOwnPropertyNames` includes own,
 string-keyed properties even if non-enumerable;
 `Object.getOwnPropertySymbols` does the same
 for just `Symbol`-keyed properties, etc.)
 

 
 
 
 

Size

 
 
 The number of items in a `Map` is easily retrieved from its
 `size` property.
 
 
 Determining the number of items in an `Object` is more roundabout and less efficient. A common way to do it is through the `length` of the array returned from `Object.keys()` .
 
 
 
 Iteration 
 
 A `Map` is an
 iterable , so it can be directly iterated.
 
 
 

 `Object` does not implement an iteration protocol , and so objects are not directly iterable using the JavaScript
 for...of 
 statement (by default).
 

 
 

 Note: 

 

 - 
 An object can implement the iteration protocol, or you can get an
 iterable for an object using `Object.keys` or `Object.entries` .
 

 - 
 The
 for...in 
 statement allows you to iterate over the
 enumerable properties of an object.
 

 

 
 
 
 
 Performance 
 
 

 Performs better in scenarios involving frequent additions and removals
 of key-value pairs.
 

 
 
 

 Not optimized for frequent additions and removals of key-value pairs.
 

 
 
 
 Serialization and parsing 
 
 

No native support for serialization or parsing.

 

 (But you can build your own serialization and parsing support for
 `Map` by using `JSON.stringify()` 
 with its replacer argument, and by using
 `JSON.parse()` with its
 reviver argument. See the Stack Overflow question
 How do you JSON.stringify an ES6 Map? ).
 

 
 
 

 Native support for serialization from `Object` to
 JSON, using `JSON.stringify()` .
 

 

 Native support for parsing from JSON to `Object` ,
 using `JSON.parse()` .
 

 
 
 
 
 
 

### Setting object properties 

 
 

Setting Object properties works for Map objects as well, and can cause
considerable confusion.

Therefore, this appears to work in a way:

 js 

```
const wrongMap = new Map();
wrongMap["bla"] = "blaa";
wrongMap["bla2"] = "blaaa2";

console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }
```

 

But that way of setting a property does not interact with the Map data
structure. It uses the feature of the generic object. The value of 'bla' is not
stored in the Map for queries. Other operations on the data fail:

 js 

```
wrongMap.has("bla"); // false
wrongMap.delete("bla"); // false
console.log(wrongMap); // Map { bla: 'blaa', bla2: 'blaaa2' }
```

 

The correct usage for storing data in the Map is through the `set(key, value)`
method.

 js 

```
const contacts = new Map();
contacts.set("Jessie", { phone: "213-555-1234", address: "123 N 1st Ave" });
contacts.has("Jessie"); // true
contacts.get("Hilary"); // undefined
contacts.set("Hilary", { phone: "617-555-4321", address: "321 S 2nd St" });
contacts.get("Jessie"); // {phone: "213-555-1234", address: "123 N 1st Ave"}
contacts.delete("Raymond"); // false
contacts.delete("Jessie"); // true
console.log(contacts.size); // 1
```

 
 
 

### Map-like browser APIs 

 
 

 Browser `Map`-like objects (or "maplike objects") are Web API interfaces that behave in many ways like a `Map`.

Just like `Map`, entries can be iterated in the same order that they were added to the object.
`Map`-like objects and `Map` also have properties and methods that share the same name and behavior.
However unlike `Map` they only allow specific predefined types for the keys and values of each entry.

The allowed types are set in the specification IDL definition.
For example, `RTCStatsReport` is a `Map`-like object that must use strings for keys and objects for values.
This is defined in the specification IDL below:

 webidl 

```
interface RTCStatsReport {
  readonly maplike<DOMString, object>;
};
```

 

`Map`-like objects are either read-only or read-writable (see the `readonly` keyword in the IDL above).

- Read-only `Map`-like objects have the property `size` , and the methods: `entries()` , `forEach()` , `get()` , `has()` , `keys()` , `values()` , and `Symbol.iterator()` .

- Writeable `Map`-like objects additionally have the methods: `clear()` , `delete()` , and `set()` .

The methods and properties have the same behavior as the equivalent entities in `Map`, except for the restriction on the types of the keys and values.

The following are examples of read-only `Map`-like browser objects:

- `AudioParamMap` 

- `RTCStatsReport` 

- `EventCounts` 

- `KeyboardLayoutMap` 

- `MIDIInputMap` 

- `MIDIOutputMap` 

 
 

## Constructor 

 
 
 `Map()` 
 

Creates a new `Map` object.

 
 
 
 

## Static properties 

 
 
 `Map[Symbol.species]` 
 

The constructor function that is used to create derived objects.

 
 
 
 

## Static methods 

 
 
 `Map.groupBy()` 
 

Groups the elements of a given iterable using the values returned by a provided callback function. The final returned `Map` uses the unique values from the test function as keys, which can be used to get the array of elements in each group.

 
 
 
 

## Instance properties 

 
 

These properties are defined on `Map.prototype` and shared by all `Map` instances.

 
 `Map.prototype.constructor` 
 

The constructor function that created the instance object. For `Map` instances, the initial value is the `Map` constructor.

 
 `Map.prototype.size` 
 

Returns the number of key/value pairs in the `Map` object.

 
 `Map.prototype[Symbol.toStringTag]` 
 

The initial value of the `[Symbol.toStringTag]` property is the string `"Map"`. This property is used in `Object.prototype.toString()` .

 
 
 
 

## Instance methods 

 
 
 `Map.prototype.clear()` 
 

Removes all key-value pairs from the `Map` object.

 
 `Map.prototype.delete()` 
 

Removes the entry specified by the key from this `Map`.

 
 `Map.prototype.entries()` 
 

Returns a new Iterator object that contains a two-member array of `[key, value]` for each element in the `Map` object in insertion order.

 
 `Map.prototype.forEach()` 
 

Calls `callbackFn` once for each key-value pair present in the `Map` object, in insertion order. If a `thisArg` parameter is provided to `forEach`, it will be used as the `this` value for each callback.

 
 `Map.prototype.get()` 
 

Returns the value corresponding to the key in this `Map`, or `undefined` if there is none.

 
 `Map.prototype.getOrInsert()` 
 Experimental 
 
 

Returns the value corresponding to the specified key in this `Map`. If the key is not present, it inserts a new entry with the key and a given default value, and returns the inserted value.

 
 `Map.prototype.getOrInsertComputed()` 
 Experimental 
 
 

Returns the value corresponding to the specified key in this `Map`. If the key is not present, it inserts a new entry with the key and a default value computed from a given callback, and returns the inserted value.

 
 `Map.prototype.has()` 
 

Returns a boolean indicating whether an entry with the specified key exists in this `Map` or not.

 
 `Map.prototype.keys()` 
 

Returns a new Iterator object that contains the keys for each element in the `Map` object in insertion order.

 
 `Map.prototype.set()` 
 

Adds a new entry with a specified key and value to this `Map`, or updates an existing entry if the key already exists.

 
 `Map.prototype.values()` 
 

Returns a new Iterator object that contains the values for each element in the `Map` object in insertion order.

 
 `Map.prototype[Symbol.iterator]()` 
 

Returns a new Iterator object that contains a two-member array of `[key, value]` for each element in the `Map` object in insertion order.

 
 
 
 

## Examples 

 
 
 
 

### Using the Map object 

 
 js 

```
const myMap = new Map();

const keyString = "a string";
const keyObj = {};
const keyFunc = () => {};

// setting the values
myMap.set(keyString, "value associated with 'a string'");
myMap.set(keyObj, "value associated with keyObj");
myMap.set(keyFunc, "value associated with keyFunc");

console.log(myMap.size); // 3

// getting the values
console.log(myMap.get(keyString)); // "value associated with 'a string'"
console.log(myMap.get(keyObj)); // "value associated with keyObj"
console.log(myMap.get(keyFunc)); // "value associated with keyFunc"

console.log(myMap.get("a string")); // "value associated with 'a string'", because keyString === 'a string'
console.log(myMap.get({})); // undefined, because keyObj !== {}
console.log(myMap.get(() => {})); // undefined, because keyFunc !== () => {}
```

 
 
 

### Using NaN as Map keys 

 
 

 `NaN` can also be used as a key. Even though every `NaN` is
not equal to itself (`NaN !== NaN` is true), the following example works because
`NaN`s are indistinguishable from each other:

 js 

```
const myMap = new Map();
myMap.set(NaN, "not a number");

myMap.get(NaN);
// "not a number"

const otherNaN = Number("foo");
myMap.get(otherNaN);
// "not a number"
```

 
 
 

### Iterating Map with for...of 

 
 

Maps can be iterated using a `for...of` loop:

 js 

```
const myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

for (const [key, value] of myMap) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one

for (const key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (const value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (const [key, value] of myMap.entries()) {
  console.log(`${key} = ${value}`);
}
// 0 = zero
// 1 = one
```

 
 
 

### Iterating Map with forEach() 

 
 

Maps can be iterated using the
 `forEach()` method:

 js 

```
myMap.forEach((value, key) => {
  console.log(`${key} = ${value}`);
});
// 0 = zero
// 1 = one
```

 
 
 

### Relation with Array objects 

 
 js 

```
const kvArray = [
  ["key1", "value1"],
  ["key2", "value2"],
];

// Use the regular Map constructor to transform a 2D key-value Array into a map
const myMap = new Map(kvArray);

console.log(myMap.get("key1")); // "value1"

// Use Array.from() to transform a map into a 2D key-value Array
console.log(Array.from(myMap)); // Will show you exactly the same Array as kvArray

// A succinct way to do the same, using the spread syntax
console.log([...myMap]);

// Or use the keys() or values() iterators, and convert them to an array
console.log(Array.from(myMap.keys())); // ["key1", "key2"]
```

 
 
 

### Cloning and merging Maps 

 
 

Just like `Array`s, `Map`s can be cloned:

 js 

```
const original = new Map([[1, "one"]]);

const clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false (useful for shallow comparison)
```

 
 

 Note: 
Keep in mind that the data itself is not cloned. In other words, it is only a shallow copy of the `Map`.

 

Maps can be merged, maintaining key uniqueness:

 js 

```
const first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge two maps. The last repeated key wins.
// Spread syntax essentially converts a Map to an Array
const merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
```

 

Maps can be merged with Arrays, too:

 js 

```
const first = new Map([
  [1, "one"],
  [2, "two"],
  [3, "three"],
]);

const second = new Map([
  [1, "uno"],
  [2, "dos"],
]);

// Merge maps with an array. The last repeated key wins.
const merged = new Map([...first, ...second, [1, "un"]]);

console.log(merged.get(1)); // un
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-map-objects 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill for `Map` in `core-js` 

- es-shims polyfill of `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 17, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Object initializer - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer

Object initializer - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Object initializer

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

An object initializer is a comma-delimited list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`). Objects can also be initialized using `Object.create()` or by invoking a constructor function with the `new` operator.

 
 
 
 
 
 

## Try it 

 
 
 

```
const object1 = { a: "foo", b: 42, c: {} };

console.log(object1.a);
// Expected output: "foo"

const a = "foo";
const b = 42;
const c = {};
const object2 = { a: a, b: b, c: c };

console.log(object2.b);
// Expected output: 42

const object3 = { a, b, c };

console.log(object3.a);
// Expected output: "foo"
```

 
 
 

## Syntax 

 
 js 

```
o = {
  a: "foo",
  b: 42,
  c: {},
  1: "number literal property",
  "foo:bar": "string literal property",

  shorthandProperty,

  method(parameters) {
    // …
  },

  get property() {},
  set property(value) {},

  [expression]: "computed property",

  __proto__: prototype,

  ...spreadProperty,
};
```

 
 
 

## Description 

 
 

An object initializer is an expression that describes the initialization of an `Object` . Objects consist of properties , which are used to describe an object. The values of object properties can either contain primitive data types or other objects.

 
 

### Object literal syntax vs. JSON 

 
 

The object literal syntax is not the same as the J ava S cript O bject N otation ( JSON ). Although they look similar, there are differences between them:

- JSON only permits property definition using the `"property": value` syntax. The property name must be double-quoted, and the definition cannot be a shorthand. Computed property names are not allowed either.

- JSON object property values can only be strings, numbers, `true`, `false`, `null`, arrays, or another JSON object. This means JSON cannot express methods or non-plain objects like `Map` or `RegExp` .

- In JSON, `"__proto__"` is a normal property key. In an object literal, it sets the object's prototype .

JSON is a strict subset of the object literal syntax, meaning that every valid JSON text can be parsed as an object literal, and would likely not cause syntax errors. The only exception is that the object literal syntax prohibits duplicate `__proto__` keys, which does not apply to `JSON.parse()` . The latter treats `__proto__` like a normal property and takes the last occurrence as the property's value. The only time when the object value they represent (a.k.a. their semantic) differ is also when the source contains the `__proto__` key — for object literals, it sets the object's prototype; for JSON, it's a normal property.

 js 

```
console.log(JSON.parse('{ "__proto__": 0, "__proto__": 1 }')); // {__proto__: 1}
console.log({ "__proto__": 0, "__proto__": 1 }); // SyntaxError: Duplicate __proto__ fields are not allowed in object literals

console.log(JSON.parse('{ "__proto__": {} }')); // { __proto__: {} }
console.log({ "__proto__": {} }); // {} (with {} as prototype)
```

 
 
 

## Examples 

 
 
 
 

### Creating objects 

 
 

An empty object with no properties can be created like this:

 js 

```
const object = {};
```

 

However, the advantage of the literal or initializer notation is, that you are able to quickly create objects with properties inside the curly braces. You notate a list of `key: value` pairs delimited by commas.

The following code creates an object with three properties and the keys are `"foo"`, `"age"` and `"baz"`. The values of these keys are a string `"bar"`, the number `42`, and another object.

 js 

```
const object = {
  foo: "bar",
  age: 42,
  baz: { myProp: 12 },
};
```

 
 
 

### Accessing properties 

 
 

Once you have created an object, you might want to read or change them. Object properties can be accessed by using the dot notation or the bracket notation. (See property accessors for detailed information.)

 js 

```
object.foo; // "bar"
object["age"]; // 42
object.baz; // {myProp: 12}
object.baz.myProp; // 12
```

 
 
 

### Property definitions 

 
 

We have already learned how to notate properties using the initializer syntax. Oftentimes, there are variables in your code that you would like to put into an object. You will see code like this:

 js 

```
const a = "foo";
const b = 42;
const c = {};

const o = {
  a: a,
  b: b,
  c: c,
};
```

 

There is a shorter notation available to achieve the same:

 js 

```
const a = "foo";
const b = 42;
const c = {};

// Shorthand property names
const o = { a, b, c };

// In other words,
console.log(o.a === { a }.a); // true
```

 

#### Duplicate property names

When using the same name for your properties, the second property will overwrite the first.

 js 

```
const a = { x: 1, x: 2 };
console.log(a); // {x: 2}
```

 

After ES2015, duplicate property names are allowed everywhere, including strict mode . You can also have duplicate property names in classes . The only exception is private elements , which must be unique in the class body.

 
 

### Method definitions 

 
 

A property of an object can also refer to a function or a getter or setter method.

 js 

```
const o = {
  property: function (parameters) {},
  get property() {
    return 1;
  },
  set property(value) {},
};
```

 

A shorthand notation is available, so that the keyword `function` is no longer necessary.

 js 

```
// Shorthand method names
const o = {
  property(parameters) {},
};
```

 

There is also a way to concisely define generator methods.

 js 

```
const o = {
  *generator() {
    // …
  },
};
```

 

Which is equivalent to this ES5-like notation (but note that ECMAScript 5 has no generators):

 js 

```
const o = {
  generator: function* () {
    // …
  },
};
```

 

For more information and examples about methods, see method definitions .

 
 

### Computed property names 

 
 

The object initializer syntax also supports computed property names. That allows you to put an expression in square brackets `[]`, that will be computed and used as the property name. This is reminiscent of the bracket notation of the property accessor syntax, which you may have used to read and set properties already.

Now you can use a similar syntax in object literals, too:

 js 

```
// Computed property names
let i = 0;
const a = {
  [`foo${++i}`]: i,
  [`foo${++i}`]: i,
  [`foo${++i}`]: i,
};

console.log(a.foo1); // 1
console.log(a.foo2); // 2
console.log(a.foo3); // 3

const items = ["A", "B", "C"];
const obj = {
  [items]: "Hello",
};
console.log(obj); // A,B,C: "Hello"
console.log(obj["A,B,C"]); // "Hello"

const param = "size";
const config = {
  [param]: 12,
  [`mobile${param.charAt(0).toUpperCase()}${param.slice(1)}`]: 4,
};

console.log(config); // {size: 12, mobileSize: 4}
```

 
 
 

### Spread properties 

 
 

Object literals support the spread syntax . It copies own enumerable properties from a provided object onto a new object.

Shallow-cloning (excluding `prototype`) or merging objects is now possible using a shorter syntax than `Object.assign()` .

 js 

```
const obj1 = { foo: "bar", x: 42 };
const obj2 = { foo: "baz", y: 13 };

const clonedObj = { ...obj1 };
// { foo: "bar", x: 42 }

const mergedObj = { ...obj1, ...obj2 };
// { foo: "baz", x: 42, y: 13 }
```

 
 

 Warning: 
Note that `Object.assign()` triggers setters , whereas the spread syntax doesn't!

 
 
 

### Prototype setter 

 
 

A property definition of the form `__proto__: value` or `"__proto__": value` does not create a property with the name `__proto__`. Instead, if the provided value is an object or `null` , it points the `[[Prototype]]` of the created object to that value. (If the value is not an object or `null`, the object is not changed.)

Note that the `__proto__` key is standardized syntax, in contrast to the non-standard and non-performant `Object.prototype.__proto__` accessors. It sets the `[[Prototype]]` during object creation, similar to `Object.create` — instead of mutating the prototype chain.

 js 

```
const obj1 = {};
console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true

const obj2 = { __proto__: null };
console.log(Object.getPrototypeOf(obj2)); // null

const protoObj = {};
const obj3 = { "__proto__": protoObj };
console.log(Object.getPrototypeOf(obj3) === protoObj); // true

const obj4 = { __proto__: "not an object or null" };
console.log(Object.getPrototypeOf(obj4) === Object.prototype); // true
console.log(Object.hasOwn(obj4, "__proto__")); // false
```

 

Only a single prototype setter is permitted in an object literal. Multiple prototype setters are a syntax error.

Property definitions that do not use "colon" notation are not prototype setters. They are property definitions that behave identically to similar definitions using any other name.

 js 

```
const __proto__ = "variable";

const obj1 = { __proto__ };
console.log(Object.getPrototypeOf(obj1) === Object.prototype); // true
console.log(Object.hasOwn(obj1, "__proto__")); // true
console.log(obj1.__proto__); // "variable"

const obj2 = { __proto__() { return "hello"; } };
console.log(obj2.__proto__()); // "hello"

const obj3 = { ["__proto__"]: 17 };
console.log(obj3.__proto__); // 17

// Mixing prototype setter with normal own properties with "__proto__" key
const obj4 = { ["__proto__"]: 17, __proto__: {} }; // {__proto__: 17} (with {} as prototype)
const obj5 = {
  ["__proto__"]: 17,
  __proto__: {},
  __proto__: null, // SyntaxError: Duplicate __proto__ fields are not allowed in object literals
};
const obj6 = {
  ["__proto__"]: 17,
  ["__proto__"]: "hello",
  __proto__: null,
}; // {__proto__: "hello"} (with null as prototype)
const obj7 =  {
  ["__proto__"]: 17,
  __proto__,
  __proto__: null,
}; // {__proto__: "variable"} (with null as prototype)
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-initializer 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Property accessors 

- `get` 

- `set` 

- Method definitions 

- Lexical grammar 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Working with objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects#using_object_initializers

Working with objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Working with objects

 
 
 
- Previous 
- Next 

JavaScript is designed on an object-based paradigm. An object is a collection of properties , and a property is an association between a name (or key ) and a value. A property's value can be a function, in which case the property is known as a method .

Objects in JavaScript, just as in many other programming languages, can be compared to objects in real life. In JavaScript, an object is a standalone entity, with properties and type. Compare it with a cup, for example. A cup is an object, with properties. A cup has a color, a design, weight, a material it is made of, etc. The same way, JavaScript objects can have properties, which define their characteristics.

In addition to objects that are predefined in the browser, you can define your own objects. This chapter describes how to use objects, properties, and methods, and how to create your own objects.

 
 
 
 
 
 

## Creating new objects 

 
 

You can create an object using an object initializer . Alternatively, you can first create a constructor function and then instantiate an object by invoking that function with the `new` operator.

 
 

### Using object initializers 

 
 

Object initializers are also called object literals . "Object initializer" is consistent with the terminology used by C++.

The syntax for an object using an object initializer is:

 js 

```
const obj = {
  property1: value1, // property name may be an identifier
  2: value2, // or a number
  "property n": value3, // or a string
};
```

 

Each property name before colons is an identifier (either a name, a number, or a string literal), and each `valueN` is an expression whose value is assigned to the property name. The property name can also be an expression; computed keys need to be wrapped in square brackets. The object initializer reference contains a more detailed explanation of the syntax.

In this example, the newly created object is assigned to a variable `obj` — this is optional. If you do not need to refer to this object elsewhere, you do not need to assign it to a variable. (Note that you may need to wrap the object literal in parentheses if the object appears where a statement is expected, so as not to have the literal be confused with a block statement.)

Object initializers are expressions, and each object initializer results in a new object being created whenever the statement in which it appears is executed. Identical object initializers create distinct objects that do not compare to each other as equal.

The following statement creates an object and assigns it to the variable `x` if and only if the expression `cond` is true:

 js 

```
let x;
if (cond) {
  x = { greeting: "hi there" };
}
```

 

The following example creates `myHonda` with three properties. Note that the `engine` property is also an object with its own properties.

 js 

```
const myHonda = {
  color: "red",
  wheels: 4,
  engine: { cylinders: 4, size: 2.2 },
};
```

 

Objects created with initializers are called plain objects , because they are instances of `Object` , but not any other object type. Some object types have special initializer syntaxes — for example, array initializers and regex literals .

 
 

### Using a constructor function 

 
 

Alternatively, you can create an object with these two steps:

- Define the object type by writing a constructor function. There is a strong convention, with good reason, to use a capital initial letter.

- Create an instance of the object with `new` .

To define an object type, create a function for the object type that specifies its name, properties, and methods. For example, suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:

 js 

```
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
```

 

Notice the use of `this` to assign values to the object's properties based on the values passed to the function.

Now you can create an object called `myCar` as follows:

 js 

```
const myCar = new Car("Eagle", "Talon TSi", 1993);
```

 

This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string `"Eagle"`, `myCar.model` is the string `"Talon TSi"`, `myCar.year` is the integer `1993`, and so on. The order of arguments and parameters should be the same.

You can create any number of `Car` objects by calls to `new`. For example,

 js 

```
const randCar = new Car("Nissan", "300ZX", 1992);
const kenCar = new Car("Mazda", "Miata", 1990);
```

 

An object can have a property that is itself another object. For example, suppose you define an object called `Person` as follows:

 js 

```
function Person(name, age, sex) {
  this.name = name;
  this.age = age;
  this.sex = sex;
}
```

 

and then instantiate two new `Person` objects as follows:

 js 

```
const rand = new Person("Rand McKinnon", 33, "M");
const ken = new Person("Ken Jones", 39, "M");
```

 

Then, you can rewrite the definition of `Car` to include an `owner` property that takes a `Person` object, as follows:

 js 

```
function Car(make, model, year, owner) {
  this.make = make;
  this.model = model;
  this.year = year;
  this.owner = owner;
}
```

 

To instantiate the new objects, you then use the following:

 js 

```
const car1 = new Car("Eagle", "Talon TSi", 1993, rand);
const car2 = new Car("Nissan", "300ZX", 1992, ken);
```

 

Notice that instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the arguments for the owners. Then if you want to find out the name of the owner of `car2`, you can access the following property:

 js 

```
car2.owner.name;
```

 

You can always add a property to a previously defined object. For example, the statement

 js 

```
car1.color = "black";
```

 

adds a property `color` to `car1`, and assigns it a value of `"black"`. However, this does not affect any other objects. To add the new property to all objects of the same type, you have to add the property to the definition of the `Car` object type.

You can also use the `class` syntax instead of the `function` syntax to define a constructor function. For more information, see the class guide .

 
 

### Using the Object.create() method 

 
 

Objects can also be created using the `Object.create()` method. This method can be very useful, because it allows you to choose the prototype object for the object you want to create, without having to define a constructor function.

 js 

```
// Animal properties and method encapsulation
const Animal = {
  type: "Invertebrates", // Default value of properties
  displayType() {
    // Method which will display type of Animal
    console.log(this.type);
  },
};

// Create new animal type called `animal`
const animal = Object.create(Animal);
animal.displayType(); // Logs: Invertebrates

// Create new animal type called fish
const fish = Object.create(Animal);
fish.type = "Fishes";
fish.displayType(); // Logs: Fishes
```

 
 
 

## Objects and properties 

 
 

A JavaScript object has properties associated with it. Object properties are basically the same as variables, except that they are associated with objects, not scopes . The properties of an object define the characteristics of the object.

For example, this example creates an object named `myCar`, with properties named `make`, `model`, and `year`, with their values set to `"Ford"`, `"Mustang"`, and `1969`:

 js 

```
const myCar = {
  make: "Ford",
  model: "Mustang",
  year: 1969,
};
```

 

Like JavaScript variables, property names are case sensitive. Property names can only be strings or Symbols — all keys are converted to strings unless they are Symbols. Array indices are, in fact, properties with string keys that contain integers.

 
 

### Accessing properties 

 
 

You can access a property of an object by its property name. Property accessors come in two syntaxes: dot notation and bracket notation . For example, you could access the properties of the `myCar` object as follows:

 js 

```
// Dot notation
myCar.make = "Ford";
myCar.model = "Mustang";
myCar.year = 1969;

// Bracket notation
myCar["make"] = "Ford";
myCar["model"] = "Mustang";
myCar["year"] = 1969;
```

 

An object property name can be any JavaScript string or symbol , including an empty string. However, you cannot use dot notation to access a property whose name is not a valid JavaScript identifier. For example, a property name that has a space or a hyphen, that starts with a number, or that is held inside a variable can only be accessed using the bracket notation. This notation is also very useful when property names are to be dynamically determined, i.e., not determinable until runtime. Examples are as follows:

 js 

```
const myObj = {};
const str = "myString";
const rand = Math.random();
const anotherObj = {};

// Create additional properties on myObj
myObj.type = "Dot syntax for a key named type";
myObj["date created"] = "This key has a space";
myObj[str] = "This key is in variable str";
myObj[rand] = "A random number is the key here";
myObj[anotherObj] = "This key is object anotherObj";
myObj[""] = "This key is an empty string";

console.log(myObj);
// {
//   type: 'Dot syntax for a key named type',
//   'date created': 'This key has a space',
//   myString: 'This key is in variable str',
//   '0.6398914448618778': 'A random number is the key here',
//   '[object Object]': 'This key is object anotherObj',
//   '': 'This key is an empty string'
// }
console.log(myObj.myString); // 'This key is in variable str'
```

 

In the above code, the key `anotherObj` is an object, which is neither a string nor a symbol. When it is added to the `myObj`, JavaScript calls the `toString()` method of `anotherObj`, and use the resulting string as the new key.

You can also access properties with a string value stored in a variable. The variable must be passed in bracket notation. In the example above, the variable `str` held `"myString"` and it is `"myString"` that is the property name. Therefore, `myObj.str` will return as undefined.

 js 

```
str = "myString";
myObj[str] = "This key is in variable str";

console.log(myObj.str); // undefined

console.log(myObj[str]); // 'This key is in variable str'
console.log(myObj.myString); // 'This key is in variable str'
```

 

This allows accessing any property as determined at runtime:

 js 

```
let propertyName = "make";
myCar[propertyName] = "Ford";

// access different properties by changing the contents of the variable
propertyName = "model";
myCar[propertyName] = "Mustang";

console.log(myCar); // { make: 'Ford', model: 'Mustang' }
```

 

However, beware of using square brackets to access properties whose names are given by external input. This may make your code susceptible to object injection attacks .

Nonexistent properties of an object have value `undefined` (and not `null` ).

 js 

```
myCar.nonexistentProperty; // undefined
```

 
 
 

### Enumerating properties 

 
 

There are three native ways to list/traverse object properties:

- `for...in` loops. This method traverses all of the enumerable string properties of an object as well as its prototype chain.

- `Object.keys()` . This method returns an array with only the enumerable own string property names ("keys") in the object `myObj`, but not those in the prototype chain.

- `Object.getOwnPropertyNames()` . This method returns an array containing all the own string property names in the object `myObj`, regardless of if they are enumerable or not.

You can use the bracket notation with `for...in` to iterate over all the enumerable properties of an object. To illustrate how this works, the following function displays the properties of the object when you pass the object and the object's name as arguments to the function:

 js 

```
function showProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    // Object.hasOwn() is used to exclude properties from the object's
    // prototype chain and only show "own properties"
    if (Object.hasOwn(obj, i)) {
      result += `${objName}.${i} = ${obj[i]}\n`;
    }
  }
  console.log(result);
}
```

 

The term "own property" refers to the properties of the object, but excluding those of the prototype chain. So, the function call `showProps(myCar, 'myCar')` would print the following:



```
myCar.make = Ford
myCar.model = Mustang
myCar.year = 1969
```



The above is equivalent to:

 js 

```
function showProps(obj, objName) {
  let result = "";
  Object.keys(obj).forEach((i) => {
    result += `${objName}.${i} = ${obj[i]}\n`;
  });
  console.log(result);
}
```

 

There is no native way to list all inherited properties including non-enumerable ones. However, this can be achieved with the following function:

 js 

```
function listAllProperties(myObj) {
  let objectToInspect = myObj;
  let result = [];

  while (objectToInspect !== null) {
    result = result.concat(Object.getOwnPropertyNames(objectToInspect));
    objectToInspect = Object.getPrototypeOf(objectToInspect);
  }

  return result;
}
```

 

For more information, see Enumerability and ownership of properties .

 
 

### Deleting properties 

 
 

You can remove a non-inherited property using the `delete` operator. The following code shows how to remove a property.

 js 

```
// Creates a new object, myObj, with two properties, a and b.
const myObj = { a: 5, b: 12 };

// Removes the a property, leaving myObj with only the b property.
delete myObj.a;
console.log("a" in myObj); // false
```

 
 
 

## Inheritance 

 
 

All objects in JavaScript inherit from at least one other object. The object being inherited from is known as the prototype, and the inherited properties can be found in the `prototype` object of the constructor. See Inheritance and the prototype chain for more information.

 
 

### Defining properties for all objects of one type 

 
 

You can add a property to all objects created through a certain constructor using the `prototype` property. This defines a property that is shared by all objects of the specified type, rather than by just one instance of the object. The following code adds a `color` property to all objects of type `Car`, and then reads the property's value from an instance `car1`.

 js 

```
Car.prototype.color = "red";
console.log(car1.color); // "red"
```

 
 
 

## Defining methods 

 
 

A method is a function associated with an object, or, put differently, a method is a property of an object that is a function. Methods are defined the way normal functions are defined, except that they have to be assigned as the property of an object. See also method definitions for more details. An example is:

 js 

```
objectName.methodName = functionName;

const myObj = {
  myMethod: function (params) {
    // do something
  },

  // this works too!
  myOtherMethod(params) {
    // do something else
  },
};
```

 

where `objectName` is an existing object, `methodName` is the name you are assigning to the method, and `functionName` is the name of the function.

You can then call the method in the context of the object as follows:

 js 

```
objectName.methodName(params);
```

 

Methods are typically defined on the `prototype` object of the constructor, so that all objects of the same type share the same method. For example, you can define a function that formats and displays the properties of the previously-defined `Car` objects.

 js 

```
Car.prototype.displayCar = function () {
  const result = `A Beautiful ${this.year} ${this.make} ${this.model}`;
  console.log(result);
};
```

 

Notice the use of `this` to refer to the object to which the method belongs. Then you can call the `displayCar` method for each of the objects as follows:

 js 

```
car1.displayCar();
car2.displayCar();
```

 
 
 

### Using this for object references 

 
 

JavaScript has a special keyword, `this` , that you can use within a method to refer to the current object. For example, suppose you have 2 objects, `Manager` and `Intern`. Each object has its own `name`, `age` and `job`. In the function `sayHi()`, notice the use of `this.name`. When added to the 2 objects, the same function will print the message with the name of the respective object it's attached to.

 js 

```
const Manager = {
  name: "Karina",
  age: 27,
  job: "Software Engineer",
};
const Intern = {
  name: "Tyrone",
  age: 21,
  job: "Software Engineer Intern",
};

function sayHi() {
  console.log(`Hello, my name is ${this.name}`);
}

// add sayHi function to both objects
Manager.sayHi = sayHi;
Intern.sayHi = sayHi;

Manager.sayHi(); // Hello, my name is Karina
Intern.sayHi(); // Hello, my name is Tyrone
```

 

`this` is a "hidden parameter" of a function call that's passed in by specifying the object before the function that was called. For example, in `Manager.sayHi()`, `this` is the `Manager` object, because `Manager` comes before the function `sayHi()`. If you access the same function from another object, `this` will change as well. If you use other methods to call the function, like `Function.prototype.call()` or `Reflect.apply()` , you can explicitly pass the value of `this` as an argument.

 
 

## Defining getters and setters 

 
 

A getter is a function associated with a property that gets the value of a specific property. A setter is a function associated with a property that sets the value of a specific property. Together, they can indirectly represent the value of a property.

Getters and setters can be either

- defined within object initializers , or

- added later to any existing object.

Within object initializers , getters and setters are defined like regular methods , but prefixed with the keywords `get` or `set`. The getter method must not expect a parameter, while the setter method expects exactly one parameter (the new value to set). For instance:

 js 

```
const myObj = {
  a: 7,
  get b() {
    return this.a + 1;
  },
  set c(x) {
    this.a = x / 2;
  },
};

console.log(myObj.a); // 7
console.log(myObj.b); // 8, returned from the get b() method
myObj.c = 50; // Calls the set c(x) method
console.log(myObj.a); // 25
```

 

The `myObj` object's properties are:

- `myObj.a` — a number

- `myObj.b` — a getter that returns `myObj.a` plus 1

- `myObj.c` — a setter that sets the value of `myObj.a` to half of the value `myObj.c` is being set to

Getters and setters can also be added to an object at any time after creation using the `Object.defineProperties()` method. This method's first parameter is the object on which you want to define the getter or setter. The second parameter is an object whose property names are the getter or setter names, and whose property values are objects for defining the getter or setter functions. Here's an example that defines the same getter and setter used in the previous example:

 js 

```
const myObj = { a: 0 };

Object.defineProperties(myObj, {
  b: {
    get() {
      return this.a + 1;
    },
  },
  c: {
    set(x) {
      this.a = x / 2;
    },
  },
});

myObj.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property
console.log(myObj.b); // Runs the getter, which yields a + 1 or 6
```

 

Which of the two forms to choose depends on your programming style and task at hand. If you can change the definition of the original object, you will probably define getters and setters through the original initializer. This form is more compact and natural. However, if you need to add getters and setters later — maybe because you did not write the particular object — then the second form is the only possible form. The second form better represents the dynamic nature of JavaScript, but it can make the code hard to read and understand.

 
 

## Comparing objects 

 
 

In JavaScript, objects are a reference type. Two distinct objects are never equal, even if they have the same properties. Only comparing the same object reference with itself yields true.

 js 

```
// Two variables, two distinct objects with the same properties
const fruit = { name: "apple" };
const anotherFruit = { name: "apple" };

fruit == anotherFruit; // return false
fruit === anotherFruit; // return false
```

 
 js 

```
// Two variables, a single object
const fruit = { name: "apple" };
const anotherFruit = fruit; // Assign fruit object reference to anotherFruit

// Here fruit and anotherFruit are pointing to same object
fruit == anotherFruit; // return true
fruit === anotherFruit; // return true

fruit.name = "grape";
console.log(anotherFruit); // { name: "grape" }; not { name: "apple" }
```

 

For more information about comparison operators, see equality operators .

 
 

## See also 

 
 

- Inheritance and the prototype chain 

- Classes 

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Aug 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Object - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object

Object - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Object

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `Object` type represents one of JavaScript's data types . It is used to store various keyed collections and more complex entities. Objects can be created using the `Object()` constructor or the object initializer / literal syntax .

 
 
 
 
 
 

## Description 

 
 

Nearly all objects in JavaScript are instances of `Object`; a typical object inherits properties (including methods) from `Object.prototype`, although these properties may be shadowed (a.k.a. overridden). The only objects that don't inherit from `Object.prototype` are those with `null` prototype , or descended from other `null` prototype objects.

Changes to the `Object.prototype` object are seen by all objects through prototype chaining, unless the properties and methods subject to those changes are overridden further along the prototype chain. This provides a very powerful although potentially dangerous mechanism to override or extend object behavior. To make it more secure, `Object.prototype` is the only object in the core JavaScript language that has immutable prototype — the prototype of `Object.prototype` is always `null` and not changeable.

 
 

### Object prototype properties 

 
 

You should avoid calling any of the `Object.prototype` methods directly from the instance, especially those that are not intended to be polymorphic (i.e., only its initial behavior makes sense and no descending object could override it in a meaningful way). All objects descending from `Object.prototype` may define a custom own property that has the same name, but with entirely different semantics from what you expect. Furthermore, these properties are not inherited by `null`-prototype objects . All modern JavaScript utilities for working with objects are static . More specifically:

- `valueOf()` , `toString()` , and `toLocaleString()` exist to be polymorphic and you should expect the object to define its own implementation with sensible behaviors, so you can call them as instance methods. However, `valueOf()` and `toString()` are usually implicitly called through type conversion and you don't need to call them yourself in your code.

- `__defineGetter__()` , `__defineSetter__()` , `__lookupGetter__()` , and `__lookupSetter__()` are deprecated and should not be used. Use the static alternatives `Object.defineProperty()` and `Object.getOwnPropertyDescriptor()` instead.

- The `__proto__` property is deprecated and should not be used. The `Object.getPrototypeOf()` and `Object.setPrototypeOf()` alternatives are static methods.

- The `propertyIsEnumerable()` and `hasOwnProperty()` methods can be replaced with the `Object.getOwnPropertyDescriptor()` and `Object.hasOwn()` static methods, respectively.

- The `isPrototypeOf()` method can usually be replaced with `instanceof` , if you are checking the `prototype` property of a constructor.

In case where a semantically equivalent static method doesn't exist, or if you really want to use the `Object.prototype` method, you should directly `call()` the `Object.prototype` method on your target object instead, to prevent the object from having an overriding property that produces unexpected results.

 js 

```
const obj = {
  foo: 1,
  // You should not define such a method on your own object,
  // but you may not be able to prevent it from happening if
  // you are receiving the object from external input
  propertyIsEnumerable() {
    return false;
  },
};

obj.propertyIsEnumerable("foo"); // false; unexpected result
Object.prototype.propertyIsEnumerable.call(obj, "foo"); // true; expected result
```

 
 
 

### Deleting a property from an object 

 
 

There isn't any method in an Object itself to delete its own properties (such as `Map.prototype.delete()` ). To do so, one must use the `delete` operator.

 
 

### null-prototype objects 

 
 

Almost all objects in JavaScript ultimately inherit from `Object.prototype` (see inheritance and the prototype chain ). However, you may create `null`-prototype objects using `Object.create(null)` or the object initializer syntax with `__proto__: null` (note: the `__proto__` key in object literals is different from the deprecated `Object.prototype.__proto__` property). You can also change the prototype of an existing object to `null` by calling `Object.setPrototypeOf(obj, null)` .

 js 

```
const obj = Object.create(null);
const obj2 = { __proto__: null };
```

 

An object with a `null` prototype can behave in unexpected ways, because it doesn't inherit any object methods from `Object.prototype`. This is especially true when debugging, since common object-property converting/detecting utility functions may generate errors, or lose information (especially if using silent error-traps that ignore errors).

For example, the lack of `Object.prototype.toString()` often makes debugging intractable:

 js 

```
const normalObj = {}; // create a normal object
const nullProtoObj = Object.create(null); // create an object with "null" prototype

console.log(`normalObj is: ${normalObj}`); // shows "normalObj is: [object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // throws error: Cannot convert object to primitive value

alert(normalObj); // shows [object Object]
alert(nullProtoObj); // throws error: Cannot convert object to primitive value
```

 

Other methods will fail as well.

 js 

```
normalObj.valueOf(); // shows {}
nullProtoObj.valueOf(); // throws error: nullProtoObj.valueOf is not a function

normalObj.hasOwnProperty("p"); // shows "true"
nullProtoObj.hasOwnProperty("p"); // throws error: nullProtoObj.hasOwnProperty is not a function

normalObj.constructor; // shows "Object() { [native code] }"
nullProtoObj.constructor; // shows "undefined"
```

 

We can add the `toString` method back to the null-prototype object by assigning it one:

 js 

```
nullProtoObj.toString = Object.prototype.toString; // since new object lacks toString, add the original generic one back

console.log(nullProtoObj.toString()); // shows "[object Object]"
console.log(`nullProtoObj is: ${nullProtoObj}`); // shows "nullProtoObj is: [object Object]"
```

 

Unlike normal objects, in which `toString()` is on the object's prototype, the `toString()` method here is an own property of `nullProtoObj`. This is because `nullProtoObj` has no (`null`) prototype.

You can also revert a null-prototype object back to an ordinary object using 

```
Object.setPrototypeOf(nullProtoObj, Object.prototype)
```

 .

In practice, objects with `null` prototype are usually used as a cheap substitute for maps . The presence of `Object.prototype` properties will cause some bugs:

 js 

```
const ages = { alice: 18, bob: 27 };

function hasPerson(name) {
  return name in ages;
}

function getAge(name) {
  return ages[name];
}

hasPerson("hasOwnProperty"); // true
getAge("toString"); // [Function: toString]
```

 

Using a null-prototype object removes this hazard without introducing too much complexity to the `hasPerson` and `getAge` functions:

 js 

```
const ages = Object.create(null, {
  alice: { value: 18, enumerable: true },
  bob: { value: 27, enumerable: true },
});

hasPerson("hasOwnProperty"); // false
getAge("toString"); // undefined
```

 

In such case, the addition of any method should be done cautiously, as they can be confused with the other key-value pairs stored as data.

Making your object not inherit from `Object.prototype` also prevents prototype pollution attacks . If a malicious script adds a property to `Object.prototype`, it will be accessible on every object in your program, except objects that have null prototype.

 js 

```
const user = {};

// A malicious script:
Object.prototype.authenticated = true;

// Unexpectedly allowing unauthenticated user to pass through
if (user.authenticated) {
  // access confidential data
}
```

 

JavaScript also has built-in APIs that produce `null`-prototype objects, especially those that use objects as ad hoc key-value collections. For example:

- The return value of `Object.groupBy()` 

- The `groups` and `indices.groups` properties of the result of `RegExp.prototype.exec()` 

- `Array.prototype[Symbol.unscopables]` (all `[Symbol.unscopables]` objects should have `null`-prototype)

- `import.meta` 

- Module namespace objects, obtained through `import * as ns from "module";` or `import()` 

The term "`null`-prototype object" often also includes any object without `Object.prototype` in its prototype chain. Such objects can be created with `extends null` when using classes.

 
 

### Object coercion 

 
 

Many built-in operations that expect objects first coerce their arguments to objects. The operation can be summarized as follows:

- Objects are returned as-is.

- `undefined` and `null` throw a `TypeError` .

- `Number` , `String` , `Boolean` , `Symbol` , `BigInt` primitives are wrapped into their corresponding object wrappers.

There are two ways to achieve nearly the same effect in JavaScript.

- `Object.prototype.valueOf()` : `Object.prototype.valueOf.call(x)` does exactly the object coercion steps explained above to convert `x`.

- The `Object()` function: `Object(x)` uses the same algorithm to convert `x`, except that `undefined` and `null` don't throw a `TypeError` , but return a plain object.

Places that use object coercion include:

- The `object` parameter of `for...in` loops.

- The `this` value of `Array` methods.

- Parameters of `Object` methods such as `Object.keys()` .

- Auto-boxing when a property is accessed on a primitive value, since primitives do not have properties.

- The `this` value when calling a non-strict function. Primitives are boxed while `null` and `undefined` are replaced with the global object .

Unlike conversion to primitives , the object coercion process itself is not observable in any way, since it doesn't invoke custom code like `toString` or `valueOf` methods.

 
 

## Constructor 

 
 
 `Object()` 
 

Turns the input into an object.

 
 
 
 

## Static methods 

 
 
 `Object.assign()` 
 

Copies the values of all enumerable own properties from one or more source objects to a target object.

 
 `Object.create()` 
 

Creates a new object with the specified prototype object and properties.

 
 `Object.defineProperties()` 
 

Adds the named properties described by the given descriptors to an object.

 
 `Object.defineProperty()` 
 

Adds the named property described by a given descriptor to an object.

 
 `Object.entries()` 
 

Returns an array containing all of the `[key, value]` pairs of a given object's own enumerable string properties.

 
 `Object.freeze()` 
 

Freezes an object. Other code cannot delete or change its properties.

 
 `Object.fromEntries()` 
 

Returns a new object from an iterable of `[key, value]` pairs. (This is the reverse of `Object.entries` ).

 
 `Object.getOwnPropertyDescriptor()` 
 

Returns a property descriptor for a named property on an object.

 
 `Object.getOwnPropertyDescriptors()` 
 

Returns an object containing all own property descriptors for an object.

 
 `Object.getOwnPropertyNames()` 
 

Returns an array containing the names of all of the given object's own enumerable and non-enumerable properties.

 
 `Object.getOwnPropertySymbols()` 
 

Returns an array of all symbol properties found directly upon a given object.

 
 `Object.getPrototypeOf()` 
 

Returns the prototype (internal `[[Prototype]]` property) of the specified object.

 
 `Object.groupBy()` 
 

Groups the elements of a given iterable according to the string values returned by a provided callback function. The returned object has separate properties for each group, containing arrays with the elements in the group.

 
 `Object.hasOwn()` 
 

Returns `true` if the specified object has the indicated property as its own property, or `false` if the property is inherited or does not exist.

 
 `Object.is()` 
 

Compares if two values are the same value. Equates all `NaN` values (which differs from both `IsLooselyEqual` used by `==` and `IsStrictlyEqual` used by `===` ).

 
 `Object.isExtensible()` 
 

Determines if extending of an object is allowed.

 
 `Object.isFrozen()` 
 

Determines if an object was frozen.

 
 `Object.isSealed()` 
 

Determines if an object is sealed.

 
 `Object.keys()` 
 

Returns an array containing the names of all of the given object's own enumerable string properties.

 
 `Object.preventExtensions()` 
 

Prevents any extensions of an object.

 
 `Object.seal()` 
 

Prevents other code from deleting properties of an object.

 
 `Object.setPrototypeOf()` 
 

Sets the object's prototype (its internal `[[Prototype]]` property).

 
 `Object.values()` 
 

Returns an array containing the values that correspond to all of a given object's own enumerable string properties.

 
 
 
 

## Instance properties 

 
 

These properties are defined on `Object.prototype` and shared by all `Object` instances.

 
 `Object.prototype.__proto__` 
 Deprecated 
 
 

Points to the object which was used as prototype when the object was instantiated.

 
 `Object.prototype.constructor` 
 

The constructor function that created the instance object. For plain `Object` instances, the initial value is the `Object` constructor. Instances of other constructors each inherit the `constructor` property from their respective `Constructor.prototype` object.

 
 
 
 

## Instance methods 

 
 
 `Object.prototype.__defineGetter__()` 
 Deprecated 
 
 

Associates a function with a property that, when accessed, executes that function and returns its return value.

 
 `Object.prototype.__defineSetter__()` 
 Deprecated 
 
 

Associates a function with a property that, when set, executes that function which modifies the property.

 
 `Object.prototype.__lookupGetter__()` 
 Deprecated 
 
 

Returns the function bound as a getter to the specified property.

 
 `Object.prototype.__lookupSetter__()` 
 Deprecated 
 
 

Returns the function bound as a setter to the specified property.

 
 `Object.prototype.hasOwnProperty()` 
 

Returns a boolean indicating whether an object contains the specified property as a direct property of that object and not inherited through the prototype chain.

 
 `Object.prototype.isPrototypeOf()` 
 

Returns a boolean indicating whether the object this method is called upon is in the prototype chain of the specified object.

 
 `Object.prototype.propertyIsEnumerable()` 
 

Returns a boolean indicating whether the specified property is the object's enumerable own property.

 
 `Object.prototype.toLocaleString()` 
 

Calls `toString()` .

 
 `Object.prototype.toString()` 
 

Returns a string representation of the object.

 
 `Object.prototype.valueOf()` 
 

Returns the primitive value of the specified object.

 
 
 
 

## Examples 

 
 
 
 

### Constructing empty objects 

 
 

The following example creates empty objects using the `new` keyword with different arguments:

 js 

```
const o1 = new Object();
const o2 = new Object(undefined);
const o3 = new Object(null);
```

 
 
 

### Using Object() constructor to turn primitives into an Object of their respective type 

 
 

You can use the `Object()` constructor to create an object wrapper of a primitive value.

The following examples create variables `o1` and `o2` which are objects storing `Boolean` and `BigInt` values:

 js 

```
// Equivalent to const o1 = new Boolean(true)
const o1 = new Object(true);

// No equivalent because BigInt() can't be called as a constructor,
// and calling it as a regular function won't create an object
const o2 = new Object(1n);
```

 
 
 

### Object prototypes 

 
 

When altering the behavior of existing `Object.prototype` methods, consider injecting code by wrapping your extension before or after the existing logic. For example, this (untested) code will pre-conditionally execute custom logic before the built-in logic or someone else's extension is executed.

When modifying prototypes with hooks, pass `this` and the arguments (the call state) to the current behavior by calling `apply()` on the function. This pattern can be used for any prototype, such as `Node.prototype`, `Function.prototype`, etc.

 js 

```
const current = Object.prototype.valueOf;

// Since my property "-prop-value" is cross-cutting and isn't always
// on the same prototype chain, I want to modify Object.prototype:
Object.prototype.valueOf = function (...args) {
  if (Object.hasOwn(this, "-prop-value")) {
    return this["-prop-value"];
  }
  // It doesn't look like one of my objects, so let's fall back on
  // the default behavior by reproducing the current behavior as best we can.
  // The apply behaves like "super" in some other languages.
  // Even though valueOf() doesn't take arguments, some other hook may.
  return current.apply(this, args);
};
```

 
 

 Warning: 
Modifying the `prototype` property of any built-in constructor is considered a bad practice and risks forward compatibility.

 

You can read more about prototypes in Inheritance and the prototype chain .

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-object-objects 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Object initializer 

- Prototype pollution attack 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 17, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Grammar and types - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#array_literals

Grammar and types - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Grammar and types

 
 
 
- Previous 
- Next 

This chapter discusses JavaScript's basic grammar, variable declarations, data types and literals.

 
 
 
 
 
 

## Basics 

 
 

JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.

JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.

 js 

```
const Früh = "foobar";
```

 

But, the variable `früh` is not the same as `Früh` because JavaScript is case sensitive.

In JavaScript, instructions are called statements and are separated by semicolons (;).

A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.

 

 Note: 
ECMAScript also has rules for automatic insertion of semicolons ( ASI ) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar .)

 

It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.

The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens , control characters , line terminators , comments , or whitespace . (Spaces, tabs, and newline characters are considered whitespace.)

 
 

## Comments 

 
 

The syntax of comments is the same as in C++ and in many other languages:

 js 

```
// a one line comment

/* this is a longer,
 * multi-line comment
 */
```

 

You can't nest block comments. This often happens when you accidentally include a `*/` sequence in your comment, which will terminate the comment.

 js 

```
/* You can't, however, /* nest comments */ SyntaxError */
```

 

In this case, you need to break up the `*/` pattern. For example, by inserting a backslash:

 js 

```
/* You can /* nest comments *\/ by escaping slashes */
```

 

Comments behave like whitespace, and are discarded during script execution.

 

 Note: 
You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: `#!/usr/bin/env node`.

This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.

 
 
 

## Declarations 

 
 

JavaScript has three kinds of variable declarations.

 
 `var` 
 

Declares a variable, optionally initializing it to a value.

 
 `let` 
 

Declares a block-scoped, local variable, optionally initializing it to a value.

 
 `const` 
 

Declares a block-scoped, read-only named constant.

 
 
 
 

### Variables 

 
 

You use variables as symbolic names for values in your application. The names of variables, called identifiers , conform to certain rules.

A JavaScript identifier usually starts with a letter, underscore (`_`), or dollar sign (`$`). Subsequent characters can also be digits (`0` – `9`). Because JavaScript is case sensitive, letters include the characters `A` through `Z` (uppercase) as well as `a` through `z` (lowercase).

You can use most Unicode letters such as `å` and `ü` in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.

Some examples of legal names are `Number_hits`, `temp99`, `$credit`, and `_name`.

 
 

### Declaring variables 

 
 

You can declare a variable in two ways:

- With the keyword `var` . For example, `var x = 42`. This syntax can be used to declare both local and global variables, depending on the execution context .

- With the keyword `const` or `let` . For example, `let y = 13`. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)

You can declare variables to unpack values using the destructuring syntax. For example, `const { bar } = foo`. This will create a variable named `bar` and assign to it the value corresponding to the key of the same name from our object `foo`.

Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.

 
 

### Declaration and initialization 

 
 

In a statement like `let x = 42`, the `let x` part is called a declaration , and the `= 42` part is called an initializer . The declaration allows the variable to be accessed later in code without throwing a `ReferenceError` , while the initializer assigns a value to the variable. In `var` and `let` declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value `undefined` .

 js 

```
let x;
console.log(x); // logs "undefined"
```

 

In essence, `let x = 42` is equivalent to `let x; x = 42`.

`const` declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with `undefined` is likely a programmer mistake.

 js 

```
const x; // SyntaxError: Missing initializer in const declaration
```

 
 
 

### Variable scope 

 
 

A variable may belong to one of the following scopes :

- Global scope: The default scope for all code running in script mode.

- Module scope: The scope for code running in module mode.

- Function scope: The scope created with a function .

In addition, variables declared with `let` or `const` can belong to an additional scope:

- Block scope: The scope created with a pair of curly braces (a block ).

When you declare a variable outside of any function, it is called a global variable, because it is available to any other code in the current document. When you declare a variable within a function, it is called a local variable, because it is available only within that function.

`let` and `const` declarations can also be scoped to the block statement that they are declared in.

 js 

```
if (Math.random() > 0.5) {
  const y = 5;
}
console.log(y); // ReferenceError: y is not defined
```

 

However, variables created with `var` are not block-scoped, but only local to the function (or global scope) that the block resides within.

For example, the following code will log `5`, because the scope of `x` is the global context (or the function context if the code is part of a function). The scope of `x` is not limited to the immediate `if` statement block.

 js 

```
if (true) {
  var x = 5;
}
console.log(x); // x is 5
```

 
 
 

### Variable hoisting 

 
 

`var`-declared variables are hoisted , meaning you can refer to the variable anywhere in its scope, even if its declaration isn't reached yet. You can see `var` declarations as being "lifted" to the top of its function or global scope. However, if you access a variable before it's declared, the value is always `undefined`, because only its declaration and default initialization (with `undefined`) is hoisted, but not its value assignment .

 js 

```
console.log(x === undefined); // true
var x = 3;

(function () {
  console.log(x); // undefined
  var x = "local value";
})();
```

 

The above examples will be interpreted the same as:

 js 

```
var x;
console.log(x === undefined); // true
x = 3;

(function () {
  var x;
  console.log(x); // undefined
  x = "local value";
})();
```

 

Because of hoisting, all `var` statements in a function should be placed as near to the top of the function as possible. This best practice increases the clarity of the code.

Whether `let` and `const` are hoisted is a matter of definition debate. Referencing the variable in the block before the variable declaration always results in a `ReferenceError` , because the variable is in a " temporal dead zone " from the start of the block until the declaration is processed.

 js 

```
console.log(x); // ReferenceError
const x = 3;

console.log(y); // ReferenceError
let y = 3;
```

 

Unlike `var` declarations, which only hoist the declaration but not its value, function declarations are hoisted entirely — you can safely call the function anywhere in its scope. See the hoisting glossary entry for more discussion.

 
 

### Global variables 

 
 

Global variables are in fact properties of the global object .

In web pages, the global object is `window` , so you can read and set global variables using the `window.variable` syntax. In all environments, the `globalThis` variable (which itself is a global variable) may be used to read and set global variables. This is to provide a consistent interface among various JavaScript runtimes.

Consequently, you can access global variables declared in one window or frame from another window or frame by specifying the `window` or `frame` name. For example, if a variable called `phoneNumber` is declared in a document, you can refer to this variable from an `iframe` as `parent.phoneNumber`.

 
 

### Constants 

 
 

You can create a read-only, named constant with the `const` keyword. The syntax of a constant identifier is the same as any variable identifier: it must start with a letter, underscore, or dollar sign (`$`), and can contain alphabetic, numeric, or underscore characters.

 js 

```
const PI = 3.14;
```

 

A constant cannot change value through assignment or be re-declared while the script is running. It must be initialized to a value. The scope rules for constants are the same as those for `let` block-scope variables.

You cannot declare a constant with the same name as a function or variable in the same scope. For example:

 js 

```
// THIS WILL CAUSE AN ERROR
function f() {}
const f = 5;

// THIS WILL CAUSE AN ERROR TOO
function f() {
  const g = 5;
  var g;
}
```

 

However, `const` only prevents re-assignments , but doesn't prevent mutations . The properties of objects assigned to constants are not protected, so the following statement is executed without problems.

 js 

```
const MY_OBJECT = { key: "value" };
MY_OBJECT.key = "otherValue";
```

 

Also, the contents of an array are not protected, so the following statement is executed without problems.

 js 

```
const MY_ARRAY = ["HTML", "CSS"];
MY_ARRAY.push("JAVASCRIPT");
console.log(MY_ARRAY); // ['HTML', 'CSS', 'JAVASCRIPT'];
```

 
 
 

## Data structures and types 

 
 
 
 

### Data types 

 
 

The latest ECMAScript standard defines eight data types:

- 

Seven data types that are primitives :

 Boolean . `true` and `false`.

- null . A special keyword denoting a null value. (Because JavaScript is case-sensitive, `null` is not the same as `Null`, `NULL`, or any other variant.)

- undefined . A top-level property whose value is not defined.

- Number . An integer or floating point number. For example: `42` or `3.14159`.

- BigInt . An integer with arbitrary precision. For example: `9007199254740992n`.

- String . A sequence of characters that represent a text value. For example: `"Howdy"`.

- Symbol . A data type whose instances are unique and immutable.

 
- 

and Object 

Although these data types are relatively few, they enable you to perform useful operations with your applications. Functions are the other fundamental elements of the language. While functions are technically a kind of object, you can think of objects as named containers for values, and functions as procedures that your script can perform.

 
 

### Data type conversion 

 
 

JavaScript is a dynamically typed language. This means you don't have to specify the data type of a variable when you declare it. It also means that data types are automatically converted as-needed during script execution.

So, for example, you could define a variable as follows:

 js 

```
let answer = 42;
```

 

And later, you could assign the same variable a string value, for example:

 js 

```
answer = "Thanks for all the fish!";
```

 

Because JavaScript is dynamically typed, this assignment does not cause an error message.

 
 

### Numbers and the '+' operator 

 
 

In expressions involving numeric and string values with the `+` operator, JavaScript converts numeric values to strings. For example, consider the following statements:

 js 

```
x = "The answer is " + 42; // "The answer is 42"
y = 42 + " is the answer"; // "42 is the answer"
z = "37" + 7; // "377"
```

 

With all other operators, JavaScript does not convert numeric values to strings. For example:

 js 

```
"37" - 7; // 30
"37" * 7; // 259
```

 
 
 

### Converting strings to numbers 

 
 

In the case that a value representing a number is in memory as a string, there are methods for conversion.

- `parseInt()` 

- `parseFloat()` 

- `Number()` 

`parseInt` only returns whole numbers, so its use is diminished for decimals.

 

 Note: 
Additionally, a best practice for `parseInt` is to always include the radix parameter. The radix parameter is used to specify which numerical system is to be used.

 
 js 

```
parseInt("101", 2); // 5
```

 

An alternative method of retrieving a number from a string is with the `+` (unary plus) operator. This implicitly performs number conversion , which is the same process as the `Number()` function.

 js 

```
"1.1" + "1.1"; // '1.11.1'
(+"1.1") + (+"1.1"); // 2.2
// Note: the parentheses are added for clarity, not required.
```

 
 
 

## Literals 

 
 

 Literals represent values in JavaScript. These are fixed values—not variables—that you literally provide in your script. This section describes the following types of literals:

- Array literals 

- Boolean literals 

- Numeric literals 

- Object literals 

- RegExp literals 

- String literals 

 
 

### Array literals 

 
 

An array literal is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets (`[]`). When you create an array using an array literal, it is initialized with the specified values as its elements, and its `length` is set to the number of arguments specified.

The following example creates the `coffees` array with three elements and a `length` of three:

 js 

```
const coffees = ["French Roast", "Colombian", "Kona"];
```

 

An array literal creates a new array object every time the literal is evaluated. For example, an array defined with a literal in the global scope is created once when the script loads. However, if the array literal is inside a function, a new array is instantiated every time that function is called.

 

 Note: 
Array literals create `Array` objects. See `Array` and Indexed collections for details on `Array` objects.

 

#### Extra commas in array literals

If you put two commas in a row in an array literal, the array leaves an empty slot for the unspecified element. The following example creates the `fish` array:

 js 

```
const fish = ["Lion", , "Angel"];
```

 

When you log this array, you will see:

 js 

```
console.log(fish);
// [ 'Lion', <1 empty item>, 'Angel' ]
```

 

Note that the second item is "empty", which is not exactly the same as the actual `undefined` value. When using array-traversing methods like `Array.prototype.map` , empty slots are skipped. However, index-accessing `fish[1]` still returns `undefined`.

If you include a trailing comma at the end of the list of elements, the comma is ignored.

In the following example, the `length` of the array is three. There is no `myList[3]` and `myList[1]` is empty. All other commas in the list indicate a new element.

 js 

```
const myList = ["home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[0]` and `myList[2]` are missing.

 js 

```
const myList = [, "home", , "school"];
```

 

In the following example, the `length` of the array is four, and `myList[1]` and `myList[3]` are missing. Only the last comma is ignored. 

 js 

```
const myList = ["home", , "school", ,];
```

 
 

 Note: 
 Trailing commas help keep git diffs clean when you have a multi-line array, because appending an item to the end only adds one line, but does not modify the previous line.

 diff 

```
const myList = [
  "home",
  "school",
+ "hospital",
];
```

 
 

Understanding the behavior of extra commas is important to understanding JavaScript as a language.

However, when writing your own code, you should explicitly declare the missing elements as `undefined`, or at least insert a comment to highlight its absence. Doing this increases your code's clarity and maintainability.

 js 

```
const myList = ["home", /* empty */, "school", /* empty */, ];
```

 
 
 

### Boolean literals 

 
 

The Boolean type has two literal values: `true` and `false`.

 

 Note: 
Do not confuse the primitive Boolean values `true` and `false` with the true and false values of the `Boolean` object.

The Boolean object is a wrapper around the primitive Boolean data type. See `Boolean` for more information.

 
 
 

### Numeric literals 

 
 

JavaScript numeric literals include integer literals in different bases as well as floating-point literals in base-10.

Note that the language specification requires numeric literals to be unsigned. Nevertheless, code fragments like `-123.4` are fine, being interpreted as a unary `-` operator applied to the numeric literal `123.4`.

#### Integer literals

Integer and `BigInt` literals can be written in decimal (base 10), hexadecimal (base 16), octal (base 8) and binary (base 2).

- A decimal integer literal is a sequence of digits without a leading `0` (zero).

- A leading `0` (zero) on an integer literal, or a leading `0o` (or `0O`) indicates it is in octal . Octal integer literals can include only the digits `0` – `7`.

- A leading `0x` (or `0X`) indicates a hexadecimal integer literal. Hexadecimal integers can include digits (`0` – `9`) and the letters `a` – `f` and `A` – `F`. (The case of a character does not change its value. Therefore: `0xa` = `0xA` = `10` and `0xf` = `0xF` = `15`.)

- A leading `0b` (or `0B`) indicates a binary integer literal. Binary integer literals can only include the digits `0` and `1`.

- A trailing `n` suffix on an integer literal indicates a `BigInt` literal. The `BigInt` literal can use any of the above bases. Note that leading-zero octal syntax like `0123n` is not allowed, but `0o123n` is fine.

Some examples of integer literals are:



```
0, 117, 123456789123456789n             (decimal, base 10)
015, 0001, 0o777777777777n              (octal, base 8)
0x1123, 0x00111, 0x123456789ABCDEFn     (hexadecimal, "hex" or base 16)
0b11, 0b0011, 0b11101001010101010101n   (binary, base 2)
```



For more information, see Numeric literals in the Lexical grammar reference .

#### Floating-point literals

A floating-point literal can have the following parts:

- An unsigned decimal integer,

- A decimal point (`.`),

- A fraction (another decimal number),

- An exponent.

The exponent part is an `e` or `E` followed by an integer, which can be signed (preceded by `+` or `-`). A floating-point literal must have at least one digit, and either a decimal point or `e` (or `E`).

More succinctly, the syntax is:



```
[digits].[digits][(E|e)[(+|-)]digits]
```



For example:

 js 

```
3.1415926
.123456789
3.1E+12
.1e-23
```

 
 
 

### Object literals 

 
 

An object literal is a list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`).

 

 Warning: 
Do not use an object literal at the beginning of a statement! This will lead to an error (or not behave as you expect), because the `{` will be interpreted as the beginning of a block.

 

The following is an example of an object literal. The first element of the `car` object defines a property, `myCar`, and assigns to it a new string, `"Saturn"`; the second element, the `getCar` property, is immediately assigned the result of invoking the function `(carTypes("Honda"))`; the third element, the `special` property, uses an existing variable (`sales`).

 js 

```
const sales = "Toyota";

function carTypes(name) {
  return name === "Honda" ? name : `Sorry, we don't sell ${name}.`;
}

const car = { myCar: "Saturn", getCar: carTypes("Honda"), special: sales };

console.log(car.myCar); // Saturn
console.log(car.getCar); // Honda
console.log(car.special); // Toyota
```

 

Additionally, you can use a numeric or string literal for the name of a property or nest an object inside another. The following example uses these options.

 js 

```
const car = { manyCars: { a: "Saab", b: "Jeep" }, 7: "Mazda" };

console.log(car.manyCars.b); // Jeep
console.log(car[7]); // Mazda
```

 

Object property names can be any string, including the empty string. If the property name would not be a valid JavaScript identifier or number, it must be enclosed in quotes.

Property names that are not valid identifiers cannot be accessed as a dot (`.`) property.

 js 

```
const unusualPropertyNames = {
  "": "An empty string",
  "!": "Bang!",
};
console.log(unusualPropertyNames.""); // SyntaxError: Unexpected string
console.log(unusualPropertyNames.!); // SyntaxError: Unexpected token !
```

 

Instead, they must be accessed with the bracket notation (`[]`).

 js 

```
console.log(unusualPropertyNames[""]); // An empty string
console.log(unusualPropertyNames["!"]); // Bang!
```

 

#### Enhanced Object literals

Object literals support a range of shorthand syntaxes that include setting the prototype at construction, shorthand for `foo: foo` assignments, defining methods, making `super` calls, and computing property names with expressions.

Together, these also bring object literals and class declarations closer together, and allow object-based design to benefit from some of the same conveniences.

 js 

```
const obj = {
  // __proto__
  __proto__: theProtoObj,
  // Shorthand for 'handler: handler'
  handler,
  // Methods
  toString() {
    // Super calls
    return `d ${super.toString()}`;
  },
  // Computed (dynamic) property names
  ["prop_" + (() => 42)()]: 42,
};
```

 
 
 

### RegExp literals 

 
 

A regex literal (which is defined in detail later ) is a pattern enclosed between slashes. The following is an example of a regex literal.

 js 

```
const re = /ab+c/;
```

 
 
 

### String literals 

 
 

A string literal is zero or more characters enclosed in double (`"`) or single (`'`) quotation marks. A string must be delimited by quotation marks of the same type (that is, either both single quotation marks, or both double quotation marks).

The following are examples of string literals:

 js 

```
'foo'
"bar"
'1234'
'one line \n another line'
"Joyo's cat"
```

 

You should use string literals unless you specifically need to use a `String` object. See `String` for details on `String` objects.

You can call any of the `String` object's methods on a string literal value. JavaScript automatically converts the string literal to a temporary String object, calls the method, then discards the temporary String object. You can also use the `length` property with a string literal:

 js 

```
// Will print the number of symbols in the string including whitespace.
console.log("Joyo's cat".length); // In this case, 10.
```

 

 Template literals are also available. Template literals are enclosed by the back-tick (```) ( grave accent ) character instead of double or single quotes.

Template literals provide syntactic sugar for constructing strings. (This is similar to string interpolation features in Perl, Python, and more.)

 js 

```
// Basic literal string creation
`In JavaScript '\n' is a line-feed.`;

// Multiline strings
`In JavaScript, template strings can run
 over multiple lines, but double and single
 quoted strings cannot.`;

// String interpolation
const name = "Lev",
  time = "today";
`Hello ${name}, how are you ${time}?`;
```

 

 Tagged templates are a compact syntax for specifying a template literal along with a call to a "tag" function for parsing it. A tagged template is just a more succinct and semantic way to invoke a function that processes a string and a set of relevant values. The name of the template tag function precedes the template literal — as in the following example, where the template tag function is named `print`. The `print` function will interpolate the arguments and serialize any objects or arrays that may come up, avoiding the pesky `[object Object]`.

 js 

```
const formatArg = (arg) => {
  if (Array.isArray(arg)) {
    // Print a bulleted list
    return arg.map((part) => `- ${part}`).join("\n");
  }
  if (arg.toString === Object.prototype.toString) {
    // This object will be serialized to "[object Object]".
    // Let's print something nicer.
    return JSON.stringify(arg);
  }
  return arg;
};

const print = (segments, ...args) => {
  // For any well-formed template literal, there will always be N args and
  // (N+1) string segments.
  let message = segments[0];
  segments.slice(1).forEach((segment, index) => {
    message += formatArg(args[index]) + segment;
  });
  console.log(message);
};

const todos = [
  "Learn JavaScript",
  "Learn Web APIs",
  "Set up my website",
  "Profit!",
];

const progress = { javascript: 20, html: 50, css: 10 };

print`I need to do:
${todos}
My current progress is: ${progress}
`;

// I need to do:
// - Learn JavaScript
// - Learn Web APIs
// - Set up my website
// - Profit!
// My current progress is: {"javascript":20,"html":50,"css":10}
```

 

Since tagged template literals are just sugar of function calls, you can re-write the above as an equivalent function call:

 js 

```
print(["I need to do:\n", "\nMy current progress is: ", "\n"], todos, progress);
```

 

This may be reminiscent of the `console.log`-style interpolation:

 js 

```
console.log("I need to do:\n%o\nMy current progress is: %o\n", todos, progress);
```

 

You can see how the tagged template reads more naturally than a traditional "formatter" function, where the variables and the template itself have to be declared separately.

#### Using special characters in strings

In addition to ordinary characters, you can also include special characters in strings, as shown in the following example.

 js 

```
"one line \n another line";
```

 

The following table lists the special characters that you can use in JavaScript strings.

 
 
 
 Character 
 Meaning 
 
 
 
 
 `\0` 
 Null Byte 
 
 
 `\b` 
 Backspace 
 
 
 `\f` 
 Form Feed 
 
 
 `\n` 
 New Line 
 
 
 `\r` 
 Carriage Return 
 
 
 `\t` 
 Tab 
 
 
 `\v` 
 Vertical tab 
 
 
 `\'` 
 Apostrophe or single quote 
 
 
 `\"` 
 Double quote 
 
 
 `\\` 
 Backslash character 
 
 
 `\XXX` 
 The character with the Latin-1 encoding specified by up to three octal digits `XXX` between `0` and `377`. For example, `\251` is the octal sequence for the copyright symbol. 
 
 
 `\xXX` 
 The character with the Latin-1 encoding specified by the two hexadecimal digits `XX` between `00` and `FF`. For example, `\xA9` is the hexadecimal sequence for the copyright symbol. 
 
 
 `\uXXXX` 
 The Unicode character specified by the four hexadecimal digits `XXXX`. For example, `\u00A9` is the Unicode sequence for the copyright symbol. See Unicode escape sequences . 
 
 
 `\u{XXXXX}` 
 Unicode code point escapes. For example, `\u{2F804}` is the same as the Unicode escapes `\uD87E\uDC04`. 
 
 
 

#### Escaping characters

For characters not listed in the table, a preceding backslash is ignored, but this usage is deprecated and should be avoided.

You can insert a quotation mark inside a string by preceding it with a backslash. This is known as escaping the quotation mark. For example:

 js 

```
const quote = "He read \"The Cremation of Sam McGee\" by R.W. Service.";
console.log(quote);
```

 

The result of this would be:



```
He read "The Cremation of Sam McGee" by R.W. Service.
```



To include a literal backslash inside a string, you must escape the backslash character. For example, to assign the file path `c:\temp` to a string, use the following:

 js 

```
const home = "c:\\temp";
```

 

You can also escape line breaks by preceding them with backslash. The backslash and line break are both removed from the value of the string.

 js 

```
const str =
  "this string \
is broken \
across multiple \
lines.";
console.log(str); // this string is broken across multiple lines.
```

 
 
 

## More information 

 
 

This chapter focuses on basic syntax for declarations and types. To learn more about JavaScript's language constructs, see also the following chapters in this guide:

- Control flow and error handling guide

- Loops and iteration 

- Functions 

- Expressions and operators guide

In the next chapter, we will have a look at control flow constructs and error handling.

- Previous 
- Next 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### this - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#content

this - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# this

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `this` keyword refers to the context where a piece of code, such as a function's body, is supposed to run. Most typically, it is used in object methods, where `this` refers to the object that the method is attached to, thus allowing the same method to be reused on different objects.

The value of `this` in JavaScript depends on how a function is invoked (runtime binding ), not how it is defined. When a regular function is invoked as a method of an object (`obj.method()`), `this` points to that object. When invoked as a standalone function (not attached to an object: `func()`), `this` typically refers to the global object (in non-strict mode) or `undefined` (in strict mode ). The `Function.prototype.bind()` method can create a function whose `this` binding doesn't change, and methods `Function.prototype.apply()` and `Function.prototype.call()` can also set the `this` value for a particular call.

 Arrow functions differ in their handling of `this`: they inherit `this` from the parent scope at the time they are defined. This behavior makes arrow functions particularly useful for callbacks and preserving context. However, arrow functions do not have their own `this` binding. Therefore, their `this` value cannot be set by `bind()`, `apply()` or `call()` methods, nor does it point to the current object in object methods.

 
 
 
 
 
 

## Try it 

 
 
 

```
const test = {
  prop: 42,
  func() {
    return this.prop;
  },
};

console.log(test.func());
// Expected output: 42
```

 
 
 

## Syntax 

 
 js 

```
this
```

 
 
 

### Value 

 
 

In non–strict mode, `this` is always a reference to an object. In strict mode, it can be any value. For more information on how the value is determined, see the description below.

 
 

## Description 

 
 

The value of `this` depends on in which context it appears: function, class, or global.

 
 

### Function context 

 
 

Inside a function, the value of `this` depends on how the function is called. Think about `this` as a hidden parameter of a function — just like the parameters declared in the function definition, `this` is a binding that the language creates for you when the function body is evaluated.

For a regular function (not an arrow function, bound function, etc.), the value of `this` is the object that the function is accessed on. In other words, if the function call is in the form `obj.f()`, then `this` refers to `obj`. For example:

 js 

```
function getThis() {
  return this;
}

const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

obj1.getThis = getThis;
obj2.getThis = getThis;

console.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }
console.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }
```

 

Note how the function is the same, but based on how it's invoked, the value of `this` is different. This is analogous to how function parameters work.

The value of `this` is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the prototype chain .

 js 

```
const obj3 = {
  __proto__: obj1,
  name: "obj3",
};

console.log(obj3.getThis()); // { name: 'obj3' }
```

 

The value of `this` always changes based on how a function is called, even when the function was defined on an object at creation:

 js 

```
const obj4 = {
  name: "obj4",
  getThis() {
    return this;
  },
};

const obj5 = { name: "obj5" };

obj5.getThis = obj4.getThis;
console.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }
```

 

If the value that the method is accessed on is a primitive, `this` will be a primitive value as well — but only if the function is in strict mode.

 js 

```
function getThisStrict() {
  "use strict"; // Enter strict mode
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThisStrict = getThisStrict;
console.log(typeof (1).getThisStrict()); // "number"
```

 

If the function is called without being accessed on anything, `this` will be `undefined` — but only if the function is in strict mode.

 js 

```
console.log(typeof getThisStrict()); // "undefined"
```

 

In non-strict mode, a special process called `this` substitution ensures that the value of `this` is always an object. This means:

- If a function is called with `this` set to `undefined` or `null`, `this` gets substituted with `globalThis` .

- If the function is called with `this` set to a primitive value, `this` gets substituted with the primitive value's wrapper object.

 js 

```
function getThis() {
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThis = getThis;
console.log(typeof (1).getThis()); // "object"
console.log(getThis() === globalThis); // true
```

 

In typical function calls, `this` is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of `this` using the `Function.prototype.call()` , `Function.prototype.apply()` , or `Reflect.apply()` methods. Using `Function.prototype.bind()` , you can create a new function with a specific value of `this` that doesn't change regardless of how the function is called. When using these methods, the `this` substitution rules above still apply if the function is non-strict.

#### Callbacks

When a function is passed as a callback, the value of `this` depends on how the callback is called, which is determined by the implementor of the API. Callbacks are typically called with a `this` value of `undefined` (calling it directly without attaching it to any object), which means if the function is non–strict, the value of `this` is the global object ( `globalThis` ). This is the case for iterative array methods , the `Promise()` constructor, etc.

 js 

```
function logThis() {
  "use strict";
  console.log(this);
}

[1, 2, 3].forEach(logThis); // undefined, undefined, undefined
```

 

Some APIs allow you to set a `this` value for invocations of the callback. For example, all iterative array methods and related ones like `Set.prototype.forEach()` accept an optional `thisArg` parameter.

 js 

```
[1, 2, 3].forEach(logThis, { name: "obj" });
// { name: 'obj' }, { name: 'obj' }, { name: 'obj' }
```

 

Occasionally, a callback is called with a `this` value other than `undefined`. For example, the `reviver` parameter of `JSON.parse()` and the `replacer` parameter of `JSON.stringify()` are both called with `this` set to the object that the property being parsed/serialized belongs to.

#### Arrow functions

In arrow functions , `this` retains the value of the enclosing lexical context's `this`. In other words, when evaluating an arrow function's body, the language does not create a new `this` binding.

For example, in global code, `this` is always `globalThis` regardless of strictness, because of the global context binding:

 js 

```
const globalObject = this;
const foo = () => this;
console.log(foo() === globalObject); // true
```

 

Arrow functions create a closure over the `this` value of its surrounding scope, which means arrow functions behave as if they are "auto-bound" — no matter how it's invoked, `this` is bound to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their `this` remains that of the enclosing lexical context. See example below .

Furthermore, when invoking arrow functions using `call()`, `bind()`, or `apply()`, the `thisArg` parameter is ignored. You can still pass other arguments using these methods, though.

 js 

```
const obj = { name: "obj" };

// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true

// Attempt to set this using bind
const boundFoo = foo.bind(obj);
console.log(boundFoo() === globalObject); // true
```

 

#### Constructors

When a function is used as a constructor (with the `new` keyword), its `this` is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of `this` becomes the value of the `new` expression unless the constructor returns another non–primitive value.

 js 

```
function C() {
  this.a = 37;
}

let o = new C();
console.log(o.a); // 37

function C2() {
  this.a = 37;
  return { a: 38 };
}

o = new C2();
console.log(o.a); // 38
```

 

In the second example (`C2`), because an object was returned during construction, the new object that `this` was bound to gets discarded. (This essentially makes the statement `this.a = 37;` dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)

#### super

When a function is invoked in the `super.method()` form, the `this` inside the `method` function is the same value as the `this` value around the `super.method()` call, and is generally not equal to the object that `super` refers to. This is because `super.method` is not an object member access like the ones above — it's a special syntax with different binding rules. For examples, see the `super` reference .

 
 

### Class context 

 
 

A class can be split into two contexts: static and instance. Constructors , methods, and instance field initializers ( public or private ) belong to the instance context. Static methods, static field initializers, and static initialization blocks belong to the static context. The `this` value is different in each context.

Class constructors are always called with `new`, so their behavior is the same as function constructors : the `this` value is the new instance being created. Class methods behave like methods in object literals — the `this` value is the object that the method was accessed on. If the method is not transferred to another object, `this` is generally an instance of the class.

Static methods are not properties of `this`. They are properties of the class itself. Therefore, they are generally accessed on the class, and `this` is the value of the class (or a subclass). Static initialization blocks are also evaluated with `this` set to the current class.

Field initializers are also evaluated in the context of the class. Instance fields are evaluated with `this` set to the instance being constructed. Static fields are evaluated with `this` set to the current class. This is why arrow functions in field initializers are bound to the instance for instance fields and to the class for static fields .

 js 

```
class C {
  instanceField = this;
  static staticField = this;
}

const c = new C();
console.log(c.instanceField === c); // true
console.log(C.staticField === C); // true
```

 

#### Derived class constructors

Unlike base class constructors, derived constructors have no initial `this` binding. Calling `super()` creates a `this` binding within the constructor and essentially has the effect of evaluating the following line of code, where `Base` is the base class:

 js 

```
this = new Base();
```

 
 

 Warning: 
Referring to `this` before calling `super()` will throw an error.

 

Derived classes must not return before calling `super()`, unless the constructor returns an object (so the `this` value is overridden) or the class has no constructor at all.

 js 

```
class Base {}
class Good extends Base {}
class AlsoGood extends Base {
  constructor() {
    return { a: 5 };
  }
}
class Bad extends Base {
  constructor() {}
}

new Good();
new AlsoGood();
new Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

 
 
 

### Global context 

 
 

In the global execution context (outside of any functions or classes; may be inside blocks or arrow functions defined in the global scope), the `this` value depends on what execution context the script runs in. Like callbacks , the `this` value is determined by the runtime environment (the caller).

At the top level of a script, `this` refers to `globalThis` whether in strict mode or not. This is generally the same as the global object — for example, if the source is put inside an HTML ` ` element and executed as a script, `this === window`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 js 

```
// In web browsers, the window object is also the global object:
console.log(this === window); // true

this.b = "MDN";
console.log(window.b); // "MDN"
console.log(b); // "MDN"
```

 

If the source is loaded as a module (for HTML, this means adding `type="module"` to the ` ` tag), `this` is always `undefined` at the top level.

If the source is executed with `eval()` , `this` is the same as the enclosing context for direct eval , or `globalThis` (as if it's run in a separate global script) for indirect eval.

 js 

```
function test() {
  // Direct eval
  console.log(eval("this") === this);
  // Indirect eval, non-strict
  console.log(eval?.("this") === globalThis);
  // Indirect eval, strict
  console.log(eval?.("'use strict'; this") === globalThis);
}

test.call({ name: "obj" }); // Logs 3 "true"
```

 

Note that some source code, while looking like the global scope, is actually wrapped in a function when executed. For example, Node.js CommonJS modules are wrapped in a function and executed with the `this` value set to `module.exports`. Event handler attributes are executed with `this` set to the element they are attached to.

Object literals don't create a `this` scope — only functions (methods) defined within the object do. Using `this` in an object literal inherits the value from the surrounding scope.

 js 

```
const obj = {
  a: this,
};

console.log(obj.a === window); // true
```

 
 
 

## Examples 

 
 
 
 

### this in function contexts 

 
 

The value of the `this` parameter depends on how the function is called, not on how it's defined.

 js 

```
// An object can be passed as the first argument to 'call'
// or 'apply' and 'this' will be bound to it.
const obj = { a: "Custom" };

// Variables declared with var become properties of 'globalThis'.
var a = "Global";

function whatsThis() {
  return this.a; // 'this' depends on how the function is called
}

whatsThis(); // 'Global'; the 'this' parameter defaults to 'globalThis' in non–strict mode
obj.whatsThis = whatsThis;
obj.whatsThis(); // 'Custom'; the 'this' parameter is bound to obj
```

 

Using `call()` and `apply()`, you can pass the value of `this` as if it's an explicit parameter.

 js 

```
function add(c, d) {
  return this.a + this.b + c + d;
}

const o = { a: 1, b: 3 };

// The first argument is bound to the implicit 'this' parameter; the remaining
// arguments are bound to the named parameters.
add.call(o, 5, 7); // 16

// The first argument is bound to the implicit 'this' parameter; the second
// argument is an array whose members are bound to the named parameters.
add.apply(o, [10, 20]); // 34
```

 
 
 

### this and object conversion 

 
 

In non–strict mode, if a function is called with a `this` value that's not an object, the `this` value is substituted with an object. `null` and `undefined` become `globalThis`. Primitives like `7` or `'foo'` are converted to an object using the related constructor, so the primitive number `7` is converted to a `Number` wrapper class and the string `'foo'` to a `String` wrapper class.

 js 

```
function bar() {
  console.log(Object.prototype.toString.call(this));
}

bar.call(7); // [object Number]
bar.call("foo"); // [object String]
bar.call(undefined); // [object Window]
```

 
 
 

### The bind() method 

 
 

Calling `f.bind(someObject)` creates a new function with the same body and scope as `f`, but the value of `this` is permanently bound to the first argument of `bind`, regardless of how the function is being called.

 js 

```
function f() {
  return this.a;
}

const g = f.bind({ a: "azerty" });
console.log(g()); // azerty

const h = g.bind({ a: "yoo" }); // bind only works once!
console.log(h()); // azerty

const o = { a: 37, f, g, h };
console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty
```

 
 
 

### this in arrow functions 

 
 

Arrow functions create closures over the `this` value of the enclosing execution context. In the following example, we create `obj` with a method `getThisGetter` that returns a function that returns the value of `this`. The returned function is created as an arrow function, so its `this` is permanently bound to the `this` of its enclosing function. The value of `this` inside `getThisGetter` can be set in the call, which in turn sets the return value of the returned function. We will assume that `getThisGetter` is a non-strict function, which means it's contained in a non-strict script and not further nested in a class or strict function.

 js 

```
const obj = {
  getThisGetter() {
    const getter = () => this;
    return getter;
  },
};
```

 

We can call `getThisGetter` as a method of `obj`, which binds `this` to `obj` inside its body. The returned function is assigned to a variable `fn`. Now, when calling `fn`, the value of `this` returned is still the one set by the call to `getThisGetter`, which is `obj`. If the returned function was not an arrow function, such calls would cause the `this` value to be `globalThis`, because `getThisGetter` is non-strict.

 js 

```
const fn = obj.getThisGetter();
console.log(fn() === obj); // true
```

 

But be careful if you unbind the method of `obj` without calling it, because `getThisGetter` is still a method that has a varying `this` value. Calling `fn2()()` in the following example returns `globalThis`, because it follows the `this` from `fn2()`, which is `globalThis` since it's called without being attached to any object.

 js 

```
const fn2 = obj.getThisGetter;
console.log(fn2()() === globalThis); // true in non-strict mode
```

 

This behavior is very useful when defining callbacks. Usually, each function expression creates its own `this` binding, which shadows the `this` value of the upper scope. Now, you can define functions as arrow functions if you don't care about the `this` value, and only create `this` bindings where you do (e.g., in class methods). See example with `setTimeout()` .

 
 

### this with a getter or setter 

 
 

`this` in getters and setters is based on which object the property is accessed on, not which object the property is defined on. A function used as getter or setter has its `this` bound to the object from which the property is being set or gotten.

 js 

```
function sum() {
  return this.a + this.b + this.c;
}

const o = {
  a: 1,
  b: 2,
  c: 3,
  get average() {
    return (this.a + this.b + this.c) / 3;
  },
};

Object.defineProperty(o, "sum", {
  get: sum,
  enumerable: true,
  configurable: true,
});

console.log(o.average, o.sum); // 2 6
```

 
 
 

### this in DOM event handlers 

 
 

When a function is used as an event handler, its `this` parameter is bound to the DOM element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than `addEventListener()` ).

 js 

```
// When called as a listener, turns the related element blue
function bluify(e) {
  // Always true
  console.log(this === e.currentTarget);
  // true when currentTarget and target are the same object
  console.log(this === e.target);
  this.style.backgroundColor = "#A5D9F3";
}

// Get a list of every element in the document
const elements = document.getElementsByTagName("*");

// Add bluify as a click listener so when the
// element is clicked on, it turns blue
for (const element of elements) {
  element.addEventListener("click", bluify);
}
```

 
 
 

### this in inline event handlers 

 
 

When the code is called from an inline event handler attribute , its `this` is bound to the DOM element on which the listener is placed:

 html 

```
<button onclick="alert(this.tagName.toLowerCase());">Show this</button>
```

 

The above alert shows `button`. Note, however, that only the outer scope has its `this` bound this way:

 html 

```
<button onclick="alert((function () { return this; })());">
  Show inner this
</button>
```

 

In this case, the `this` parameter of the inner function is bound to `globalThis` (i.e., the default object in non–strict mode where `this` isn't passed in the call).

 
 

### Bound methods in classes 

 
 

Just like with regular functions, the value of `this` within methods depends on how they are called. Sometimes it is useful to override this behavior so that `this` within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:

 js 

```
class Car {
  constructor() {
    // Bind sayBye but not sayHi to show the difference
    this.sayBye = this.sayBye.bind(this);
  }

  sayHi() {
    console.log(`Hello from ${this.name}`);
  }

  sayBye() {
    console.log(`Bye from ${this.name}`);
  }

  get name() {
    return "Ferrari";
  }
}

class Bird {
  get name() {
    return "Tweety";
  }
}

const car = new Car();
const bird = new Bird();

// The value of 'this' in methods depends on their caller
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// For bound methods, 'this' doesn't depend on the caller
bird.sayBye = car.sayBye;
bird.sayBye(); // Bye from Ferrari
```

 
 

 Note: 
Classes are always in strict mode. Calling methods with an undefined `this` will throw an error if the method tries to access properties on `this`.

 js 

```
const carSayHi = car.sayHi;
carSayHi(); // TypeError because the 'sayHi' method tries to access 'this.name', but 'this' is undefined in strict mode.
```

 
 

Note, however, that auto-bound methods suffer from the same problem as using arrow functions for class properties : each instance of the class will have its own copy of the method, which increases memory usage. Only use it where absolutely necessary. You can also mimic the implementation of `Intl.NumberFormat.prototype.format()` : define the property as a getter that returns a bound function when accessed and saves it, so that the function is only created once and only created when necessary.

 
 

### this in with statements 

 
 

Although `with` statements are deprecated and not available in strict mode, they still serve as an exception to the normal `this` binding rules. If a function is called within a `with` statement and that function is a property of the scope object, the `this` value is bound to the scope object, as if the `obj.` prefix exists.

 js 

```
const obj = {
  foo() {
    return this;
  },
};

with (obj) {
  console.log(foo() === obj); // true
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Strict mode 

- `globalThis` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 18, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### this - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#search

this - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# this

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `this` keyword refers to the context where a piece of code, such as a function's body, is supposed to run. Most typically, it is used in object methods, where `this` refers to the object that the method is attached to, thus allowing the same method to be reused on different objects.

The value of `this` in JavaScript depends on how a function is invoked (runtime binding ), not how it is defined. When a regular function is invoked as a method of an object (`obj.method()`), `this` points to that object. When invoked as a standalone function (not attached to an object: `func()`), `this` typically refers to the global object (in non-strict mode) or `undefined` (in strict mode ). The `Function.prototype.bind()` method can create a function whose `this` binding doesn't change, and methods `Function.prototype.apply()` and `Function.prototype.call()` can also set the `this` value for a particular call.

 Arrow functions differ in their handling of `this`: they inherit `this` from the parent scope at the time they are defined. This behavior makes arrow functions particularly useful for callbacks and preserving context. However, arrow functions do not have their own `this` binding. Therefore, their `this` value cannot be set by `bind()`, `apply()` or `call()` methods, nor does it point to the current object in object methods.

 
 
 
 
 
 

## Try it 

 
 
 

```
const test = {
  prop: 42,
  func() {
    return this.prop;
  },
};

console.log(test.func());
// Expected output: 42
```

 
 
 

## Syntax 

 
 js 

```
this
```

 
 
 

### Value 

 
 

In non–strict mode, `this` is always a reference to an object. In strict mode, it can be any value. For more information on how the value is determined, see the description below.

 
 

## Description 

 
 

The value of `this` depends on in which context it appears: function, class, or global.

 
 

### Function context 

 
 

Inside a function, the value of `this` depends on how the function is called. Think about `this` as a hidden parameter of a function — just like the parameters declared in the function definition, `this` is a binding that the language creates for you when the function body is evaluated.

For a regular function (not an arrow function, bound function, etc.), the value of `this` is the object that the function is accessed on. In other words, if the function call is in the form `obj.f()`, then `this` refers to `obj`. For example:

 js 

```
function getThis() {
  return this;
}

const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

obj1.getThis = getThis;
obj2.getThis = getThis;

console.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }
console.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }
```

 

Note how the function is the same, but based on how it's invoked, the value of `this` is different. This is analogous to how function parameters work.

The value of `this` is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the prototype chain .

 js 

```
const obj3 = {
  __proto__: obj1,
  name: "obj3",
};

console.log(obj3.getThis()); // { name: 'obj3' }
```

 

The value of `this` always changes based on how a function is called, even when the function was defined on an object at creation:

 js 

```
const obj4 = {
  name: "obj4",
  getThis() {
    return this;
  },
};

const obj5 = { name: "obj5" };

obj5.getThis = obj4.getThis;
console.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }
```

 

If the value that the method is accessed on is a primitive, `this` will be a primitive value as well — but only if the function is in strict mode.

 js 

```
function getThisStrict() {
  "use strict"; // Enter strict mode
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThisStrict = getThisStrict;
console.log(typeof (1).getThisStrict()); // "number"
```

 

If the function is called without being accessed on anything, `this` will be `undefined` — but only if the function is in strict mode.

 js 

```
console.log(typeof getThisStrict()); // "undefined"
```

 

In non-strict mode, a special process called `this` substitution ensures that the value of `this` is always an object. This means:

- If a function is called with `this` set to `undefined` or `null`, `this` gets substituted with `globalThis` .

- If the function is called with `this` set to a primitive value, `this` gets substituted with the primitive value's wrapper object.

 js 

```
function getThis() {
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThis = getThis;
console.log(typeof (1).getThis()); // "object"
console.log(getThis() === globalThis); // true
```

 

In typical function calls, `this` is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of `this` using the `Function.prototype.call()` , `Function.prototype.apply()` , or `Reflect.apply()` methods. Using `Function.prototype.bind()` , you can create a new function with a specific value of `this` that doesn't change regardless of how the function is called. When using these methods, the `this` substitution rules above still apply if the function is non-strict.

#### Callbacks

When a function is passed as a callback, the value of `this` depends on how the callback is called, which is determined by the implementor of the API. Callbacks are typically called with a `this` value of `undefined` (calling it directly without attaching it to any object), which means if the function is non–strict, the value of `this` is the global object ( `globalThis` ). This is the case for iterative array methods , the `Promise()` constructor, etc.

 js 

```
function logThis() {
  "use strict";
  console.log(this);
}

[1, 2, 3].forEach(logThis); // undefined, undefined, undefined
```

 

Some APIs allow you to set a `this` value for invocations of the callback. For example, all iterative array methods and related ones like `Set.prototype.forEach()` accept an optional `thisArg` parameter.

 js 

```
[1, 2, 3].forEach(logThis, { name: "obj" });
// { name: 'obj' }, { name: 'obj' }, { name: 'obj' }
```

 

Occasionally, a callback is called with a `this` value other than `undefined`. For example, the `reviver` parameter of `JSON.parse()` and the `replacer` parameter of `JSON.stringify()` are both called with `this` set to the object that the property being parsed/serialized belongs to.

#### Arrow functions

In arrow functions , `this` retains the value of the enclosing lexical context's `this`. In other words, when evaluating an arrow function's body, the language does not create a new `this` binding.

For example, in global code, `this` is always `globalThis` regardless of strictness, because of the global context binding:

 js 

```
const globalObject = this;
const foo = () => this;
console.log(foo() === globalObject); // true
```

 

Arrow functions create a closure over the `this` value of its surrounding scope, which means arrow functions behave as if they are "auto-bound" — no matter how it's invoked, `this` is bound to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their `this` remains that of the enclosing lexical context. See example below .

Furthermore, when invoking arrow functions using `call()`, `bind()`, or `apply()`, the `thisArg` parameter is ignored. You can still pass other arguments using these methods, though.

 js 

```
const obj = { name: "obj" };

// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true

// Attempt to set this using bind
const boundFoo = foo.bind(obj);
console.log(boundFoo() === globalObject); // true
```

 

#### Constructors

When a function is used as a constructor (with the `new` keyword), its `this` is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of `this` becomes the value of the `new` expression unless the constructor returns another non–primitive value.

 js 

```
function C() {
  this.a = 37;
}

let o = new C();
console.log(o.a); // 37

function C2() {
  this.a = 37;
  return { a: 38 };
}

o = new C2();
console.log(o.a); // 38
```

 

In the second example (`C2`), because an object was returned during construction, the new object that `this` was bound to gets discarded. (This essentially makes the statement `this.a = 37;` dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)

#### super

When a function is invoked in the `super.method()` form, the `this` inside the `method` function is the same value as the `this` value around the `super.method()` call, and is generally not equal to the object that `super` refers to. This is because `super.method` is not an object member access like the ones above — it's a special syntax with different binding rules. For examples, see the `super` reference .

 
 

### Class context 

 
 

A class can be split into two contexts: static and instance. Constructors , methods, and instance field initializers ( public or private ) belong to the instance context. Static methods, static field initializers, and static initialization blocks belong to the static context. The `this` value is different in each context.

Class constructors are always called with `new`, so their behavior is the same as function constructors : the `this` value is the new instance being created. Class methods behave like methods in object literals — the `this` value is the object that the method was accessed on. If the method is not transferred to another object, `this` is generally an instance of the class.

Static methods are not properties of `this`. They are properties of the class itself. Therefore, they are generally accessed on the class, and `this` is the value of the class (or a subclass). Static initialization blocks are also evaluated with `this` set to the current class.

Field initializers are also evaluated in the context of the class. Instance fields are evaluated with `this` set to the instance being constructed. Static fields are evaluated with `this` set to the current class. This is why arrow functions in field initializers are bound to the instance for instance fields and to the class for static fields .

 js 

```
class C {
  instanceField = this;
  static staticField = this;
}

const c = new C();
console.log(c.instanceField === c); // true
console.log(C.staticField === C); // true
```

 

#### Derived class constructors

Unlike base class constructors, derived constructors have no initial `this` binding. Calling `super()` creates a `this` binding within the constructor and essentially has the effect of evaluating the following line of code, where `Base` is the base class:

 js 

```
this = new Base();
```

 
 

 Warning: 
Referring to `this` before calling `super()` will throw an error.

 

Derived classes must not return before calling `super()`, unless the constructor returns an object (so the `this` value is overridden) or the class has no constructor at all.

 js 

```
class Base {}
class Good extends Base {}
class AlsoGood extends Base {
  constructor() {
    return { a: 5 };
  }
}
class Bad extends Base {
  constructor() {}
}

new Good();
new AlsoGood();
new Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

 
 
 

### Global context 

 
 

In the global execution context (outside of any functions or classes; may be inside blocks or arrow functions defined in the global scope), the `this` value depends on what execution context the script runs in. Like callbacks , the `this` value is determined by the runtime environment (the caller).

At the top level of a script, `this` refers to `globalThis` whether in strict mode or not. This is generally the same as the global object — for example, if the source is put inside an HTML ` ` element and executed as a script, `this === window`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 js 

```
// In web browsers, the window object is also the global object:
console.log(this === window); // true

this.b = "MDN";
console.log(window.b); // "MDN"
console.log(b); // "MDN"
```

 

If the source is loaded as a module (for HTML, this means adding `type="module"` to the ` ` tag), `this` is always `undefined` at the top level.

If the source is executed with `eval()` , `this` is the same as the enclosing context for direct eval , or `globalThis` (as if it's run in a separate global script) for indirect eval.

 js 

```
function test() {
  // Direct eval
  console.log(eval("this") === this);
  // Indirect eval, non-strict
  console.log(eval?.("this") === globalThis);
  // Indirect eval, strict
  console.log(eval?.("'use strict'; this") === globalThis);
}

test.call({ name: "obj" }); // Logs 3 "true"
```

 

Note that some source code, while looking like the global scope, is actually wrapped in a function when executed. For example, Node.js CommonJS modules are wrapped in a function and executed with the `this` value set to `module.exports`. Event handler attributes are executed with `this` set to the element they are attached to.

Object literals don't create a `this` scope — only functions (methods) defined within the object do. Using `this` in an object literal inherits the value from the surrounding scope.

 js 

```
const obj = {
  a: this,
};

console.log(obj.a === window); // true
```

 
 
 

## Examples 

 
 
 
 

### this in function contexts 

 
 

The value of the `this` parameter depends on how the function is called, not on how it's defined.

 js 

```
// An object can be passed as the first argument to 'call'
// or 'apply' and 'this' will be bound to it.
const obj = { a: "Custom" };

// Variables declared with var become properties of 'globalThis'.
var a = "Global";

function whatsThis() {
  return this.a; // 'this' depends on how the function is called
}

whatsThis(); // 'Global'; the 'this' parameter defaults to 'globalThis' in non–strict mode
obj.whatsThis = whatsThis;
obj.whatsThis(); // 'Custom'; the 'this' parameter is bound to obj
```

 

Using `call()` and `apply()`, you can pass the value of `this` as if it's an explicit parameter.

 js 

```
function add(c, d) {
  return this.a + this.b + c + d;
}

const o = { a: 1, b: 3 };

// The first argument is bound to the implicit 'this' parameter; the remaining
// arguments are bound to the named parameters.
add.call(o, 5, 7); // 16

// The first argument is bound to the implicit 'this' parameter; the second
// argument is an array whose members are bound to the named parameters.
add.apply(o, [10, 20]); // 34
```

 
 
 

### this and object conversion 

 
 

In non–strict mode, if a function is called with a `this` value that's not an object, the `this` value is substituted with an object. `null` and `undefined` become `globalThis`. Primitives like `7` or `'foo'` are converted to an object using the related constructor, so the primitive number `7` is converted to a `Number` wrapper class and the string `'foo'` to a `String` wrapper class.

 js 

```
function bar() {
  console.log(Object.prototype.toString.call(this));
}

bar.call(7); // [object Number]
bar.call("foo"); // [object String]
bar.call(undefined); // [object Window]
```

 
 
 

### The bind() method 

 
 

Calling `f.bind(someObject)` creates a new function with the same body and scope as `f`, but the value of `this` is permanently bound to the first argument of `bind`, regardless of how the function is being called.

 js 

```
function f() {
  return this.a;
}

const g = f.bind({ a: "azerty" });
console.log(g()); // azerty

const h = g.bind({ a: "yoo" }); // bind only works once!
console.log(h()); // azerty

const o = { a: 37, f, g, h };
console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty
```

 
 
 

### this in arrow functions 

 
 

Arrow functions create closures over the `this` value of the enclosing execution context. In the following example, we create `obj` with a method `getThisGetter` that returns a function that returns the value of `this`. The returned function is created as an arrow function, so its `this` is permanently bound to the `this` of its enclosing function. The value of `this` inside `getThisGetter` can be set in the call, which in turn sets the return value of the returned function. We will assume that `getThisGetter` is a non-strict function, which means it's contained in a non-strict script and not further nested in a class or strict function.

 js 

```
const obj = {
  getThisGetter() {
    const getter = () => this;
    return getter;
  },
};
```

 

We can call `getThisGetter` as a method of `obj`, which binds `this` to `obj` inside its body. The returned function is assigned to a variable `fn`. Now, when calling `fn`, the value of `this` returned is still the one set by the call to `getThisGetter`, which is `obj`. If the returned function was not an arrow function, such calls would cause the `this` value to be `globalThis`, because `getThisGetter` is non-strict.

 js 

```
const fn = obj.getThisGetter();
console.log(fn() === obj); // true
```

 

But be careful if you unbind the method of `obj` without calling it, because `getThisGetter` is still a method that has a varying `this` value. Calling `fn2()()` in the following example returns `globalThis`, because it follows the `this` from `fn2()`, which is `globalThis` since it's called without being attached to any object.

 js 

```
const fn2 = obj.getThisGetter;
console.log(fn2()() === globalThis); // true in non-strict mode
```

 

This behavior is very useful when defining callbacks. Usually, each function expression creates its own `this` binding, which shadows the `this` value of the upper scope. Now, you can define functions as arrow functions if you don't care about the `this` value, and only create `this` bindings where you do (e.g., in class methods). See example with `setTimeout()` .

 
 

### this with a getter or setter 

 
 

`this` in getters and setters is based on which object the property is accessed on, not which object the property is defined on. A function used as getter or setter has its `this` bound to the object from which the property is being set or gotten.

 js 

```
function sum() {
  return this.a + this.b + this.c;
}

const o = {
  a: 1,
  b: 2,
  c: 3,
  get average() {
    return (this.a + this.b + this.c) / 3;
  },
};

Object.defineProperty(o, "sum", {
  get: sum,
  enumerable: true,
  configurable: true,
});

console.log(o.average, o.sum); // 2 6
```

 
 
 

### this in DOM event handlers 

 
 

When a function is used as an event handler, its `this` parameter is bound to the DOM element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than `addEventListener()` ).

 js 

```
// When called as a listener, turns the related element blue
function bluify(e) {
  // Always true
  console.log(this === e.currentTarget);
  // true when currentTarget and target are the same object
  console.log(this === e.target);
  this.style.backgroundColor = "#A5D9F3";
}

// Get a list of every element in the document
const elements = document.getElementsByTagName("*");

// Add bluify as a click listener so when the
// element is clicked on, it turns blue
for (const element of elements) {
  element.addEventListener("click", bluify);
}
```

 
 
 

### this in inline event handlers 

 
 

When the code is called from an inline event handler attribute , its `this` is bound to the DOM element on which the listener is placed:

 html 

```
<button onclick="alert(this.tagName.toLowerCase());">Show this</button>
```

 

The above alert shows `button`. Note, however, that only the outer scope has its `this` bound this way:

 html 

```
<button onclick="alert((function () { return this; })());">
  Show inner this
</button>
```

 

In this case, the `this` parameter of the inner function is bound to `globalThis` (i.e., the default object in non–strict mode where `this` isn't passed in the call).

 
 

### Bound methods in classes 

 
 

Just like with regular functions, the value of `this` within methods depends on how they are called. Sometimes it is useful to override this behavior so that `this` within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:

 js 

```
class Car {
  constructor() {
    // Bind sayBye but not sayHi to show the difference
    this.sayBye = this.sayBye.bind(this);
  }

  sayHi() {
    console.log(`Hello from ${this.name}`);
  }

  sayBye() {
    console.log(`Bye from ${this.name}`);
  }

  get name() {
    return "Ferrari";
  }
}

class Bird {
  get name() {
    return "Tweety";
  }
}

const car = new Car();
const bird = new Bird();

// The value of 'this' in methods depends on their caller
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// For bound methods, 'this' doesn't depend on the caller
bird.sayBye = car.sayBye;
bird.sayBye(); // Bye from Ferrari
```

 
 

 Note: 
Classes are always in strict mode. Calling methods with an undefined `this` will throw an error if the method tries to access properties on `this`.

 js 

```
const carSayHi = car.sayHi;
carSayHi(); // TypeError because the 'sayHi' method tries to access 'this.name', but 'this' is undefined in strict mode.
```

 
 

Note, however, that auto-bound methods suffer from the same problem as using arrow functions for class properties : each instance of the class will have its own copy of the method, which increases memory usage. Only use it where absolutely necessary. You can also mimic the implementation of `Intl.NumberFormat.prototype.format()` : define the property as a getter that returns a bound function when accessed and saves it, so that the function is only created once and only created when necessary.

 
 

### this in with statements 

 
 

Although `with` statements are deprecated and not available in strict mode, they still serve as an exception to the normal `this` binding rules. If a function is called within a `with` statement and that function is a property of the scope object, the `this` value is bound to the scope object, as if the `obj.` prefix exists.

 js 

```
const obj = {
  foo() {
    return this;
  },
};

with (obj) {
  console.log(foo() === obj); // true
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Strict mode 

- `globalThis` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 18, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### this - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#browser_compatibility

this - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# this

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `this` keyword refers to the context where a piece of code, such as a function's body, is supposed to run. Most typically, it is used in object methods, where `this` refers to the object that the method is attached to, thus allowing the same method to be reused on different objects.

The value of `this` in JavaScript depends on how a function is invoked (runtime binding ), not how it is defined. When a regular function is invoked as a method of an object (`obj.method()`), `this` points to that object. When invoked as a standalone function (not attached to an object: `func()`), `this` typically refers to the global object (in non-strict mode) or `undefined` (in strict mode ). The `Function.prototype.bind()` method can create a function whose `this` binding doesn't change, and methods `Function.prototype.apply()` and `Function.prototype.call()` can also set the `this` value for a particular call.

 Arrow functions differ in their handling of `this`: they inherit `this` from the parent scope at the time they are defined. This behavior makes arrow functions particularly useful for callbacks and preserving context. However, arrow functions do not have their own `this` binding. Therefore, their `this` value cannot be set by `bind()`, `apply()` or `call()` methods, nor does it point to the current object in object methods.

 
 
 
 
 
 

## Try it 

 
 
 

```
const test = {
  prop: 42,
  func() {
    return this.prop;
  },
};

console.log(test.func());
// Expected output: 42
```

 
 
 

## Syntax 

 
 js 

```
this
```

 
 
 

### Value 

 
 

In non–strict mode, `this` is always a reference to an object. In strict mode, it can be any value. For more information on how the value is determined, see the description below.

 
 

## Description 

 
 

The value of `this` depends on in which context it appears: function, class, or global.

 
 

### Function context 

 
 

Inside a function, the value of `this` depends on how the function is called. Think about `this` as a hidden parameter of a function — just like the parameters declared in the function definition, `this` is a binding that the language creates for you when the function body is evaluated.

For a regular function (not an arrow function, bound function, etc.), the value of `this` is the object that the function is accessed on. In other words, if the function call is in the form `obj.f()`, then `this` refers to `obj`. For example:

 js 

```
function getThis() {
  return this;
}

const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

obj1.getThis = getThis;
obj2.getThis = getThis;

console.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }
console.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }
```

 

Note how the function is the same, but based on how it's invoked, the value of `this` is different. This is analogous to how function parameters work.

The value of `this` is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the prototype chain .

 js 

```
const obj3 = {
  __proto__: obj1,
  name: "obj3",
};

console.log(obj3.getThis()); // { name: 'obj3' }
```

 

The value of `this` always changes based on how a function is called, even when the function was defined on an object at creation:

 js 

```
const obj4 = {
  name: "obj4",
  getThis() {
    return this;
  },
};

const obj5 = { name: "obj5" };

obj5.getThis = obj4.getThis;
console.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }
```

 

If the value that the method is accessed on is a primitive, `this` will be a primitive value as well — but only if the function is in strict mode.

 js 

```
function getThisStrict() {
  "use strict"; // Enter strict mode
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThisStrict = getThisStrict;
console.log(typeof (1).getThisStrict()); // "number"
```

 

If the function is called without being accessed on anything, `this` will be `undefined` — but only if the function is in strict mode.

 js 

```
console.log(typeof getThisStrict()); // "undefined"
```

 

In non-strict mode, a special process called `this` substitution ensures that the value of `this` is always an object. This means:

- If a function is called with `this` set to `undefined` or `null`, `this` gets substituted with `globalThis` .

- If the function is called with `this` set to a primitive value, `this` gets substituted with the primitive value's wrapper object.

 js 

```
function getThis() {
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThis = getThis;
console.log(typeof (1).getThis()); // "object"
console.log(getThis() === globalThis); // true
```

 

In typical function calls, `this` is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of `this` using the `Function.prototype.call()` , `Function.prototype.apply()` , or `Reflect.apply()` methods. Using `Function.prototype.bind()` , you can create a new function with a specific value of `this` that doesn't change regardless of how the function is called. When using these methods, the `this` substitution rules above still apply if the function is non-strict.

#### Callbacks

When a function is passed as a callback, the value of `this` depends on how the callback is called, which is determined by the implementor of the API. Callbacks are typically called with a `this` value of `undefined` (calling it directly without attaching it to any object), which means if the function is non–strict, the value of `this` is the global object ( `globalThis` ). This is the case for iterative array methods , the `Promise()` constructor, etc.

 js 

```
function logThis() {
  "use strict";
  console.log(this);
}

[1, 2, 3].forEach(logThis); // undefined, undefined, undefined
```

 

Some APIs allow you to set a `this` value for invocations of the callback. For example, all iterative array methods and related ones like `Set.prototype.forEach()` accept an optional `thisArg` parameter.

 js 

```
[1, 2, 3].forEach(logThis, { name: "obj" });
// { name: 'obj' }, { name: 'obj' }, { name: 'obj' }
```

 

Occasionally, a callback is called with a `this` value other than `undefined`. For example, the `reviver` parameter of `JSON.parse()` and the `replacer` parameter of `JSON.stringify()` are both called with `this` set to the object that the property being parsed/serialized belongs to.

#### Arrow functions

In arrow functions , `this` retains the value of the enclosing lexical context's `this`. In other words, when evaluating an arrow function's body, the language does not create a new `this` binding.

For example, in global code, `this` is always `globalThis` regardless of strictness, because of the global context binding:

 js 

```
const globalObject = this;
const foo = () => this;
console.log(foo() === globalObject); // true
```

 

Arrow functions create a closure over the `this` value of its surrounding scope, which means arrow functions behave as if they are "auto-bound" — no matter how it's invoked, `this` is bound to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their `this` remains that of the enclosing lexical context. See example below .

Furthermore, when invoking arrow functions using `call()`, `bind()`, or `apply()`, the `thisArg` parameter is ignored. You can still pass other arguments using these methods, though.

 js 

```
const obj = { name: "obj" };

// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true

// Attempt to set this using bind
const boundFoo = foo.bind(obj);
console.log(boundFoo() === globalObject); // true
```

 

#### Constructors

When a function is used as a constructor (with the `new` keyword), its `this` is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of `this` becomes the value of the `new` expression unless the constructor returns another non–primitive value.

 js 

```
function C() {
  this.a = 37;
}

let o = new C();
console.log(o.a); // 37

function C2() {
  this.a = 37;
  return { a: 38 };
}

o = new C2();
console.log(o.a); // 38
```

 

In the second example (`C2`), because an object was returned during construction, the new object that `this` was bound to gets discarded. (This essentially makes the statement `this.a = 37;` dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)

#### super

When a function is invoked in the `super.method()` form, the `this` inside the `method` function is the same value as the `this` value around the `super.method()` call, and is generally not equal to the object that `super` refers to. This is because `super.method` is not an object member access like the ones above — it's a special syntax with different binding rules. For examples, see the `super` reference .

 
 

### Class context 

 
 

A class can be split into two contexts: static and instance. Constructors , methods, and instance field initializers ( public or private ) belong to the instance context. Static methods, static field initializers, and static initialization blocks belong to the static context. The `this` value is different in each context.

Class constructors are always called with `new`, so their behavior is the same as function constructors : the `this` value is the new instance being created. Class methods behave like methods in object literals — the `this` value is the object that the method was accessed on. If the method is not transferred to another object, `this` is generally an instance of the class.

Static methods are not properties of `this`. They are properties of the class itself. Therefore, they are generally accessed on the class, and `this` is the value of the class (or a subclass). Static initialization blocks are also evaluated with `this` set to the current class.

Field initializers are also evaluated in the context of the class. Instance fields are evaluated with `this` set to the instance being constructed. Static fields are evaluated with `this` set to the current class. This is why arrow functions in field initializers are bound to the instance for instance fields and to the class for static fields .

 js 

```
class C {
  instanceField = this;
  static staticField = this;
}

const c = new C();
console.log(c.instanceField === c); // true
console.log(C.staticField === C); // true
```

 

#### Derived class constructors

Unlike base class constructors, derived constructors have no initial `this` binding. Calling `super()` creates a `this` binding within the constructor and essentially has the effect of evaluating the following line of code, where `Base` is the base class:

 js 

```
this = new Base();
```

 
 

 Warning: 
Referring to `this` before calling `super()` will throw an error.

 

Derived classes must not return before calling `super()`, unless the constructor returns an object (so the `this` value is overridden) or the class has no constructor at all.

 js 

```
class Base {}
class Good extends Base {}
class AlsoGood extends Base {
  constructor() {
    return { a: 5 };
  }
}
class Bad extends Base {
  constructor() {}
}

new Good();
new AlsoGood();
new Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

 
 
 

### Global context 

 
 

In the global execution context (outside of any functions or classes; may be inside blocks or arrow functions defined in the global scope), the `this` value depends on what execution context the script runs in. Like callbacks , the `this` value is determined by the runtime environment (the caller).

At the top level of a script, `this` refers to `globalThis` whether in strict mode or not. This is generally the same as the global object — for example, if the source is put inside an HTML ` ` element and executed as a script, `this === window`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 js 

```
// In web browsers, the window object is also the global object:
console.log(this === window); // true

this.b = "MDN";
console.log(window.b); // "MDN"
console.log(b); // "MDN"
```

 

If the source is loaded as a module (for HTML, this means adding `type="module"` to the ` ` tag), `this` is always `undefined` at the top level.

If the source is executed with `eval()` , `this` is the same as the enclosing context for direct eval , or `globalThis` (as if it's run in a separate global script) for indirect eval.

 js 

```
function test() {
  // Direct eval
  console.log(eval("this") === this);
  // Indirect eval, non-strict
  console.log(eval?.("this") === globalThis);
  // Indirect eval, strict
  console.log(eval?.("'use strict'; this") === globalThis);
}

test.call({ name: "obj" }); // Logs 3 "true"
```

 

Note that some source code, while looking like the global scope, is actually wrapped in a function when executed. For example, Node.js CommonJS modules are wrapped in a function and executed with the `this` value set to `module.exports`. Event handler attributes are executed with `this` set to the element they are attached to.

Object literals don't create a `this` scope — only functions (methods) defined within the object do. Using `this` in an object literal inherits the value from the surrounding scope.

 js 

```
const obj = {
  a: this,
};

console.log(obj.a === window); // true
```

 
 
 

## Examples 

 
 
 
 

### this in function contexts 

 
 

The value of the `this` parameter depends on how the function is called, not on how it's defined.

 js 

```
// An object can be passed as the first argument to 'call'
// or 'apply' and 'this' will be bound to it.
const obj = { a: "Custom" };

// Variables declared with var become properties of 'globalThis'.
var a = "Global";

function whatsThis() {
  return this.a; // 'this' depends on how the function is called
}

whatsThis(); // 'Global'; the 'this' parameter defaults to 'globalThis' in non–strict mode
obj.whatsThis = whatsThis;
obj.whatsThis(); // 'Custom'; the 'this' parameter is bound to obj
```

 

Using `call()` and `apply()`, you can pass the value of `this` as if it's an explicit parameter.

 js 

```
function add(c, d) {
  return this.a + this.b + c + d;
}

const o = { a: 1, b: 3 };

// The first argument is bound to the implicit 'this' parameter; the remaining
// arguments are bound to the named parameters.
add.call(o, 5, 7); // 16

// The first argument is bound to the implicit 'this' parameter; the second
// argument is an array whose members are bound to the named parameters.
add.apply(o, [10, 20]); // 34
```

 
 
 

### this and object conversion 

 
 

In non–strict mode, if a function is called with a `this` value that's not an object, the `this` value is substituted with an object. `null` and `undefined` become `globalThis`. Primitives like `7` or `'foo'` are converted to an object using the related constructor, so the primitive number `7` is converted to a `Number` wrapper class and the string `'foo'` to a `String` wrapper class.

 js 

```
function bar() {
  console.log(Object.prototype.toString.call(this));
}

bar.call(7); // [object Number]
bar.call("foo"); // [object String]
bar.call(undefined); // [object Window]
```

 
 
 

### The bind() method 

 
 

Calling `f.bind(someObject)` creates a new function with the same body and scope as `f`, but the value of `this` is permanently bound to the first argument of `bind`, regardless of how the function is being called.

 js 

```
function f() {
  return this.a;
}

const g = f.bind({ a: "azerty" });
console.log(g()); // azerty

const h = g.bind({ a: "yoo" }); // bind only works once!
console.log(h()); // azerty

const o = { a: 37, f, g, h };
console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty
```

 
 
 

### this in arrow functions 

 
 

Arrow functions create closures over the `this` value of the enclosing execution context. In the following example, we create `obj` with a method `getThisGetter` that returns a function that returns the value of `this`. The returned function is created as an arrow function, so its `this` is permanently bound to the `this` of its enclosing function. The value of `this` inside `getThisGetter` can be set in the call, which in turn sets the return value of the returned function. We will assume that `getThisGetter` is a non-strict function, which means it's contained in a non-strict script and not further nested in a class or strict function.

 js 

```
const obj = {
  getThisGetter() {
    const getter = () => this;
    return getter;
  },
};
```

 

We can call `getThisGetter` as a method of `obj`, which binds `this` to `obj` inside its body. The returned function is assigned to a variable `fn`. Now, when calling `fn`, the value of `this` returned is still the one set by the call to `getThisGetter`, which is `obj`. If the returned function was not an arrow function, such calls would cause the `this` value to be `globalThis`, because `getThisGetter` is non-strict.

 js 

```
const fn = obj.getThisGetter();
console.log(fn() === obj); // true
```

 

But be careful if you unbind the method of `obj` without calling it, because `getThisGetter` is still a method that has a varying `this` value. Calling `fn2()()` in the following example returns `globalThis`, because it follows the `this` from `fn2()`, which is `globalThis` since it's called without being attached to any object.

 js 

```
const fn2 = obj.getThisGetter;
console.log(fn2()() === globalThis); // true in non-strict mode
```

 

This behavior is very useful when defining callbacks. Usually, each function expression creates its own `this` binding, which shadows the `this` value of the upper scope. Now, you can define functions as arrow functions if you don't care about the `this` value, and only create `this` bindings where you do (e.g., in class methods). See example with `setTimeout()` .

 
 

### this with a getter or setter 

 
 

`this` in getters and setters is based on which object the property is accessed on, not which object the property is defined on. A function used as getter or setter has its `this` bound to the object from which the property is being set or gotten.

 js 

```
function sum() {
  return this.a + this.b + this.c;
}

const o = {
  a: 1,
  b: 2,
  c: 3,
  get average() {
    return (this.a + this.b + this.c) / 3;
  },
};

Object.defineProperty(o, "sum", {
  get: sum,
  enumerable: true,
  configurable: true,
});

console.log(o.average, o.sum); // 2 6
```

 
 
 

### this in DOM event handlers 

 
 

When a function is used as an event handler, its `this` parameter is bound to the DOM element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than `addEventListener()` ).

 js 

```
// When called as a listener, turns the related element blue
function bluify(e) {
  // Always true
  console.log(this === e.currentTarget);
  // true when currentTarget and target are the same object
  console.log(this === e.target);
  this.style.backgroundColor = "#A5D9F3";
}

// Get a list of every element in the document
const elements = document.getElementsByTagName("*");

// Add bluify as a click listener so when the
// element is clicked on, it turns blue
for (const element of elements) {
  element.addEventListener("click", bluify);
}
```

 
 
 

### this in inline event handlers 

 
 

When the code is called from an inline event handler attribute , its `this` is bound to the DOM element on which the listener is placed:

 html 

```
<button onclick="alert(this.tagName.toLowerCase());">Show this</button>
```

 

The above alert shows `button`. Note, however, that only the outer scope has its `this` bound this way:

 html 

```
<button onclick="alert((function () { return this; })());">
  Show inner this
</button>
```

 

In this case, the `this` parameter of the inner function is bound to `globalThis` (i.e., the default object in non–strict mode where `this` isn't passed in the call).

 
 

### Bound methods in classes 

 
 

Just like with regular functions, the value of `this` within methods depends on how they are called. Sometimes it is useful to override this behavior so that `this` within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:

 js 

```
class Car {
  constructor() {
    // Bind sayBye but not sayHi to show the difference
    this.sayBye = this.sayBye.bind(this);
  }

  sayHi() {
    console.log(`Hello from ${this.name}`);
  }

  sayBye() {
    console.log(`Bye from ${this.name}`);
  }

  get name() {
    return "Ferrari";
  }
}

class Bird {
  get name() {
    return "Tweety";
  }
}

const car = new Car();
const bird = new Bird();

// The value of 'this' in methods depends on their caller
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// For bound methods, 'this' doesn't depend on the caller
bird.sayBye = car.sayBye;
bird.sayBye(); // Bye from Ferrari
```

 
 

 Note: 
Classes are always in strict mode. Calling methods with an undefined `this` will throw an error if the method tries to access properties on `this`.

 js 

```
const carSayHi = car.sayHi;
carSayHi(); // TypeError because the 'sayHi' method tries to access 'this.name', but 'this' is undefined in strict mode.
```

 
 

Note, however, that auto-bound methods suffer from the same problem as using arrow functions for class properties : each instance of the class will have its own copy of the method, which increases memory usage. Only use it where absolutely necessary. You can also mimic the implementation of `Intl.NumberFormat.prototype.format()` : define the property as a getter that returns a bound function when accessed and saves it, so that the function is only created once and only created when necessary.

 
 

### this in with statements 

 
 

Although `with` statements are deprecated and not available in strict mode, they still serve as an exception to the normal `this` binding rules. If a function is called within a `with` statement and that function is a property of the scope object, the `this` value is bound to the scope object, as if the `obj.` prefix exists.

 js 

```
const obj = {
  foo() {
    return this;
  },
};

with (obj) {
  console.log(foo() === obj); // true
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Strict mode 

- `globalThis` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 18, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Strict mode - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode

Strict mode - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Strict mode

 
 
 

 Note: 
Sometimes you'll see the default, non-strict mode referred to as sloppy mode . This isn't an official term, but be aware of it, just in case.

 

JavaScript's strict mode is a way to opt in to a restricted variant of JavaScript, thereby implicitly opting-out of " sloppy mode ". Strict mode isn't just a subset: it intentionally has different semantics from normal code. Strict mode code and non-strict mode code can coexist, so scripts can opt into strict mode incrementally.

Strict mode makes several changes to normal JavaScript semantics:

- Eliminates some JavaScript silent errors by changing them to throw errors.

- Fixes mistakes that make it difficult for JavaScript engines to perform optimizations: strict mode code can sometimes be made to run faster than identical code that's not strict mode.

- Prohibits some syntax likely to be defined in future versions of ECMAScript.

 
 
 
 
 
 

## Invoking strict mode 

 
 

Strict mode applies to entire scripts or to individual functions . It doesn't apply to block statements enclosed in `{}` braces; attempting to apply it to such contexts does nothing. `eval` code, `Function` code, event handler attributes, strings passed to `setTimeout()` , and related functions are either function bodies or entire scripts, and invoking strict mode in them works as expected.

 
 

### Strict mode for scripts 

 
 

To invoke strict mode for an entire script, put the exact statement `"use strict";` (or `'use strict';`) before any other statements.

 js 

```
// Whole-script strict mode syntax
"use strict";
const v = "Hi! I'm a strict mode script!";
```

 
 
 

### Strict mode for functions 

 
 

Likewise, to invoke strict mode for a function, put the exact statement `"use strict";` (or `'use strict';`) in the function's body before any other statements.

 js 

```
function myStrictFunction() {
  // Function-level strict mode syntax
  "use strict";
  function nested() {
    return "And so am I!";
  }
  return `Hi! I'm a strict mode function! ${nested()}`;
}
function myNotStrictFunction() {
  return "I'm not strict.";
}
```

 

The `"use strict"` directive can only be applied to the body of functions with simple parameters. Using `"use strict"` in functions with rest , default , or destructured parameters is a syntax error .

 js 

```
function sum(a = 1, b = 2) {
  // SyntaxError: "use strict" not allowed in function with default parameter
  "use strict";
  return a + b;
}
```

 
 
 

### Strict mode for modules 

 
 

The entire contents of JavaScript modules are automatically in strict mode, with no statement needed to initiate it.

 js 

```
function myStrictFunction() {
  // because this is a module, I'm strict by default
}
export default myStrictFunction;
```

 
 
 

### Strict mode for classes 

 
 

All parts of a class 's body are strict mode code, including both class declarations and class expressions .

 js 

```
class C1 {
  // All code here is evaluated in strict mode
  test() {
    delete Object.prototype;
  }
}
new C1().test(); // TypeError, because test() is in strict mode

const C2 = class {
  // All code here is evaluated in strict mode
};

// Code here may not be in strict mode
delete Object.prototype; // Will not throw error
```

 
 
 

## Changes in strict mode 

 
 

Strict mode changes both syntax and runtime behavior. Changes generally fall into these categories:

- changes converting mistakes into errors (as syntax errors or at runtime)

- changes simplifying how variable references are resolved

- changes simplifying `eval` and `arguments`

- changes making it easier to write "secure" JavaScript

- changes anticipating future ECMAScript evolution.

 
 

### Converting mistakes into errors 

 
 

Strict mode changes some previously-accepted mistakes into errors. JavaScript was designed to be easy for novice developers, and sometimes it gives operations which should be errors non-error semantics. Sometimes this fixes the immediate problem, but sometimes this creates worse problems in the future. Strict mode treats these mistakes as errors so that they're discovered and promptly fixed.

#### Assigning to undeclared variables

Strict mode makes it impossible to accidentally create global variables. In sloppy mode, mistyping a variable in an assignment creates a new property on the global object and continues to "work". Assignments which would accidentally create global variables throw an error in strict mode:

 
 js 

```
"use strict";
let mistypeVariable;

// Assuming no global variable mistypeVarible exists
// this line throws a ReferenceError due to the
// misspelling of "mistypeVariable" (lack of an "a")
mistypeVarible = 17;
```

 

#### Failing to assign to object properties

Strict mode makes assignments which would otherwise silently fail to throw an exception. There are three ways to fail a property assignment:

- assignment to a non-writable data property

- assignment to a getter-only accessor property

- assignment to a new property on a non-extensible object

For example, `NaN` is a non-writable global variable. In sloppy mode, assigning to `NaN` does nothing; the developer receives no failure feedback. In strict mode, assigning to `NaN` throws an exception.

 js 

```
"use strict";

// Assignment to a non-writable global
undefined = 5; // TypeError
Infinity = 5; // TypeError

// Assignment to a non-writable property
const obj1 = {};
Object.defineProperty(obj1, "x", { value: 42, writable: false });
obj1.x = 9; // TypeError

// Assignment to a getter-only property
const obj2 = {
  get x() {
    return 17;
  },
};
obj2.x = 5; // TypeError

// Assignment to a new property on a non-extensible object
const fixed = {};
Object.preventExtensions(fixed);
fixed.newProp = "ohai"; // TypeError
```

 

#### Failing to delete object properties

Attempts to delete a non-configurable or otherwise undeletable (e.g., it's intercepted by a proxy's `deleteProperty` handler which returns `false`) property throw in strict mode (where before the attempt would have no effect):

 js 

```
"use strict";
delete Object.prototype; // TypeError
delete [].length; // TypeError
```

 

Strict mode also forbids deleting plain names. `delete name` in strict mode is a syntax error:

 js 

```
"use strict";

var x;
delete x; // syntax error
```

 

If the name is a configurable global property, prefix it with `globalThis` to delete it.

 js 

```
"use strict";

delete globalThis.x;
```

 

#### Duplicate parameter names

Strict mode requires that function parameter names be unique. In sloppy mode, the last duplicated argument hides previous identically-named arguments. Those previous arguments remain available through `arguments` , so they're not completely inaccessible. Still, this hiding makes little sense and is probably undesirable (it might hide a typo, for example), so in strict mode, duplicate argument names are a syntax error:

 js 

```
function sum(a, a, c) {
  // syntax error
  "use strict";
  return a + a + c; // wrong if this code ran
}
```

 

It is also a syntax error in non-strict mode to have duplicate parameter names, if the function has a default parameter, rest parameter, or destructured parameter.

#### Legacy octal literals

Strict mode forbids a `0`-prefixed octal literal . In sloppy mode, a number beginning with a `0`, such as `0644`, is interpreted as an octal number (`0644 === 420`), if all digits are smaller than 8. Novice developers sometimes believe a leading-zero prefix has no semantic meaning, so they might use it as an alignment device — but this changes the number's meaning! A leading-zero syntax for the octal is rarely useful and can be mistakenly used, so strict mode makes it a syntax error:

 js 

```
"use strict";
const sum =
  015 + // syntax error
  197 +
  142;
```

 

The standardized way to denote octal literals is via the `0o` prefix. For example:

 js 

```
const sumWithOctal = 0o10 + 8;
console.log(sumWithOctal); // 16
```

 

Octal escape sequences, such as `"\45"`, which is equal to `"%"`, can be used to represent characters by extended- ASCII character code numbers in octal. In strict mode, this is a syntax error . More formally, it's disallowed to have `\` followed by any decimal digit other than `0`, or `\0` followed by a decimal digit; for example `\9` and `\07`.

#### Setting properties on primitive values

Strict mode forbids setting properties on primitive values. Accessing a property on a primitive implicitly creates a wrapper object that's unobservable, so in sloppy mode, setting properties is ignored (no-op). In strict mode, a `TypeError` is thrown.

 js 

```
"use strict";

false.true = ""; // TypeError
(14).sailing = "home"; // TypeError
"with".you = "far away"; // TypeError
```

 

#### Duplicate property names

Duplicate property names used to be considered a `SyntaxError` in strict mode. With the introduction of computed property names , making duplication possible at runtime, this restriction was removed in ES2015.

 js 

```
"use strict";
const o = { p: 1, p: 2 }; // syntax error prior to ECMAScript 2015
```

 
 

 Note: 
Making code that used to error become non-errors is always considered backwards-compatible. This is a good part of the language being strict about throwing errors: it leaves room for future semantic changes.

 
 
 

### Simplifying scope management 

 
 

Strict mode simplifies how variable names map to particular variable definitions in the code. Many compiler optimizations rely on the ability to say that variable X is stored in that location: this is critical to fully optimizing JavaScript code. JavaScript sometimes makes this basic mapping of name to variable definition in the code impossible to perform until runtime. Strict mode removes most cases where this happens, so the compiler can better optimize strict mode code.

#### Removal of the with statement

Strict mode prohibits `with` . The problem with `with` is that any name inside the block might map either to a property of the object passed to it, or to a variable in surrounding (or even global) scope, at runtime; it's impossible to know which beforehand. Strict mode makes `with` a syntax error, so there's no chance for a name in a `with` to refer to an unknown location at runtime:

 js 

```
"use strict";
const x = 17;
with (obj) {
  // Syntax error
  // If this weren't strict mode, would this be const x, or
  // would it instead be obj.x? It's impossible in general
  // to say without running the code, so the name can't be
  // optimized.
  x;
}
```

 

The alternative of assigning the object to a short name variable, then accessing the corresponding property on that variable, stands ready to replace `with`.

#### Non-leaking eval

In strict mode, `eval` does not introduce new variables into the surrounding scope . In sloppy mode, `eval("var x;")` introduces a variable `x` into the surrounding function or the global scope. This means that, in general, in a function containing a call to `eval`, every name not referring to an argument or local variable must be mapped to a particular definition at runtime (because that `eval` might have introduced a new variable that would hide the outer variable). In strict mode, `eval` creates variables only for the code being evaluated, so `eval` can't affect whether a name refers to an outer variable or some local variable:

 js 

```
var x = 17;
var evalX = eval("'use strict'; var x = 42; x;");
console.assert(x === 17);
console.assert(evalX === 42);
```

 

Whether the string passed to `eval()` is evaluated in strict mode depends on how `eval()` is invoked ( direct eval or indirect eval ).

#### Block-scoped function declarations

The JavaScript language specification, since its start, had not allowed function declarations nested in block statements. However, it was so intuitive that most browsers implemented it as an extension grammar. Unfortunately, the implementations' semantics diverged, and it became impossible for the language specification to reconcile all implementations. Therefore, block-scoped function declarations are only explicitly specified in strict mode (whereas they were once disallowed in strict mode), while sloppy mode behavior remains divergent among browsers.

 
 

### Making eval and arguments simpler 

 
 

Strict mode makes `arguments` and `eval` less bizarrely magical. Both involve a considerable amount of magical behavior in sloppy mode: `eval` to add or remove bindings and to change binding values, and `arguments` syncing named arguments with its indexed properties. Strict mode makes great strides toward treating `eval` and `arguments` as keywords.

#### Preventing binding or assigning eval and arguments

The names `eval` and `arguments` can't be bound or assigned in language syntax. All these attempts to do so are syntax errors:

 js 

```
"use strict";
eval = 17;
arguments++;
++eval;
const obj = { set p(arguments) {} };
let eval;
try {
} catch (arguments) {}
function x(eval) {}
function arguments() {}
const y = function eval() {};
const f = new Function("arguments", "'use strict'; return 17;");
```

 

#### No syncing between parameters and arguments indices

Strict mode code doesn't sync indices of the `arguments` object with each parameter binding. In a sloppy mode function whose first argument is `arg`, setting `arg` also sets `arguments[0]`, and vice versa (unless no arguments were provided or `arguments[0]` is deleted). `arguments` objects for strict mode functions store the original arguments when the function was invoked. `arguments[i]` does not track the value of the corresponding named argument, nor does a named argument track the value in the corresponding `arguments[i]`.

 js 

```
function f(a) {
  "use strict";
  a = 42;
  return [a, arguments[0]];
}
const pair = f(17);
console.assert(pair[0] === 42);
console.assert(pair[1] === 17);
```

 
 
 

### "Securing" JavaScript 

 
 

Strict mode makes it easier to write "secure" JavaScript. Some websites now provide ways for users to write JavaScript which will be run by the website on behalf of other users . JavaScript in browsers can access the user's private information, so such JavaScript must be partially transformed before it is run, to censor access to forbidden functionality. JavaScript's flexibility makes it effectively impossible to do this without many runtime checks. Certain language functions are so pervasive that performing runtime checks has a considerable performance cost. A few strict mode tweaks, plus requiring that user-submitted JavaScript be strict mode code and that it be invoked in a certain manner, substantially reduce the need for those runtime checks.

#### No this substitution

The value passed as `this` to a function in strict mode is not forced into being an object (a.k.a. "boxed"). For a sloppy mode function, `this` is always an object: either the provided object, if called with an object-valued `this`; or the boxed value of `this`, if called with a primitive as `this`; or the global object, if called with `undefined` or `null` as `this`. (Use `call` , `apply` , or `bind` to specify a particular `this`.) Not only is automatic boxing a performance cost, but exposing the global object in browsers is a security hazard because the global object provides access to functionality that "secure" JavaScript environments must restrict. Thus for a strict mode function, the specified `this` is not boxed into an object, and if unspecified, `this` is `undefined` instead of `globalThis` :

 js 

```
"use strict";
function fun() {
  return this;
}
console.assert(fun() === undefined);
console.assert(fun.call(2) === 2);
console.assert(fun.apply(null) === null);
console.assert(fun.call(undefined) === undefined);
console.assert(fun.bind(true)() === true);
```

 

#### Removal of stack-walking properties

In strict mode it's no longer possible to "walk" the JavaScript stack. Many implementations used to implement some extension features that make it possible to detect the upstream caller of a function. When a function `fun` is in the middle of being called, `fun.caller` is the function that most recently called `fun`, and `fun.arguments` is the `arguments` for that invocation of `fun`. Both extensions are problematic for "secure" JavaScript because they allow "secured" code to access "privileged" functions and their (potentially unsecured) arguments. If `fun` is in strict mode, both `fun.caller` and `fun.arguments` are non-deletable properties which throw when set or retrieved:

 js 

```
function restricted() {
  "use strict";
  restricted.caller; // throws a TypeError
  restricted.arguments; // throws a TypeError
}
function privilegedInvoker() {
  return restricted();
}
privilegedInvoker();
```

 

Similarly, `arguments.callee` is no longer supported. In sloppy mode, `arguments.callee` refers to the enclosing function. This use case is weak: name the enclosing function! Moreover, `arguments.callee` substantially hinders optimizations like inlining functions, because it must be made possible to provide a reference to the un-inlined function if `arguments.callee` is accessed. `arguments.callee` for strict mode functions is a non-deletable property which throws an error when set or retrieved:

 js 

```
"use strict";
function f() {
  return arguments.callee;
}
f(); // throws a TypeError
```

 
 
 

### Future-proofing JavaScript 

 
 

#### Extra reserved words

 Reserved words are identifiers that can't be used as variable names. Strict mode reserves some more names than sloppy mode, some of which are already used in the language, and some of which are reserved for the future to make future syntax extensions easier to implement.

- `implements`

- `interface`

- `let` 

- `package`

- `private`

- `protected`

- `public`

- `static` 

- `yield` 

 
 

## Transitioning to strict mode 

 
 

Strict mode has been designed so that the transition to it can be made gradually. It is possible to change each file individually and even to transition code to strict mode down to the function granularity.

You can migrate a codebase to strict mode by first adding `"use strict"` to a piece of source code, and then fixing all execution errors, while watching out for semantic differences.

 
 

### Syntax errors 

 
 

When adding `'use strict';`, the following cases will throw a `SyntaxError` before the script is executing:

- Octal syntax `const n = 023;`

- `with` statement

- Using `delete` on a variable name `delete myVariable`;

- Using `eval` or `arguments` as variable or function argument name

- Using one of the newly reserved keywords (in prevision for future language features): `implements`, `interface`, `let`, `package`, `private`, `protected`, `public`, `static`, and `yield`

- Declaring two function parameters with the same name `function f(a, b, b) {}`

- Declaring the same property name twice in an object literal `{a: 1, b: 3, a: 7}`. This constraint was later removed ( bug 1041128 ).

These errors are good, because they reveal plain errors or bad practices. They occur before the code is running, so they are easily discoverable as long as the code gets parsed by the runtime.

 
 

### New runtime errors 

 
 

JavaScript used to silently fail in contexts where what was done should be an error. Strict mode throws in such cases. If your code base contains such cases, testing will be necessary to be sure nothing is broken. You can screen for such errors at the function granularity level.

- Assigning to an undeclared variable throws a `ReferenceError` . This used to set a property on the global object, which is rarely the expected effect. If you really want to set a value to the global object, explicitly assign it as a property on `globalThis`.

- Failing to assign to an object's property (e.g., it's read-only) throws a `TypeError` . In sloppy mode, this would silently fail.

- Deleting a non-deletable property throws a `TypeError` . In sloppy mode, this would silently fail.

- Accessing `arguments.callee` , `strictFunction.caller` , or `strictFunction.arguments` throws a `TypeError` if the function is in strict mode. If you are using `arguments.callee` to call the function recursively, you can use a named function expression instead.

 
 

### Semantic differences 

 
 

These differences are very subtle differences. It's possible that a test suite doesn't catch this kind of subtle difference. Careful review of your code base will probably be necessary to be sure these differences don't affect the semantics of your code. Fortunately, this careful review can be done gradually down the function granularity.

 
 `this` 
 

In sloppy mode, function calls like `f()` would pass the global object as the `this` value. In strict mode, it is now `undefined`. When a function was called with `call` or `apply` , if the value was a primitive value, this one was boxed into an object (or the global object for `undefined` and `null`). In strict mode, the value is passed directly without conversion or replacement.

 
 `arguments` 
 

In sloppy mode, modifying a value in the `arguments` object modifies the corresponding named argument. This made optimizations complicated for JavaScript engine and made code harder to read/understand. In strict mode, the `arguments` object is created and initialized with the same values than the named arguments, but changes to either the `arguments` object or the named arguments aren't reflected in one another.

 
 `eval` 
 

In strict mode code, `eval` doesn't create a new variable in the scope from which it was called. Also, of course, in strict mode, the string is evaluated with strict mode rules. Thorough testing will need to be performed to make sure nothing breaks. Not using eval if you don't really need it may be another pragmatic solution.

 
 Block-scoped function declarations 
 

In sloppy mode, a function declaration inside a block may be visible outside the block and even callable. In strict mode, a function declaration inside a block is only visible inside the block.

 
 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 
 
 
 
 

## See also 

 
 

- JavaScript modules guide

- Lexical grammar 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Function.prototype.bind() - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind

Function.prototype.bind() - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Function.prototype.bind()

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `bind()` method of `Function` instances creates a new function that, when called, calls this function with its `this` keyword set to the provided value, and a given sequence of arguments preceding any provided when the new function is called.

 
 
 
 
 
 

## Try it 

 
 
 

```
const module = {
  x: 42,
  getX() {
    return this.x;
  },
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// Expected output: undefined

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// Expected output: 42
```

 
 
 

## Syntax 

 
 js 

```
bind(thisArg)
bind(thisArg, arg1)
bind(thisArg, arg1, arg2)
bind(thisArg, arg1, arg2, /* …, */ argN)
```

 
 
 

### Parameters 

 
 
 `thisArg` 
 

The value to be passed as the `this` parameter to the target function `func` when the bound function is called. If the function is not in strict mode , `null` and `undefined` will be replaced with the global object, and primitive values will be converted to objects. The value is ignored if the bound function is constructed using the `new` operator.

 
 `arg1`, …, `argN` Optional 
 

Arguments to prepend to arguments provided to the bound function when invoking `func`.

 
 
 
 

### Return value 

 
 

A copy of the given function with the specified `this` value, and initial arguments (if provided).

 
 

## Description 

 
 

The `bind()` function creates a new bound function . Calling the bound function generally results in the execution of the function it wraps, which is also called the target function . The bound function will store the parameters passed — which include the value of `this` and the first few arguments — as its internal state. These values are stored in advance, instead of being passed at call time. You can generally see `const boundFn = fn.bind(thisArg, arg1, arg2)` as being equivalent to 

```
const boundFn = (...restArgs) => fn.call(thisArg, arg1, arg2, ...restArgs)
```

 for the effect when it's called (but not when `boundFn` is constructed).

A bound function can be further bound by calling `boundFn.bind(thisArg, /* more args */)`, which creates another bound function `boundFn2`. The newly bound `thisArg` value is ignored, because the target function of `boundFn2`, which is `boundFn`, already has a bound `this`. When `boundFn2` is called, it would call `boundFn`, which in turn calls `fn`. The arguments that `fn` ultimately receives are, in order: the arguments bound by `boundFn`, arguments bound by `boundFn2`, and the arguments received by `boundFn2`.

 js 

```
"use strict"; // prevent `this` from being boxed into the wrapper object

function log(...args) {
  console.log(this, ...args);
}
const boundLog = log.bind("this value", 1, 2);
const boundLog2 = boundLog.bind("new this value", 3, 4);
boundLog2(5, 6); // "this value", 1, 2, 3, 4, 5, 6
```

 

A bound function may also be constructed using the `new` operator if its target function is constructable. Doing so acts as though the target function had instead been constructed. The prepended arguments are provided to the target function as usual, while the provided `this` value is ignored (because construction prepares its own `this`, as seen by the parameters of `Reflect.construct` ). If the bound function is directly constructed, `new.target` will be the target function instead. (That is, the bound function is transparent to `new.target`.)

 js 

```
class Base {
  constructor(...args) {
    console.log(new.target === Base);
    console.log(args);
  }
}

const BoundBase = Base.bind(null, 1, 2);

new BoundBase(3, 4); // true, [1, 2, 3, 4]
```

 

However, because a bound function does not have the `prototype` property, it cannot be used as a base class for `extends` .

 js 

```
class Derived extends class {}.bind(null) {}
// TypeError: Class extends value does not have valid prototype property undefined
```

 

When using a bound function as the right-hand side of `instanceof` , `instanceof` would reach for the target function (which is stored internally in the bound function) and read its `prototype` instead.

 js 

```
class Base {}
const BoundBase = Base.bind(null, 1, 2);
console.log(new Base() instanceof BoundBase); // true
```

 

The bound function has the following properties:

 
 `length` 
 

The `length` of the target function minus the number of arguments being bound (not counting the `thisArg` parameter), with 0 being the minimum value.

 
 `name` 
 

The `name` of the target function plus a `"bound "` prefix.

 
 

The bound function also inherits the prototype chain of the target function. However, it doesn't have other own properties of the target function (such as static properties if the target function is a class).

 
 

## Examples 

 
 
 
 

### Creating a bound function 

 
 

The most common use of `bind()` is to make a function that, no matter how it is called, is called with a particular `this` value.

A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its `this` (e.g., by using the method in callback-based code).

Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:

 js 

```
// Top-level 'this' is bound to 'globalThis' in scripts.
this.x = 9;
const module = {
  x: 81,
  getX() {
    return this.x;
  },
};

// The 'this' parameter of 'getX' is bound to 'module'.
console.log(module.getX()); // 81

const retrieveX = module.getX;
// The 'this' parameter of 'retrieveX' is bound to 'globalThis' in non-strict mode.
console.log(retrieveX()); // 9

// Create a new function 'boundGetX' with the 'this' parameter bound to 'module'.
const boundGetX = retrieveX.bind(module);
console.log(boundGetX()); // 81
```

 
 

 Note: 
If you run this example in strict mode , the `this` parameter of `retrieveX` will be bound to `undefined` instead of `globalThis`, causing the `retrieveX()` call to fail.

If you run this example in an ECMAScript module, top-level `this` will be bound to `undefined` instead of `globalThis`, causing the `this.x = 9` assignment to fail.

If you run this example in a Node CommonJS module, top-level `this` will be bound to `module.exports` instead of `globalThis`. However, the `this` parameter of `retrieveX` will still be bound to `globalThis` in non-strict mode and to `undefined` in strict mode. Therefore, in non-strict mode (the default), the `retrieveX()` call will return `undefined` because `this.x = 9` is writing to a different object (`module.exports`) from what `getX` is reading from (`globalThis`).

 

In fact, some built-in "methods" are also getters that return bound functions — one notable example being `Intl.NumberFormat.prototype.format()` , which, when accessed, returns a bound function that you can directly pass as a callback.

 
 

### Partially applied functions 

 
 

Another use of `bind()` is to make a function with pre-specified initial arguments.

These arguments (if any) follow the provided `this` value and are then inserted at the start of the arguments passed to the target function, followed by whatever arguments are passed to the bound function at the time it is called.

 js 

```
function list(...args) {
  return args;
}

function addArguments(arg1, arg2) {
  return arg1 + arg2;
}

console.log(list(1, 2, 3)); // [1, 2, 3]

console.log(addArguments(1, 2)); // 3

// Create a function with a preset leading argument
const leadingThirtySevenList = list.bind(null, 37);

// Create a function with a preset first argument.
const addThirtySeven = addArguments.bind(null, 37);

console.log(leadingThirtySevenList()); // [37]
console.log(leadingThirtySevenList(1, 2, 3)); // [37, 1, 2, 3]
console.log(addThirtySeven(5)); // 42
console.log(addThirtySeven(5, 10)); // 42
// (the last argument 10 is ignored)
```

 
 
 

### With setTimeout() 

 
 

By default, within `setTimeout()` , the `this` keyword will be set to `globalThis` , which is `window` in browsers. When working with class methods that require `this` to refer to class instances, you may explicitly bind `this` to the callback function, in order to maintain the instance.

 js 

```
class LateBloomer {
  constructor() {
    this.petalCount = Math.floor(Math.random() * 12) + 1;
  }
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(this.declare.bind(this), 1000);
  }
  declare() {
    console.log(`I am a beautiful flower with ${this.petalCount} petals!`);
  }
}

const flower = new LateBloomer();
flower.bloom();
// After 1 second, calls 'flower.declare()'
```

 

You can also use arrow functions for this purpose.

 js 

```
class LateBloomer {
  bloom() {
    // Declare bloom after a delay of 1 second
    setTimeout(() => this.declare(), 1000);
  }
}
```

 
 
 

### Bound functions used as constructors 

 
 

Bound functions are automatically suitable for use with the `new` operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided `this` is ignored. However, provided arguments are still prepended to the constructor call.

 js 

```
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return `${this.x},${this.y}`;
};

const p = new Point(1, 2);
p.toString();
// '1,2'

// The thisArg's value doesn't matter because it's ignored
const YAxisPoint = Point.bind(null, 0 /* x */);

const axisPoint = new YAxisPoint(5);
axisPoint.toString(); // '0,5'

axisPoint instanceof Point; // true
axisPoint instanceof YAxisPoint; // true
new YAxisPoint(17, 42) instanceof Point; // true
```

 

Note that you need not do anything special to create a bound function for use with `new` . `new.target` , `instanceof` , `this` etc. all work as expected, as if the constructor was never bound. The only difference is that it can no longer be used for `extends` .

The corollary is that you need not do anything special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using `new` . If you call it without `new`, the bound `this` is suddenly not ignored.

 js 

```
const emptyObj = {};
const YAxisPoint = Point.bind(emptyObj, 0 /* x */);

// Can still be called as a normal function
// (although usually this is undesirable)
YAxisPoint(13);

// The modifications to `this` is now observable from the outside
console.log(emptyObj); // { x: 0, y: 13 }
```

 

If you wish to restrict a bound function to only be callable with `new` , or only be callable without `new`, the target function must enforce that restriction, such as by checking `new.target !== undefined` or using a class instead.

 
 

### Binding classes 

 
 

Using `bind()` on classes preserves most of the class's semantics, except that all static own properties of the current class are lost. However, because the prototype chain is preserved, you can still access static properties inherited from the parent class.

 js 

```
class Base {
  static baseProp = "base";
}

class Derived extends Base {
  static derivedProp = "derived";
}

const BoundDerived = Derived.bind(null);
console.log(BoundDerived.baseProp); // "base"
console.log(BoundDerived.derivedProp); // undefined
console.log(new BoundDerived() instanceof Derived); // true
```

 
 
 

### Transforming methods to utility functions 

 
 

`bind()` is also helpful in cases where you want to transform a method which requires a specific `this` value to a plain utility function that accepts the previous `this` parameter as a normal parameter. This is similar to how general-purpose utility functions work: instead of calling `array.map(callback)`, you use `map(array, callback)`, which allows you to use `map` with array-like objects that are not arrays (for example, `arguments` ) without mutating `Object.prototype`.

Take `Array.prototype.slice()` , for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:

 js 

```
const slice = Array.prototype.slice;

// …

slice.call(arguments);
```

 

Note that you can't save `slice.call` and call it as a plain function, because the `call()` method also reads its `this` value, which is the function it should call. In this case, you can use `bind()` to bind the value of `this` for `call()`. In the following piece of code, `slice()` is a bound version of `Function.prototype.call()` , with the `this` value bound to `Array.prototype.slice()` . This means that additional `call()` calls can be eliminated:

 js 

```
// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function.prototype.bind 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `Function.prototype.bind` in `core-js` 

- `Function.prototype.apply()` 

- `Function.prototype.call()` 

- Functions 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Function.prototype.apply() - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply

Function.prototype.apply() - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Function.prototype.apply()

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `apply()` method of `Function` instances calls this function with a given `this` value, and `arguments` provided as an array (or an array-like object ).

 
 
 
 
 
 

## Try it 

 
 
 

```
const numbers = [5, 6, 2, 3, 7];

const max = Math.max.apply(null, numbers);

console.log(max);
// Expected output: 7

const min = Math.min.apply(null, numbers);

console.log(min);
// Expected output: 2
```

 
 
 

## Syntax 

 
 js 

```
apply(thisArg)
apply(thisArg, argsArray)
```

 
 
 

### Parameters 

 
 
 `thisArg` 
 

The value of `this` provided for the call to `func`. If the function is not in strict mode , `null` and `undefined` will be replaced with the global object, and primitive values will be converted to objects.

 
 `argsArray` Optional 
 

An array-like object, specifying the arguments with which `func` should be called, or `null` or `undefined` if no arguments should be provided to the function.

 
 
 
 

### Return value 

 
 

The result of calling the function with the specified `this` value and arguments.

 
 

## Description 

 
 

 Note: 
This function is almost identical to `call()` , except that the function arguments are passed to `call()` individually as a list, while for `apply()` they are combined in one object, typically an array — for example, `func.call(this, "eat", "bananas")` vs. `func.apply(this, ["eat", "bananas"])`.

 

Normally, when calling a function, the value of `this` inside the function is the object that the function was accessed on. With `apply()`, you can assign an arbitrary value as `this` when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.

You can also use any kind of object which is array-like as the second parameter. In practice, this means that it needs to have a `length` property, and integer ("index") properties in the range `(0..length - 1)`. For example, you could use a `NodeList` , or a custom object like `{ 'length': 2, '0': 'eat', '1': 'bananas' }`. You can also use `arguments` , for example:

 js 

```
function wrapper() {
  return anotherFn.apply(null, arguments);
}
```

 

With the rest parameters and parameter spread syntax , this can be rewritten as:

 js 

```
function wrapper(...args) {
  return anotherFn(...args);
}
```

 

In general, `fn.apply(null, args)` is equivalent to `fn(...args)` with the parameter spread syntax, except `args` is expected to be an array-like object in the former case with `apply()`, and an iterable object in the latter case with spread syntax.

 

 Warning: 
Do not use `apply()` to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means `new.target` is `undefined`, and classes throw an error because they can't be called without `new` . Use `Reflect.construct()` or `extends` instead.

 
 
 

## Examples 

 
 
 
 

### Using apply() to append an array to another 

 
 

You can use `Array.prototype.push()` to append an element to an array. Because `push()` accepts a variable number of arguments, you can also push multiple elements at once. But if you pass an array to `push()`, it will actually add that array as a single element, instead of adding the elements individually, ending up with an array inside an array. On the other hand, `Array.prototype.concat()` does have the desired behavior in this case, but it does not append to the existing array — it creates and returns a new array.

In this case, you can use `apply` to implicitly "spread" an array as a series of arguments.

 js 

```
const array = ["a", "b"];
const elements = [0, 1, 2];
array.push.apply(array, elements);
console.info(array); // ["a", "b", 0, 1, 2]
```

 

The same effect can be achieved with the spread syntax.

 js 

```
const array = ["a", "b"];
const elements = [0, 1, 2];
array.push(...elements);
console.info(array); // ["a", "b", 0, 1, 2]
```

 
 
 

### Using apply() and built-in functions 

 
 

Clever usage of `apply()` allows you to use built-in functions for some tasks that would probably otherwise require manually looping over a collection (or using the spread syntax).

For example, we can use `Math.max()` and `Math.min()` to find out the maximum and minimum value in an array.

 js 

```
// min/max number in an array
const numbers = [5, 6, 2, 3, 7];

// using Math.min/Math.max apply
let max = Math.max.apply(null, numbers);
// This about equal to Math.max(numbers[0], …)
// or Math.max(5, 6, …)

let min = Math.min.apply(null, numbers);

// vs. loop based algorithm
max = -Infinity;
min = Infinity;

for (const n of numbers) {
  if (n > max) {
    max = n;
  }
  if (n < min) {
    min = n;
  }
}
```

 

But beware: by using `apply()` (or the spread syntax) with an arbitrarily long arguments list, you run the risk of exceeding the JavaScript engine's argument length limit.

The consequences of calling a function with too many arguments (that is, more than tens of thousands of arguments) is unspecified and varies across engines. (The JavaScriptCore engine has a hard-coded argument limit of 65536 .) Most engines throw an exception; but there's no normative specification preventing other behaviors, such as arbitrarily limiting the number of arguments actually passed to the applied function. To illustrate this latter case: if such an engine had a limit of four arguments (actual limits are of course significantly higher), it would be as if the arguments `5, 6, 2, 3` had been passed to `apply` in the examples above, rather than the full array.

If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:

 js 

```
function minOfArray(arr) {
  let min = Infinity;
  const QUANTUM = 32768;

  for (let i = 0; i < arr.length; i += QUANTUM) {
    const subMin = Math.min.apply(
      null,
      arr.slice(i, Math.min(i + QUANTUM, arr.length)),
    );
    min = Math.min(subMin, min);
  }

  return min;
}

const min = minOfArray([5, 6, 2, 3, 7]);
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function.prototype.apply 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `arguments` 

- `Function.prototype.bind()` 

- `Function.prototype.call()` 

- `Reflect.apply()` 

- Functions 

- Spread syntax (`...`) 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Function.prototype.call() - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call

Function.prototype.call() - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Function.prototype.call()

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `call()` method of `Function` instances calls this function with a given `this` value and arguments provided individually.

 
 
 
 
 
 

## Try it 

 
 
 

```
function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = "food";
}

console.log(new Food("cheese", 5).name);
// Expected output: "cheese"
```

 
 
 

## Syntax 

 
 js 

```
call(thisArg)
call(thisArg, arg1)
call(thisArg, arg1, arg2)
call(thisArg, arg1, arg2, /* …, */ argN)
```

 
 
 

### Parameters 

 
 
 `thisArg` 
 

The value to use as `this` when calling `func`. If the function is not in strict mode , `null` and `undefined` will be replaced with the global object, and primitive values will be converted to objects.

 
 `arg1`, …, `argN` Optional 
 

Arguments for the function.

 
 
 
 

### Return value 

 
 

The result of calling the function with the specified `this` value and arguments.

 
 

## Description 

 
 

 Note: 
This function is almost identical to `apply()` , except that the function arguments are passed to `call()` individually as a list, while for `apply()` they are combined in one object, typically an array — for example, `func.call(this, "eat", "bananas")` vs. `func.apply(this, ["eat", "bananas"])`.

 

Normally, when calling a function, the value of `this` inside the function is the object that the function was accessed on. With `call()`, you can assign an arbitrary value as `this` when calling an existing function, without first attaching the function to the object as a property. This allows you to use methods of one object as generic utility functions.

 

 Warning: 
Do not use `call()` to chain constructors (for example, to implement inheritance). This invokes the constructor function as a plain function, which means `new.target` is `undefined`, and classes throw an error because they can't be called without `new` . Use `Reflect.construct()` or `extends` instead.

 
 
 

## Examples 

 
 
 
 

### Using call() to invoke a function and specifying the this value 

 
 

In the example below, when we call `greet`, the value of `this` will be bound to object `obj`, even when `greet` is not a method of `obj`.

 js 

```
function greet() {
  console.log(this.animal, "typically sleep between", this.sleepDuration);
}

const obj = {
  animal: "cats",
  sleepDuration: "12 and 16 hours",
};

greet.call(obj); // cats typically sleep between 12 and 16 hours
```

 
 
 

### Using call() to invoke a function without specifying the first argument 

 
 

If the first `thisArg` parameter is omitted, it defaults to `undefined`. In non-strict mode, the `this` value is then substituted with `globalThis` (which is akin to the global object).

 js 

```
globalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // Logs "globProp value is foo"
```

 

In strict mode, the value of `this` is not substituted, so it stays as `undefined`.

 js 

```
"use strict";

globalThis.globProp = "foo";

function display() {
  console.log(`globProp value is ${this.globProp}`);
}

display.call(); // throws TypeError: Cannot read the property of 'globProp' of undefined
```

 
 
 

### Transforming methods to utility functions 

 
 

`call()` is almost equivalent to a normal function call, except that `this` is passed as a normal parameter instead of as the value that the function was accessed on. This is similar to how general-purpose utility functions work: instead of calling `array.map(callback)`, you use `map(array, callback)`, which allows you to use `map` with array-like objects that are not arrays (for example, `arguments` ) without mutating `Object.prototype`.

Take `Array.prototype.slice()` , for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:

 js 

```
const slice = Array.prototype.slice;

// …

slice.call(arguments);
```

 

Note that you can't save `slice.call` and call it as a plain function, because the `call()` method also reads its `this` value, which is the function it should call. In this case, you can use `bind()` to bind the value of `this` for `call()`. In the following piece of code, `slice()` is a bound version of `Function.prototype.call()`, with the `this` value bound to `Array.prototype.slice()` . This means that additional `call()` calls can be eliminated:

 js 

```
// Same as "slice" in the previous example
const unboundSlice = Array.prototype.slice;
const slice = Function.prototype.call.bind(unboundSlice);

// …

slice(arguments);
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function.prototype.call 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `Function.prototype.bind()` 

- `Function.prototype.apply()` 

- `Reflect.apply()` 

- Spread syntax (`...`) 

- Introduction to Object-Oriented JavaScript 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 10, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Arrow function expressions - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions

Arrow function expressions - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Arrow function expressions

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨September 2016⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

An arrow function expression is a compact alternative to a traditional function expression , with some semantic differences and deliberate limitations in usage:

- Arrow functions don't have their own bindings to `this` , `arguments` , or `super` , and should not be used as methods .

- Arrow functions cannot be used as constructors . Calling them with `new` throws a `TypeError` . They also don't have access to the `new.target` keyword.

- Arrow functions cannot use `yield` within their body and cannot be created as generator functions.

 
 
 
 
 
 

## Try it 

 
 
 

```
const materials = ["Hydrogen", "Helium", "Lithium", "Beryllium"];

console.log(materials.map((material) => material.length));
// Expected output: Array [8, 6, 7, 9]
```

 
 
 

## Syntax 

 
 js 

```
() => expression

param => expression

(param) => expression

(param1, paramN) => expression

() => {
  statements
}

param => {
  statements
}

(param1, paramN) => {
  statements
}
```

 

 Rest parameters , default parameters , and destructuring within params are supported, and always require parentheses:

 js 

```
(a, b, ...r) => expression
(a = 400, b = 20, c) => expression
([a, b] = [10, 20]) => expression
({ a, b } = { a: 10, b: 20 }) => expression
```

 

Arrow functions can be `async` by prefixing the expression with the `async` keyword.

 js 

```
async param => expression
async (param1, param2, ...paramN) => {
  statements
}
```

 
 
 

## Description 

 
 

Let's decompose a traditional anonymous function down to the simplest arrow function step-by-step. Each step along the way is a valid arrow function.

 

 Note: 
Traditional function expressions and arrow functions have more differences than their syntax. We will introduce their behavior differences in more detail in the next few subsections.

 
 js 

```
// Traditional anonymous function
(function (a) {
  return a + 100;
});

// 1. Remove the word "function" and place arrow between the argument and opening body brace
(a) => {
  return a + 100;
};

// 2. Remove the body braces and word "return" — the return is implied.
(a) => a + 100;

// 3. Remove the parameter parentheses
a => a + 100;
```

 

In the example above, both the parentheses around the parameter and the braces around the function body may be omitted. However, they can only be omitted in certain cases.

The parentheses can only be omitted if the function has a single simple parameter. If it has multiple parameters, no parameters, or default, destructured, or rest parameters, the parentheses around the parameter list are required.

 js 

```
// Traditional anonymous function
(function (a, b) {
  return a + b + 100;
});

// Arrow function
(a, b) => a + b + 100;

const a = 4;
const b = 2;

// Traditional anonymous function (no parameters)
(function () {
  return a + b + 100;
});

// Arrow function (no parameters)
() => a + b + 100;
```

 

The braces can only be omitted if the function directly returns an expression. If the body has statements, the braces are required — and so is the `return` keyword. Arrow functions cannot guess what or when you want to return.

 js 

```
// Traditional anonymous function
(function (a, b) {
  const chuck = 42;
  return a + b + chuck;
});

// Arrow function
(a, b) => {
  const chuck = 42;
  return a + b + chuck;
};
```

 

Arrow functions are not inherently associated with a name. If the arrow function needs to call itself, use a named function expression instead. You can also assign the arrow function to a variable, allowing you to refer to it through that variable.

 js 

```
// Traditional Function
function bob(a) {
  return a + 100;
}

// Arrow Function
const bob2 = (a) => a + 100;
```

 
 
 

### Function body 

 
 

Arrow functions can have either an expression body or the usual block body .

In an expression body, only a single expression is specified, which becomes the implicit return value. In a block body, you must use an explicit `return` statement.

 js 

```
const func = (x) => x * x;
// expression body syntax, implied "return"

const func2 = (x, y) => {
  return x + y;
};
// with block body, explicit "return" needed
```

 

Returning object literals using the expression body syntax `(params) => { object: literal }` does not work as expected.

 js 

```
const func = () => { foo: 1 };
// Calling func() returns undefined!

const func2 = () => { foo: function () {} };
// SyntaxError: function statement requires a name

const func3 = () => { foo() {} };
// SyntaxError: Unexpected token '{'
```

 

This is because JavaScript only sees the arrow function as having an expression body if the token following the arrow is not a left brace, so the code inside braces ({}) is parsed as a sequence of statements, where `foo` is a label , not a key in an object literal.

To fix this, wrap the object literal in parentheses:

 js 

```
const func = () => ({ foo: 1 });
```

 
 
 

### Cannot be used as methods 

 
 

Arrow function expressions should only be used for non-method functions because they do not have their own `this`. Let's see what happens when we try to use them as methods:

 js 

```
"use strict";

const obj = {
  i: 10,
  b: () => console.log(this.i, this),
  c() {
    console.log(this.i, this);
  },
};

obj.b(); // logs undefined, Window { /* … */ } (or the global object)
obj.c(); // logs 10, Object { /* … */ }
```

 

Another example involving `Object.defineProperty()` :

 js 

```
"use strict";

const obj = {
  a: 10,
};

Object.defineProperty(obj, "b", {
  get: () => {
    console.log(this.a, typeof this.a, this); // undefined 'undefined' Window { /* … */ } (or the global object)
    return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'
  },
});
```

 

Because a class 's body has a `this` context, arrow functions as class fields close over the class's `this` context, and the `this` inside the arrow function's body will correctly point to the instance (or the class itself, for static fields ). However, because it is a closure , not the function's own binding, the value of `this` will not change based on the execution context.

 js 

```
class C {
  a = 1;
  autoBoundMethod = () => {
    console.log(this.a);
  };
}

const c = new C();
c.autoBoundMethod(); // 1
const { autoBoundMethod } = c;
autoBoundMethod(); // 1
// If it were a normal method, it should be undefined in this case
```

 

Arrow function properties are often said to be "auto-bound methods", because the equivalent with normal methods is:

 js 

```
class C {
  a = 1;
  constructor() {
    this.method = this.method.bind(this);
  }
  method() {
    console.log(this.a);
  }
}
```

 
 

 Note: 
Class fields are defined on the instance , not on the prototype , so every instance creation would create a new function reference and allocate a new closure, potentially leading to more memory usage than a normal unbound method.

 

For similar reasons, the `call()` , `apply()` , and `bind()` methods are not useful when called on arrow functions, because arrow functions establish `this` based on the scope the arrow function is defined within, and the `this` value does not change based on how the function is invoked.

 
 

### No binding of arguments 

 
 

Arrow functions do not have their own `arguments` object. Thus, in this example, `arguments` is a reference to the arguments of the enclosing scope:

 js 

```
function foo(n) {
  const f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n
  return f();
}

foo(3); // 3 + 3 = 6
```

 

In most cases, using rest parameters 
is a good alternative to using an `arguments` object.

 js 

```
function foo(n) {
  const f = (...args) => args[0] + n;
  return f(10);
}

foo(1); // 11
```

 
 
 

### Cannot be used as constructors 

 
 

Arrow functions cannot be used as constructors and will throw an error when called with `new` . They also do not have a `prototype` property.

 js 

```
const Foo = () => {};
const foo = new Foo(); // TypeError: Foo is not a constructor
console.log("prototype" in Foo); // false
```

 
 
 

### Cannot be used as generators 

 
 

The `yield` keyword cannot be used in an arrow function's body (except when used within generator functions further nested within the arrow function). As a consequence, arrow functions cannot be used as generators.

 
 

### Line break before arrow 

 
 

An arrow function cannot contain a line break between its parameters and its arrow.

 js 

```
const func = (a, b, c)
  => 1;
// SyntaxError: Unexpected token '=>'
```

 

For the purpose of formatting, you may put the line break after the arrow or use parentheses/braces around the function body, as shown below. You can also put line breaks between parameters.

 js 

```
const func = (a, b, c) =>
  1;

const func2 = (a, b, c) => (
  1
);

const func3 = (a, b, c) => {
  return 1;
};

const func4 = (
  a,
  b,
  c,
) => 1;
```

 
 
 

### Precedence of arrow 

 
 

Although the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with operator precedence compared to regular functions.

 js 

```
let callback;

callback = callback || () => {};
// SyntaxError: invalid arrow-function arguments
```

 

Because `=>` has a lower precedence than most operators, parentheses are necessary to avoid `callback || ()` being parsed as the arguments list of the arrow function.

 js 

```
callback = callback || (() => {});
```

 
 
 

## Examples 

 
 
 
 

### Using arrow functions 

 
 js 

```
// An empty arrow function returns undefined
const empty = () => {};

(() => "foobar")();
// Returns "foobar"
// (this is an Immediately Invoked Function Expression)

const simple = (a) => (a > 15 ? 15 : a);
simple(16); // 15
simple(10); // 10

const max = (a, b) => (a > b ? a : b);

// Easy array filtering, mapping, etc.
const arr = [5, 6, 13, 0, 1, 18, 23];

const sum = arr.reduce((a, b) => a + b);
// 66

const even = arr.filter((v) => v % 2 === 0);
// [6, 0, 18]

const double = arr.map((v) => v * 2);
// [10, 12, 26, 0, 2, 36, 46]

// More concise promise chains
promise
  .then((a) => {
    // …
  })
  .then((b) => {
    // …
  });

// Arrow functions without parameters
setTimeout(() => {
  console.log("I happen sooner");
  setTimeout(() => {
    // deeper code
    console.log("I happen later");
  }, 1);
}, 1);
```

 
 
 

### Using call, bind, and apply 

 
 

The `call()` , `apply()` , and `bind()` methods work as expected with traditional functions, because we establish the scope for each of the methods:

 js 

```
const obj = {
  num: 100,
};

// Setting "num" on globalThis to show how it is NOT used.
globalThis.num = 42;

// A traditional function to operate on "this"
function add(a, b, c) {
  return this.num + a + b + c;
}

console.log(add.call(obj, 1, 2, 3)); // 106
console.log(add.apply(obj, [1, 2, 3])); // 106
const boundAdd = add.bind(obj);
console.log(boundAdd(1, 2, 3)); // 106
```

 

With arrow functions, since our `add` function is essentially created on the `globalThis` (global) scope, it will assume `this` is the `globalThis`.

 js 

```
const obj = {
  num: 100,
};

// Setting "num" on globalThis to show how it gets picked up.
globalThis.num = 42;

// Arrow function
const add = (a, b, c) => this.num + a + b + c;

console.log(add.call(obj, 1, 2, 3)); // 48
console.log(add.apply(obj, [1, 2, 3])); // 48
const boundAdd = add.bind(obj);
console.log(boundAdd(1, 2, 3)); // 48
```

 

Perhaps the greatest benefit of using arrow functions is with methods like `setTimeout()` and `EventTarget.prototype.addEventListener()` that usually require some kind of closure, `call()`, `apply()`, or `bind()` to ensure that the function is executed in the proper scope.

With traditional function expressions, code like this does not work as expected:

 js 

```
const obj = {
  count: 10,
  doSomethingLater() {
    setTimeout(function () {
      // the function executes on the window scope
      this.count++;
      console.log(this.count);
    }, 300);
  },
};

obj.doSomethingLater(); // logs "NaN", because the property "count" is not in the window scope.
```

 

With arrow functions, the `this` scope is more easily preserved:

 js 

```
const obj = {
  count: 10,
  doSomethingLater() {
    // The method syntax binds "this" to the "obj" context.
    setTimeout(() => {
      // Since the arrow function doesn't have its own binding and
      // setTimeout (as a function call) doesn't create a binding
      // itself, the "obj" context of the outer method is used.
      this.count++;
      console.log(this.count);
    }, 300);
  },
};

obj.doSomethingLater(); // logs 11
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-arrow-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Functions 

- `function` 

- `function` expression 

- ES6 In Depth: Arrow functions on hacks.mozilla.org (2015)

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#content

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#search

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#javascript_the_core_language_ecmascript

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#dom_apis

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#other_notable_apis

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#javascript_implementations

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#shells

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### JavaScript technologies overview - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/JavaScript_technologies_overview#tools_resources

JavaScript technologies overview - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# JavaScript technologies overview

 
 
 

Whereas HTML defines a webpage's structure and content and CSS sets the formatting and appearance, JavaScript adds interactivity to a webpage and creates rich web applications.

However, the umbrella term "JavaScript" as understood in a web browser context contains several very different elements. One of them is the core language (ECMAScript), another is the collection of the Web APIs , including the DOM (Document Object Model).

 
 
 
 
 
 

## JavaScript, the core language (ECMAScript) 

 
 

The core language of JavaScript is standardized by the ECMA TC39 committee as a language named ECMAScript. "ECMAScript" is the term for the language standard, but "ECMAScript" and "JavaScript" can be used interchangeably.

This core language is also used in non-browser environments, for example in Node.js .

 
 

### What falls under the ECMAScript scope? 

 
 

Among other things, ECMAScript defines:

- Language syntax (parsing rules, keywords, control flow, object literal initialization, ...)

- Error handling mechanisms ( `throw` , `try...catch` , ability to create user-defined `Error` types)

- Types (boolean, number, string, function, object, ...)

- A prototype-based inheritance mechanism

- Built-in objects and functions, including `JSON` , `Math` , Array methods, `parseInt` , `decodeURI` , etc.

- Strict mode 

- A module system 

- Basic memory model

 
 

### Standardization process 

 
 

ECMAScript editions are approved and published as a standard by the ECMA General Assembly on a yearly basis. All development is public on the Ecma TC39 GitHub organization , which hosts proposals, the official specification text, and meeting notes.

Before the 6th edition of ECMAScript (known as ES6), specifications were published once every several years, and are commonly referred by their major version numbers — ES3, ES5, etc. After ES6, the specification is named by the publishing year — ES2017, ES2018, etc. ES6 is synonymous with ES2015. ESNext is a dynamic name that refers to whatever the next version is at the time of writing. ESNext features are more correctly called proposals, because, by definition, the specification has not been finalized yet.

The current committee-approved snapshot of ECMA-262 is available in PDF and HTML format on Ecma International's ECMA-262 language specification page . ECMA-262 and ECMA-402 are continuously maintained and kept up to date by the specification editors; the TC39 website hosts the latest, up-to-date ECMA-262 and ECMA-402 versions.

New language features, including introduction of new syntaxes and APIs and revision of existing behaviors, are discussed in the form of proposals. Each proposal goes through a 4-stage process , and is typically implemented by JavaScript engines at stage 3 or stage 4 and thus available for public consumption.

See Wikipedia ECMAScript entry for more information on ECMAScript history.

 
 

### Internationalization API 

 
 

The ECMAScript Internationalization API Specification is an addition to the ECMAScript Language Specification, also standardized by Ecma TC39. The internationalization API provides collation (string comparison), number formatting, and date-and-time formatting for JavaScript applications, letting the applications choose the language and tailor the functionality to their needs. The initial standard was approved in December 2012; the status of implementations in browsers is tracked in the documentation of the `Intl` object. The Internationalization specification is nowadays also ratified on a yearly basis and browsers constantly improve their implementation.

 
 

### Related resources 

 
 

There are a variety of ways you can participate in or just track current work on the ECMAScript Language Specification and the ECMAScript Internationalization API Specification and related resources:

- ECMAScript Language Specification repo 

- ECMAScript Internationalization API Specification repo 

- ECMAScript proposals repo 

- ECMAScript conformance test suite repo 

- TC39 meeting notes 

- ECMAScript spec discussion; current mailing list 

- ECMAScript spec discussion; historical mailing-list archives (until March 2021) 

 
 

## DOM APIs 

 
 
 
 

### WebIDL 

 
 

The WebIDL specification provides the glue between the DOM technologies and ECMAScript.

 
 

### The Core of the DOM 

 
 

The Document Object Model (DOM) is a cross-platform, language-independent convention for representing and interacting with objects in HTML, XHTML and XML documents. Objects in the DOM tree may be addressed and manipulated by using methods on the objects. Nowadays, the DOM core spec is maintained by WHATWG (superseding the W3C version). It defines language-agnostic interfaces that abstract HTML and XML documents as objects, and also defines mechanisms to manipulate this abstraction. This includes: `Node` , `Element` , `DocumentFragment` , `Document` , `DOMImplementation` , `Event` , `EventTarget` , and more.

From the ECMAScript point of view, objects defined in the DOM specification are called "host objects".

 
 

### HTML DOM 

 
 

 HTML , the Web's markup language, is specified in terms of the DOM. Layered above the abstract concepts defined in DOM Core, HTML also defines the meaning of elements. The HTML DOM includes such things as the `className` property on HTML elements, or APIs such as `Document.body` .

The HTML specification also defines restrictions on documents; for example, it requires all children of a `
` element, which represents an unordered list, to be `- ` elements, as those represent list items. In general, it also forbids using elements and attributes that aren't defined in a standard.

Looking for the `Document` object, `Window` object, and the other DOM elements? Read the DOM documentation .

 
 

## Other notable APIs 

 
 

 The `setTimeout()` and `setInterval()` functions were first specified on the `Window` interface in HTML Standard.

- XMLHttpRequest makes it possible to send asynchronous HTTP requests.

- The Fetch API provides a more ergonomic abstraction for network requests.

- The CSS Object Model abstract CSS rules as objects.

- WebWorkers allows parallel computation.

- WebSockets allows low-level bidirectional communication.

- Canvas 2D Context is a drawing API for ` ` .

- The WebAssembly interface provides utilities for communication between JavaScript code and WebAssembly modules.

Non-browser environments (like Node.js) often do not have DOM APIs — because they don't interact with a document — but they still usually implement many web APIs, such as `fetch()` and `setTimeout()` .

 
 

## JavaScript implementations 

 
 

JavaScript engines used in current web browsers include:

- Mozilla's SpiderMonkey , used in Firefox, Servo, and Flow. Other non-browser usage includes MongoDB, CouchDB, and more. This was the first ever JavaScript engine, created by Brendan Eich at Netscape.

- Google's V8 , used in Chrome and Chromium-based browsers such as Opera, Edge, and Brave. Other non-browser usage includes Node.js , Deno , Electron , and more.

- Apple's JavaScriptCore (also known as SquirrelFish/Nitro), used in Safari and other WebKit-based browsers. Other non-browser usage includes Bun .

- LibJS , used in Ladybird .

Some JavaScript engines used in earlier browsers include:

- Carakan , used in Opera before it became a Chromium-based browser.

- Microsoft's Chakra , used in Internet Explorer (although the language it implements is formally called "JScript" to avoid trademark issues). Earlier versions of Edge used another JavaScript engine, confusingly also called Chakra , before it became a Chromium-based browser.

Some JavaScript engines specifically tailored for non-browser purposes include:

- Engine262 , written in JavaScript and intended essentially as a reference implementation of the language.

- Meta's Hermes , optimized for React Native .

- Mozilla's Rhino , written in Java.

- Oracle's GraalJS , written in Java and built on top of GraalVM.

- Moddable XS , intended for IoT/embedded systems.

- QuickJS , intended to be small and lightweight.

JavaScript engines expose a public API which application developers can use to integrate JavaScript into their software. By far, the most common host environment for JavaScript is web browsers. Web browsers typically use the public API to create host objects responsible for reflecting the DOM into JavaScript.

Another common application for JavaScript is as a (Web) server-side scripting language. A JavaScript web server exposes host objects representing a HTTP request and response objects, which can then be manipulated by a JavaScript program to dynamically generate web pages. Node.js is a popular example of this.

 
 

## Shells 

 
 

A JavaScript shell allows you to quickly test snippets of JavaScript code without having to reload a web page. They are extremely useful for developing and debugging code.

 
 

### Standalone JavaScript shells 

 
 

The following JavaScript shells are stand-alone environments, like Perl or Python.

- Node.js - Node.js is a platform for easily building fast, scalable network applications.

- ShellJS - Portable Unix shell commands for Node.js.

 
 

### Browser-based JavaScript shells 

 
 

The following JavaScript shells run code through the browser's JavaScript engine.

- Firefox has a built-in JavaScript console , which support multi-line editing.

- Babel REPL - A browser-based REPL for experimenting with future JavaScript.

- TypeScript playground — A browser-based playground for experimenting both new JavaScript features (via the tsc compiler) and TypeScript syntax.

 
 

## Tools & resources 

 
 

Helpful tools for writing and debugging your JavaScript code.

 
 Firefox Developer Tools 
 

 Web Console , JavaScript Profiler , Debugger , and more.

 
 Learn JavaScript 
 

An excellent resource for aspiring web developers — Learn JavaScript in an interactive environment, with short lessons and interactive tests, guided by automated assessment. The first 40 lessons are free, and the complete course is available for a small one-time payment.

 
 TogetherJS 
 

Collaboration made easy. By adding TogetherJS to your site, your users can help each other out on a website in real-time!

 
 Stack Overflow 
 

Stack Overflow questions tagged with "JavaScript".

 
 JSFiddle 
 

Edit JavaScript, CSS, and HTML and get live results. Use external resources and collaborate with your team online.

 
 Plunker 
 

Plunker is an online community for creating, collaborating on, and sharing your web development ideas. Edit your JavaScript, CSS, and HTML files and get live results and file structure.

 
 JS Bin 
 

JS Bin is an open-source collaborative web development debugging tool.

 
 CodePen 
 

CodePen is another collaborative web development tool used as a live result playground.

 
 StackBlitz 
 

StackBlitz is another online playground/debugging tool, which can host and deploy full-stack applications using React, Angular, etc.

 
 RunJS 
 

RunJS is a desktop playground/scratchpad tool, which provides live results and access to both Node and Browser APIs.

 
 
 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Oct 27, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Infinity - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity

Infinity - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Infinity

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `Infinity` global property is a numeric value representing infinity.

 
 
 
 
 
 

## Try it 

 
 
 

```
const maxNumber = 10 ** 1000; // Max positive number

if (maxNumber === Infinity) {
  console.log("Let's call it Infinity!");
  // Expected output: "Let's call it Infinity!"
}

console.log(1 / maxNumber);
// Expected output: 0
```

 
 
 

## Value 

 
 

The same number value as `Number.POSITIVE_INFINITY` .

 Property attributes of `Infinity` Writable no Enumerable no Configurable no 
 
 

## Description 

 
 

`Infinity` is a property of the global object . In other words, it is a variable in global scope.

The value `Infinity` (positive infinity) is greater than any other number.

This value behaves slightly differently than mathematical infinity; see `Number.POSITIVE_INFINITY` for details.

 
 

## Examples 

 
 
 
 

### Using Infinity 

 
 js 

```
console.log(Infinity); /* Infinity */
console.log(Infinity + 1); /* Infinity */
console.log(10 ** 1000); /* Infinity */
console.log(Math.log(0)); /* -Infinity */
console.log(1 / Infinity); /* 0 */
console.log(1 / 0); /* Infinity */
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-value-properties-of-the-global-object-infinity 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `Number.NEGATIVE_INFINITY` 

- `Number.POSITIVE_INFINITY` 

- `Number.isFinite` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### NaN - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN

NaN - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# NaN

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `NaN` global property is a value representing Not-A-Number.

 
 
 
 
 
 

## Try it 

 
 
 

```
function sanitize(x) {
  if (isNaN(x)) {
    return NaN;
  }
  return x;
}

console.log(sanitize("1"));
// Expected output: "1"

console.log(sanitize("NotANumber"));
// Expected output: NaN
```

 
 
 

## Value 

 
 

The same number value as `Number.NaN` .

 Property attributes of `NaN` Writable no Enumerable no Configurable no 
 
 

## Description 

 
 

`NaN` is a property of the global object . In other words, it is a variable in global scope.

In modern browsers, `NaN` is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.

There are five different types of operations that return `NaN`:

- Failed number conversion (e.g., explicit ones like `parseInt("blabla")`, `Number(undefined)`, or implicit ones like `Math.abs(undefined)`)

- Math operation where the result is not a real number (e.g., `Math.sqrt(-1)`)

- Indeterminate form (e.g., `0 * Infinity`, `1 ** Infinity`, `Infinity / Infinity`, `Infinity - Infinity`)

- A method or expression whose operand is or gets coerced to `NaN` (e.g., `7 ** NaN`, `7 * "blabla"`) — this means `NaN` is contagious

- Other cases where an invalid value is to be represented as a number (e.g., an invalid Date `new Date("blabla").getTime()`, `"".charCodeAt(1)`)

`NaN` and its behaviors are not invented by JavaScript. Its semantics in floating point arithmetic (including that `NaN !== NaN`) are specified by IEEE 754 . `NaN`'s behaviors include:

- If `NaN` is involved in a mathematical operation (but not bitwise operations ), the result is usually also `NaN`. (See counter-example below.)

- When `NaN` is one of the operands of any relational comparison (`>`, ` =`, ` `==` , `!=` , `===` , and `!==` ) to any other value — including to another `NaN` value.

`NaN` is also one of the falsy values in JavaScript.

 
 

## Examples 

 
 
 
 

### Testing against NaN 

 
 

To tell if a value is `NaN`, use `Number.isNaN()` or `isNaN()` to most clearly determine whether a value is `NaN` — or, since `NaN` is the only value that compares unequal to itself, you can perform a self-comparison like `x !== x`.

 js 

```
NaN === NaN; // false
Number.NaN === NaN; // false
isNaN(NaN); // true
isNaN(Number.NaN); // true
Number.isNaN(NaN); // true

function valueIsNaN(v) {
  return v !== v;
}
valueIsNaN(1); // false
valueIsNaN(NaN); // true
valueIsNaN(Number.NaN); // true
```

 

However, do note the difference between `isNaN()` and `Number.isNaN()`: the former will return `true` if the value is currently `NaN`, or if it is going to be `NaN` after it is coerced to a number, while the latter will return `true` only if the value is currently `NaN`:

 js 

```
isNaN("hello world"); // true
Number.isNaN("hello world"); // false
```

 

For the same reason, using a BigInt value will throw an error with `isNaN()` and not with `Number.isNaN()`:

 js 

```
isNaN(1n); // TypeError: Conversion from 'BigInt' to 'number' is not allowed.
Number.isNaN(1n); // false
```

 

Additionally, some array methods cannot find `NaN`, while others can. Namely, the index-finding ones ( `indexOf()` , `lastIndexOf()` ) cannot find `NaN`, while the value-finding ones ( `includes()` ) can:

 js 

```
const arr = [2, 4, NaN, 12];
arr.indexOf(NaN); // -1
arr.includes(NaN); // true

// Methods accepting a properly defined predicate can always find NaN
arr.findIndex((n) => Number.isNaN(n)); // 2
```

 

For more information about `NaN` and its comparison, see Equality comparison and sameness .

 
 

### Observably distinct NaN values 

 
 

It's possible to produce two floating point numbers with different binary representations but are both `NaN`, because in IEEE 754 encoding , any floating point number with exponent `0x7ff` and a non-zero mantissa is `NaN`. In JavaScript, you can do bit-level manipulation using typed arrays .

 js 

```
const f2b = (x) => new Uint8Array(new Float64Array([x]).buffer);
const b2f = (x) => new Float64Array(x.buffer)[0];
// Get a byte representation of NaN
const n = f2b(NaN);
const m = f2b(NaN);
// Change the sign bit, which doesn't matter for NaN
n[7] += 2 ** 7;
// n[0] += 2**7; for big endian processors
const nan2 = b2f(n);
console.log(nan2); // NaN
console.log(Object.is(nan2, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan2)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 255]
// Change the first bit, which is the least significant bit of the mantissa and doesn't matter for NaN
m[0] = 1;
// m[7] = 1; for big endian processors
const nan3 = b2f(m);
console.log(nan3); // NaN
console.log(Object.is(nan3, NaN)); // true
console.log(f2b(NaN)); // Uint8Array(8) [0, 0, 0, 0, 0, 0, 248, 127]
console.log(f2b(nan3)); // Uint8Array(8) [1, 0, 0, 0, 0, 0, 248, 127]
```

 
 
 

### Silently escaping NaN 

 
 

`NaN` propagates through mathematical operations, so it's usually sufficient to test for `NaN` once at the end of calculation to detect error conditions. The only case where `NaN` gets silently escaped is when using exponentiation with an exponent of `0`, which immediately returns `1` without testing the base's value.

 js 

```
NaN ** 0 === 1; // true
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-value-properties-of-the-global-object-nan 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `Number.NaN` 

- `Number.isNaN()` 

- `isNaN()` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### undefined - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined

undefined - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# undefined

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `undefined` global property represents the primitive
value `undefined` . It is one of JavaScript's
 primitive types .

 
 
 
 
 
 

## Try it 

 
 
 

```
function test(t) {
  if (t === undefined) {
    return "Undefined value!";
  }
  return t;
}

let x;

console.log(test(x));
// Expected output: "Undefined value!"
```

 
 
 

## Value 

 
 

The primitive value `undefined` .

 Property attributes of `undefined` Writable no Enumerable no Configurable no 
 
 

## Description 

 
 

`undefined` is a property of the global object . That is, it is a variable in global scope.

In all non-legacy browsers, `undefined` is a non-configurable, non-writable property. Even when this is not the case, avoid overriding it.

A variable that has not been assigned a value is of type `undefined`. A
method or statement also returns `undefined` if the variable that is being
evaluated does not have an assigned value. A function returns `undefined` if
a value was not `returned` .

 

 Note: 
While you can use `undefined` as an identifier (variable name) in any scope other than the global scope (because `undefined` is not a reserved word ), doing so is a very bad idea that will make your code difficult to maintain and debug.

 js 

```
// DON'T DO THIS

(() => {
  const undefined = "foo";
  console.log(undefined, typeof undefined); // foo string
})();

((undefined) => {
  console.log(undefined, typeof undefined); // foo string
})("foo");
```

 
 
 
 

## Examples 

 
 
 
 

### Strict equality and undefined 

 
 

You can use `undefined` and the strict equality and inequality operators to
determine whether a variable has a value. In the following code, the variable
`x` is not initialized, and the `if` statement evaluates to true.

 js 

```
let x;
if (x === undefined) {
  // these statements execute
} else {
  // these statements do not execute
}
```

 
 

 Note: 
The strict equality operator (as opposed to the
 standard equality operator) must be used here, because
`x == undefined` also checks whether `x` is `null`,
while strict equality doesn't. This is because `null` is not equivalent to
`undefined`.

See Equality comparison and sameness for details.

 
 
 

### typeof operator and undefined 

 
 

Alternatively, `typeof` can be used:

 js 

```
let x;
if (typeof x === "undefined") {
  // these statements execute
}
```

 

One reason to use `typeof` is that it does not throw an
error if the variable has not been declared.

 js 

```
// x has not been declared before
// evaluates to true without errors
if (typeof x === "undefined") {
  // these statements execute
}

// Throws a ReferenceError
if (x === undefined) {
}
```

 

However, there is another alternative. JavaScript is a statically scoped language, so
knowing if a variable is declared can be read by seeing whether it is declared in an
enclosing context.

The global scope is bound to the global object , so
checking the existence of a variable in the global context can be done by checking the
existence of a property on the global object , using the
 `in` operator, for instance:

 js 

```
if ("x" in window) {
  // These statements execute only if x is defined globally
}
```

 
 
 

### void operator and undefined 

 
 

The `void` operator is a third alternative.

 js 

```
let x;
if (x === void 0) {
  // these statements execute
}

// y has not been declared before
if (y === void 0) {
  // throws Uncaught ReferenceError: y is not defined
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-undefined 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- JavaScript data types and data structures 

- `null` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Standard built-in objects - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#function_properties

Standard built-in objects - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Standard built-in objects

 
 
 

This chapter documents all of JavaScript's standard, built-in objects, including their methods and properties.

The term "global objects" (or standard built-in objects) here is not to be confused with the global object . Here, "global objects" refer to objects in the global scope .

The global object itself can be accessed using the `this` operator in the global scope. In fact, the global scope consists of the properties of the global object, including inherited properties, if any.

Other objects in the global scope are either created by the user script or provided by the host application. The host objects available in browser contexts are documented in the API reference .

For more information about the distinction between the DOM and core JavaScript , see JavaScript technologies overview .

 
 
 
 
 
 

## Standard objects by category 

 
 
 
 

### Value properties 

 
 

These global properties return a simple value. They have no properties or methods.

- `globalThis` 

- `Infinity` 

- `NaN` 

- `undefined` 

 
 

### Function properties 

 
 

These global functions—functions which are called globally, rather than on an object—directly return their results to the caller.

- `eval()` 

- `isFinite()` 

- `isNaN()` 

- `parseFloat()` 

- `parseInt()` 

- `decodeURI()` 

- `decodeURIComponent()` 

- `encodeURI()` 

- `encodeURIComponent()` 

- `escape()` 
 Deprecated 
 

- `unescape()` 
 Deprecated 
 

 
 

### Fundamental objects 

 
 

These objects represent fundamental language constructs.

- `Object` 

- `Function` 

- `Boolean` 

- `Symbol` 

 
 

### Error objects 

 
 

Error objects are a special type of fundamental object. They include the basic `Error` type, as well as several specialized error types.

- `Error` 

- `AggregateError` 

- `EvalError` 

- `RangeError` 

- `ReferenceError` 

- `SuppressedError` 

- `SyntaxError` 

- `TypeError` 

- `URIError` 

- `InternalError` 
 Non-standard 
 

 
 

### Numbers and dates 

 
 

These are the base objects representing numbers, dates, and mathematical calculations.

- `Number` 

- `BigInt` 

- `Math` 

- `Date` 

- `Temporal` 

 
 

### Text processing 

 
 

These objects represent strings and support manipulating them.

- `String` 

- `RegExp` 

 
 

### Indexed collections 

 
 

These objects represent collections of data which are ordered by an index value. This includes (typed) arrays and array-like constructs.

- `Array` 

- `TypedArray` 

- `Int8Array` 

- `Uint8Array` 

- `Uint8ClampedArray` 

- `Int16Array` 

- `Uint16Array` 

- `Int32Array` 

- `Uint32Array` 

- `BigInt64Array` 

- `BigUint64Array` 

- `Float16Array` 

- `Float32Array` 

- `Float64Array` 

 
 

### Keyed collections 

 
 

These objects represent collections which use keys. The iterable collections ( `Map` and `Set` ) contain elements which are easily iterated in the order of insertion.

- `Map` 

- `Set` 

- `WeakMap` 

- `WeakSet` 

 
 

### Structured data 

 
 

These objects represent and interact with structured data buffers and data coded using JavaScript Object Notation (JSON).

- `ArrayBuffer` 

- `SharedArrayBuffer` 

- `DataView` 

- `Atomics` 

- `JSON` 

 
 

### Managing memory 

 
 

These objects interact with the garbage collection mechanism.

- `WeakRef` 

- `FinalizationRegistry` 

 
 

### Control abstraction objects 

 
 

Control abstractions can help to structure code, especially async code (without using deeply nested callbacks, for example).

- `Iterator` 

- `AsyncIterator` 

- `Promise` 

- `GeneratorFunction` 

- `AsyncGeneratorFunction` 

- `Generator` 

- `AsyncGenerator` 

- `AsyncFunction` 

- `DisposableStack` 

- `AsyncDisposableStack` 

 
 

### Reflection 

 
 

- `Reflect` 

- `Proxy` 

 
 

### Internationalization 

 
 

Additions to the ECMAScript core for language-sensitive functionalities.

- `Intl` 

- `Intl.Collator` 

- `Intl.DateTimeFormat` 

- `Intl.DisplayNames` 

- `Intl.DurationFormat` 

- `Intl.ListFormat` 

- `Intl.Locale` 

- `Intl.NumberFormat` 

- `Intl.PluralRules` 

- `Intl.RelativeTimeFormat` 

- `Intl.Segmenter` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### eval() - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval

eval() - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# eval()

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

 Warning: 
Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use `eval()`. See Never use direct eval()! , below.

 

The `eval()` function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.

 
 
 
 
 
 

## Try it 

 
 
 

```
console.log(eval("2 + 2"));
// Expected output: 4

console.log(eval(new String("2 + 2")));
// Expected output: 2 + 2

console.log(eval("2 + 2") === eval("4"));
// Expected output: true

console.log(eval("2 + 2") === eval(new String("2 + 2")));
// Expected output: false
```

 
 
 

## Syntax 

 
 js 

```
eval(script)
```

 
 
 

### Parameters 

 
 
 `script` 
 

A string representing a JavaScript expression, statement, or sequence of statements. The expression can include variables and properties of existing objects. It will be parsed as a script, so `import` declarations (which can only exist in modules) are not allowed.

 
 
 
 

### Return value 

 
 

The completion value of evaluating the given code. If the completion value is empty, `undefined` is returned. If `script` is not a string primitive, `eval()` returns the argument unchanged.

 
 

### Exceptions 

 
 

Throws any exception that occurs during evaluation of the code, including `SyntaxError` if `script` fails to be parsed as a script.

 
 

## Description 

 
 

`eval()` is a function property of the global object.

The argument of the `eval()` function is a string. It will evaluate the source string as a script body, which means both statements and expressions are allowed. It returns the completion value of the code. For expressions, it's the value the expression evaluates to. Many statements and declarations have completion values as well, but the result may be surprising (for example, the completion value of an assignment is the assigned value, but the completion value of `let` is undefined), so it's recommended to not rely on statements' completion values.

In strict mode, declaring a variable named `eval` or re-assigning `eval` is a `SyntaxError` .

 js 

```
"use strict";

const eval = 1; // SyntaxError: Unexpected eval or arguments in strict mode
```

 

If the argument of `eval()` is not a string, `eval()` returns the argument unchanged. In the following example, passing a `String` object instead of a primitive causes `eval()` to return the `String` object rather than evaluating the string.

 js 

```
eval(new String("2 + 2")); // returns a String object containing "2 + 2"
eval("2 + 2"); // returns 4
```

 

To work around the issue in a generic fashion, you can coerce the argument to a string yourself before passing it to `eval()`.

 js 

```
const expression = new String("2 + 2");
eval(String(expression)); // returns 4
```

 
 
 

### Direct and indirect eval 

 
 

There are two modes of `eval()` calls: direct eval and indirect eval. Direct eval, as the name implies, refers to directly calling the global `eval` function with `eval(...)`. Everything else, including invoking it via an aliased variable, via a member access or other expression, or through the optional chaining `?.` operator, is indirect.

 js 

```
// Direct call
eval("x + y");

// Indirect call using the comma operator to return eval
(0, eval)("x + y");

// Indirect call through optional chaining
eval?.("x + y");

// Indirect call using a variable to store and return eval
const myEval = eval;
myEval("x + y");

// Indirect call through member access
const obj = { eval };
obj.eval("x + y");
```

 

Indirect eval can be seen as if the code is evaluated within a separate ` ` tag. This means:

- 

Indirect eval works in the global scope rather than the local scope, and the code being evaluated doesn't have access to local variables within the scope where it's being called.

 js 

```
function test() {
  const x = 2;
  const y = 4;
  // Direct call, uses local scope
  console.log(eval("x + y")); // Result is 6
  // Indirect call, uses global scope
  console.log(eval?.("x + y")); // Throws because x is not defined in global scope
}
```

 

- 

Indirect `eval` does not inherit the strictness of the surrounding context, and is only in strict mode if the source string itself has a `"use strict"` directive.

 js 

```
function nonStrictContext() {
  eval?.(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval?.(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval?.(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Logs 3.141592653589793
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement
```

 

On the other hand, direct eval inherits the strictness of the invoking context.

 js 

```
function nonStrictContext() {
  eval(`with (Math) console.log(PI);`);
}
function strictContext() {
  "use strict";
  eval(`with (Math) console.log(PI);`);
}
function strictContextStrictEval() {
  "use strict";
  eval(`"use strict"; with (Math) console.log(PI);`);
}
nonStrictContext(); // Logs 3.141592653589793
strictContext(); // Uncaught SyntaxError: Strict mode code may not include a with statement
strictContextStrictEval(); // Uncaught SyntaxError: Strict mode code may not include a with statement
```

 

- 

`var`-declared variables and function declarations would go into the surrounding scope if the source string is not interpreted in strict mode — for indirect eval, they become global variables. If it's a direct eval in a strict mode context, or if the `eval` source string itself is in strict mode, then `var` and function declarations do not "leak" into the surrounding scope.

 js 

```
// Neither context nor source string is strict,
// so var creates a variable in the surrounding scope
eval("var a = 1;");
console.log(a); // 1
// Context is not strict, but eval source is strict,
// so b is scoped to the evaluated script
eval("'use strict'; var b = 1;");
console.log(b); // ReferenceError: b is not defined

function strictContext() {
  "use strict";
  // Context is strict, but this is indirect and the source
  // string is not strict, so c is still global
  eval?.("var c = 1;");
  // Direct eval in a strict context, so d is scoped
  eval("var d = 1;");
}
strictContext();
console.log(c); // 1
console.log(d); // ReferenceError: d is not defined
```

 

 `let` and `const` declarations within the evaluated string are always scoped to that script.

- 

Direct eval may have access to additional contextual expressions. For example, in a function's body, one can use `new.target` :

 js 

```
function Ctor() {
  eval("console.log(new.target)");
}
new Ctor(); // [Function: Ctor]
```

 

 
 

### Never use direct eval()! 

 
 

Using direct `eval()` suffers from multiple problems:

- `eval()` executes the code it's passed with the privileges of the caller. If you run `eval()` with a string that could be affected by a malicious party, you may end up running malicious code on the user's machine with the permissions of your webpage / extension. More importantly, allowing third-party code to access the scope in which `eval()` was invoked (if it's a direct eval) can lead to possible attacks that reads or changes local variables.

- `eval()` is slower than the alternatives, since it has to invoke the JavaScript interpreter, while many other constructs are optimized by modern JS engines.

- Modern JavaScript interpreters convert JavaScript to machine code. This means that any concept of variable naming gets obliterated. Thus, any use of `eval()` will force the browser to do long expensive variable name lookups to figure out where the variable exists in the machine code and set its value. Additionally, new things can be introduced to that variable through `eval()`, such as changing the type of that variable, forcing the browser to re-evaluate all of the generated machine code to compensate.

- Minifiers give up on any minification if the scope is transitively depended on by `eval()`, because otherwise `eval()` cannot read the correct variable at runtime.

There are many cases where the use of `eval()` or related methods can be optimized or avoided altogether.

#### Using indirect eval()

Consider this code:

 js 

```
function looseJsonParse(obj) {
  return eval(`(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));
```

 

Simply using indirect eval and forcing strict mode can make the code much better:

 js 

```
function looseJsonParse(obj) {
  return eval?.(`"use strict";(${obj})`);
}
console.log(looseJsonParse("{ a: 4 - 1, b: function () {}, c: new Map() }"));
```

 

The two code snippets above may seem to work the same way, but they do not; the first one using direct eval suffers from multiple problems.

- 

It is a great deal slower, due to more scope inspections. Notice `c: new Map()` in the evaluated string. In the indirect eval version, the object is being evaluated in the global scope, so it is safe for the interpreter to assume that `Map` refers to the global `Map()` constructor instead of a local variable called `Map`. However, in the code using direct eval, the interpreter cannot assume this. For example, in the following code, `Map` in the evaluated string doesn't refer to `window.Map()`.

 js 

```
function looseJsonParse(obj) {
  class Map {}
  return eval(`(${obj})`);
}
console.log(looseJsonParse(`{ a: 4 - 1, b: function () {}, c: new Map() }`));
```

 

Thus, in the `eval()` version of the code, the browser is forced to make the expensive lookup call to check to see if there are any local variables called `Map()`.

- 

If not using strict mode, `var` declarations within the `eval()` source becomes variables in the surrounding scope. This leads to hard-to-debug issues if the string is acquired from external input, especially if there's an existing variable with the same name.

- 

Direct eval can read and mutate bindings in the surrounding scope, which may lead to external input corrupting local data.

- 

When using direct `eval`, especially when the eval source cannot be proven to be in strict mode, the engine — and build tools — have to disable all optimizations related to inlining, because the `eval()` source can depend on any variable name in its surrounding scope.

However, using indirect `eval()` does not allow passing extra bindings other than existing global variables for the evaluated source to read. If you need to specify additional variables that the evaluated source should have access to, consider using the `Function()` constructor.

#### Using the Function() constructor

The `Function()` constructor is very similar to the indirect eval example above: it also evaluates the JavaScript source passed to it in the global scope without reading or mutating any local bindings, and therefore allows engines to do more optimizations than direct `eval()`.

The difference between `eval()` and `Function()` is that the source string passed to `Function()` is parsed as a function body, not as a script. There are a few nuances — for example, you can use `return` statements at the top level of a function body, but not in a script.

The `Function()` constructor is useful if you wish to create local bindings within your eval source, by passing the variables as parameter bindings.

 js 

```
function add(a, b) {
  return a + b;
}
function runCodeWithAddFunction(obj) {
  return Function("add", `"use strict";return (${obj});`)(add);
}
console.log(runCodeWithAddFunction("add(5, 7)")); // 12
```

 

Both `eval()` and `Function()` implicitly evaluate arbitrary code, and are forbidden in strict CSP settings. There are also additional safer (and faster!) alternatives to `eval()` or `Function()` for common use-cases.

#### Using bracket accessors

You should not use `eval()` to access properties dynamically. Consider the following example where the property of the object to be accessed is not known until the code is executed. This can be done with `eval()`:

 js 

```
const obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"

const result = eval(`obj.${propName}`);
```

 

However, `eval()` is not necessary here — in fact, it's more error-prone, because if `propName` is not a valid identifier, it leads to a syntax error. Moreover, if `getPropName` is not a function you control, this may lead to execution of arbitrary code. Instead, use the property accessors , which are much faster and safer:

 js 

```
const obj = { a: 20, b: 30 };
const propName = getPropName(); // returns "a" or "b"
const result = obj[propName]; // obj["a"] is the same as obj.a
```

 

You can even use this method to access descendant properties. Using `eval()`, this would look like:

 js 

```
const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"

const result = eval(`obj.${propPath}`); // 0
```

 

Avoiding `eval()` here could be done by splitting the property path and looping through the different properties:

 js 

```
function getDescendantProp(obj, desc) {
  const arr = desc.split(".");
  while (arr.length) {
    obj = obj[arr.shift()];
  }
  return obj;
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = getDescendantProp(obj, propPath); // 0
```

 

Setting a property that way works similarly:

 js 

```
function setDescendantProp(obj, desc, value) {
  const arr = desc.split(".");
  while (arr.length > 1) {
    obj = obj[arr.shift()];
  }
  return (obj[arr[0]] = value);
}

const obj = { a: { b: { c: 0 } } };
const propPath = getPropPath(); // suppose it returns "a.b.c"
const result = setDescendantProp(obj, propPath, 1); // obj.a.b.c is now 1
```

 

However, beware that using bracket accessors with unconstrained input is not safe either — it may lead to object injection attacks .

#### Using callbacks

JavaScript has first-class functions , which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:

 js 

```
// Instead of setTimeout("…", 1000) use:
setTimeout(() => {
  // …
}, 1000);

// Instead of elt.setAttribute("onclick", "…") use:
elt.addEventListener("click", () => {
  // …
});
```

 

 Closures are also helpful as a way to create parameterized functions without concatenating strings.

#### Using JSON

If the string you're calling `eval()` on contains data (for example, an array: `"[1, 2, 3]"`), as opposed to code, you should consider switching to JSON , which allows the string to use a subset of JavaScript syntax to represent data.

Note that since JSON syntax is limited compared to JavaScript syntax, many valid JavaScript literals will not parse as JSON. For example, trailing commas are not allowed in JSON, and property names (keys) in object literals must be enclosed in quotes. Be sure to use a JSON serializer to generate strings that will be later parsed as JSON.

Passing carefully constrained data instead of arbitrary code is a good idea in general. For example, an extension designed to scrape contents of web-pages could have the scraping rules defined in XPath instead of JavaScript code.

 
 

## Examples 

 
 
 
 

### Using eval() 

 
 

In the following code, both of the statements containing `eval()` return 42.
The first evaluates the string `"x + y + 1"`; the second evaluates the string
`"42"`.

 js 

```
const x = 2;
const y = 39;
const z = "42";
eval("x + y + 1"); // 42
eval(z); // 42
```

 
 
 

### eval() returns the completion value of statements 

 
 

`eval()` returns the completion value of statements. For `if`, it would be the last expression or statement evaluated.

 js 

```
const str = "if (a) { 1 + 1 } else { 1 + 2 }";
let a = true;
let b = eval(str);

console.log(`b is: ${b}`); // b is: 2

a = false;
b = eval(str);

console.log(`b is: ${b}`); // b is: 3
```

 

The following example uses `eval()` to evaluate the string `str`. This string consists of JavaScript statements that assign `z` a value of 42 if `x` is five, and assign 0 to `z` otherwise. When the second statement is executed, `eval()` will cause these statements to be performed, and it will also evaluate the set of statements and return the value that is assigned to `z`, because the completion value of an assignment is the assigned value.

 js 

```
const x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
} else {
  z = 0;
}`;

console.log("z is ", eval(str)); // z is 42  z is 42
```

 

If you assign multiple values then the last value is returned.

 js 

```
let x = 5;
const str = `if (x === 5) {
  console.log("z is 42");
  z = 42;
  x = 420;
} else {
  z = 0;
}`;

console.log("x is", eval(str)); // z is 42  x is 420
```

 
 
 

### eval() as a string defining function requires "(" and ")" as prefix and suffix 

 
 js 

```
// This is a function declaration
const fctStr1 = "function a() {}";
// This is a function expression
const fctStr2 = "(function b() {})";
const fct1 = eval(fctStr1); // return undefined, but `a` is available as a global function now
const fct2 = eval(fctStr2); // return the function `b`
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-eval-x 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Property accessors 

- WebExtensions: Using eval in content scripts 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### isFinite() - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isFinite

isFinite() - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# isFinite()

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `isFinite()` function determines whether a value is finite, first converting the value to a number if necessary. A finite number is one that's not `NaN` or ± `Infinity` . Because coercion inside the `isFinite()` function can be surprising , you may prefer to use `Number.isFinite()` .

 
 
 
 
 
 

## Try it 

 
 
 

```
function div(x) {
  if (isFinite(1000 / x)) {
    return "Number is NOT Infinity.";
  }
  return "Number is Infinity!";
}

console.log(div(0));
// Expected output: "Number is Infinity!""

console.log(div(1));
// Expected output: "Number is NOT Infinity."
```

 
 
 

## Syntax 

 
 js 

```
isFinite(value)
```

 
 
 

### Parameters 

 
 
 `value` 
 

The value to be tested.

 
 
 
 

### Return value 

 
 

`false` if the given value is `NaN` , `Infinity` , or `-Infinity` after being converted to a number ; otherwise, `true`.

 
 

## Description 

 
 

`isFinite()` is a function property of the global object.

When the argument to the `isFinite()` function is not of type Number , the value is first coerced to a number, and the resulting value is then compared against `NaN` and ±Infinity. This is as confusing as the behavior of `isNaN` — for example, `isFinite("1")` is `true`.

 `Number.isFinite()` is a more reliable way to test whether a value is a finite number value, because it returns `false` for any non-number input.

 
 

## Examples 

 
 
 
 

### Using isFinite() 

 
 js 

```
isFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(0); // true
isFinite(2e64); // true
isFinite(910); // true

// Would've been false with the more robust Number.isFinite():
isFinite(null); // true
isFinite("0"); // true
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-isfinite-number 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `Number.isFinite()` 

- `Number.NaN` 

- `Number.POSITIVE_INFINITY` 

- `Number.NEGATIVE_INFINITY` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### isNaN() - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN

isNaN() - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# isNaN()

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `isNaN()` function determines whether a value is `NaN` , first converting the value to a number if necessary. Because coercion inside the `isNaN()` function can be surprising , you may prefer to use `Number.isNaN()` .

 
 
 
 
 
 

## Try it 

 
 
 

```
function milliseconds(x) {
  if (isNaN(x)) {
    return "Not a Number!";
  }
  return x * 1000;
}

console.log(milliseconds("100F"));
// Expected output: "Not a Number!"

console.log(milliseconds("0.0314E+2"));
// Expected output: 3140
```

 
 
 

## Syntax 

 
 js 

```
isNaN(value)
```

 
 
 

### Parameters 

 
 
 `value` 
 

The value to be tested.

 
 
 
 

### Return value 

 
 

`true` if the given value is `NaN` after being converted to a number ; otherwise, `false`.

 
 

## Description 

 
 

`isNaN()` is a function property of the global object.

For number values, `isNaN()` tests if the number is the value `NaN` . When the argument to the `isNaN()` function is not of type Number , the value is first coerced to a number, and the resulting value is then compared against `NaN` .

This behavior of `isNaN()` for non-numeric arguments can be confusing! For example, an empty string is coerced to 0, while a boolean is coerced to 0 or 1; both values are intuitively "not numbers", but they don't evaluate to `NaN`, so `isNaN()` returns `false`. Therefore, `isNaN()` answers neither the question "is the input the floating point `NaN` value" nor the question "is the input not a number".

 `Number.isNaN()` is a more reliable way to test whether a value is the number value `NaN` or not. Alternatively, the expression `x !== x` can be used, and neither of the solutions is subject to the false positives that make the global `isNaN()` unreliable. To test if a value is a number, use `typeof x === "number"` .

The `isNaN()` function answers the question "is the input functionally equivalent to `NaN` when used in a number context". If `isNaN(x)` returns `false`, you can use `x` in an arithmetic expression as if it's a valid number that's not `NaN`. If `isNaN(x)` returns `true`, `x` will get coerced to `NaN` and make most arithmetic expressions return `NaN` (because `NaN` propagates). You can use this, for example, to test whether an argument to a function is arithmetically processable (usable "like" a number), and handle values that are not number-like by throwing an error, providing a default value, etc. This way, you can have a function that makes use of the full versatility JavaScript provides by implicitly converting values depending on context.

 

 Note: 
The `+` operator performs both number addition and string concatenation. Therefore, even if `isNaN()` returns `false` for both operands, the `+` operator may still return a string, because it's not used as an arithmetic operator. For example, `isNaN("1")` returns `false`, but `"1" + 1` returns `"11"`. To be sure that you are working with numbers, coerce the value to a number and use `Number.isNaN()` to test the result.

 
 
 

## Examples 

 
 

Note how `isNaN()` returns `true` for values that are not the value `NaN` but are not numbers either:

 js 

```
isNaN(NaN); // true
isNaN(undefined); // true
isNaN({}); // true

isNaN(true); // false
isNaN(null); // false
isNaN(37); // false

// Strings
isNaN("37"); // false: "37" is converted to the number 37 which is not NaN
isNaN("37.37"); // false: "37.37" is converted to the number 37.37 which is not NaN
isNaN("37,5"); // true
isNaN("123ABC"); // true: Number("123ABC") is NaN
isNaN(""); // false: the empty string is converted to 0 which is not NaN
isNaN(" "); // false: a string with spaces is converted to 0 which is not NaN

// Dates
isNaN(new Date()); // false; Date objects can be converted to a number (timestamp)
isNaN(new Date().toString()); // true; the string representation of a Date object cannot be parsed as a number

// Arrays
isNaN([]); // false; the primitive representation is "", which coverts to the number 0
isNaN([1]); // false; the primitive representation is "1"
isNaN([1, 2]); // true; the primitive representation is "1,2", which cannot be parsed as number
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-isnan-number 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `NaN` 

- `Number.isNaN()` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#content

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#search

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### this - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#global_context

this - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# this

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `this` keyword refers to the context where a piece of code, such as a function's body, is supposed to run. Most typically, it is used in object methods, where `this` refers to the object that the method is attached to, thus allowing the same method to be reused on different objects.

The value of `this` in JavaScript depends on how a function is invoked (runtime binding ), not how it is defined. When a regular function is invoked as a method of an object (`obj.method()`), `this` points to that object. When invoked as a standalone function (not attached to an object: `func()`), `this` typically refers to the global object (in non-strict mode) or `undefined` (in strict mode ). The `Function.prototype.bind()` method can create a function whose `this` binding doesn't change, and methods `Function.prototype.apply()` and `Function.prototype.call()` can also set the `this` value for a particular call.

 Arrow functions differ in their handling of `this`: they inherit `this` from the parent scope at the time they are defined. This behavior makes arrow functions particularly useful for callbacks and preserving context. However, arrow functions do not have their own `this` binding. Therefore, their `this` value cannot be set by `bind()`, `apply()` or `call()` methods, nor does it point to the current object in object methods.

 
 
 
 
 
 

## Try it 

 
 
 

```
const test = {
  prop: 42,
  func() {
    return this.prop;
  },
};

console.log(test.func());
// Expected output: 42
```

 
 
 

## Syntax 

 
 js 

```
this
```

 
 
 

### Value 

 
 

In non–strict mode, `this` is always a reference to an object. In strict mode, it can be any value. For more information on how the value is determined, see the description below.

 
 

## Description 

 
 

The value of `this` depends on in which context it appears: function, class, or global.

 
 

### Function context 

 
 

Inside a function, the value of `this` depends on how the function is called. Think about `this` as a hidden parameter of a function — just like the parameters declared in the function definition, `this` is a binding that the language creates for you when the function body is evaluated.

For a regular function (not an arrow function, bound function, etc.), the value of `this` is the object that the function is accessed on. In other words, if the function call is in the form `obj.f()`, then `this` refers to `obj`. For example:

 js 

```
function getThis() {
  return this;
}

const obj1 = { name: "obj1" };
const obj2 = { name: "obj2" };

obj1.getThis = getThis;
obj2.getThis = getThis;

console.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }
console.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }
```

 

Note how the function is the same, but based on how it's invoked, the value of `this` is different. This is analogous to how function parameters work.

The value of `this` is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the prototype chain .

 js 

```
const obj3 = {
  __proto__: obj1,
  name: "obj3",
};

console.log(obj3.getThis()); // { name: 'obj3' }
```

 

The value of `this` always changes based on how a function is called, even when the function was defined on an object at creation:

 js 

```
const obj4 = {
  name: "obj4",
  getThis() {
    return this;
  },
};

const obj5 = { name: "obj5" };

obj5.getThis = obj4.getThis;
console.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }
```

 

If the value that the method is accessed on is a primitive, `this` will be a primitive value as well — but only if the function is in strict mode.

 js 

```
function getThisStrict() {
  "use strict"; // Enter strict mode
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThisStrict = getThisStrict;
console.log(typeof (1).getThisStrict()); // "number"
```

 

If the function is called without being accessed on anything, `this` will be `undefined` — but only if the function is in strict mode.

 js 

```
console.log(typeof getThisStrict()); // "undefined"
```

 

In non-strict mode, a special process called `this` substitution ensures that the value of `this` is always an object. This means:

- If a function is called with `this` set to `undefined` or `null`, `this` gets substituted with `globalThis` .

- If the function is called with `this` set to a primitive value, `this` gets substituted with the primitive value's wrapper object.

 js 

```
function getThis() {
  return this;
}

// Only for demonstration — you should not mutate built-in prototypes
Number.prototype.getThis = getThis;
console.log(typeof (1).getThis()); // "object"
console.log(getThis() === globalThis); // true
```

 

In typical function calls, `this` is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of `this` using the `Function.prototype.call()` , `Function.prototype.apply()` , or `Reflect.apply()` methods. Using `Function.prototype.bind()` , you can create a new function with a specific value of `this` that doesn't change regardless of how the function is called. When using these methods, the `this` substitution rules above still apply if the function is non-strict.

#### Callbacks

When a function is passed as a callback, the value of `this` depends on how the callback is called, which is determined by the implementor of the API. Callbacks are typically called with a `this` value of `undefined` (calling it directly without attaching it to any object), which means if the function is non–strict, the value of `this` is the global object ( `globalThis` ). This is the case for iterative array methods , the `Promise()` constructor, etc.

 js 

```
function logThis() {
  "use strict";
  console.log(this);
}

[1, 2, 3].forEach(logThis); // undefined, undefined, undefined
```

 

Some APIs allow you to set a `this` value for invocations of the callback. For example, all iterative array methods and related ones like `Set.prototype.forEach()` accept an optional `thisArg` parameter.

 js 

```
[1, 2, 3].forEach(logThis, { name: "obj" });
// { name: 'obj' }, { name: 'obj' }, { name: 'obj' }
```

 

Occasionally, a callback is called with a `this` value other than `undefined`. For example, the `reviver` parameter of `JSON.parse()` and the `replacer` parameter of `JSON.stringify()` are both called with `this` set to the object that the property being parsed/serialized belongs to.

#### Arrow functions

In arrow functions , `this` retains the value of the enclosing lexical context's `this`. In other words, when evaluating an arrow function's body, the language does not create a new `this` binding.

For example, in global code, `this` is always `globalThis` regardless of strictness, because of the global context binding:

 js 

```
const globalObject = this;
const foo = () => this;
console.log(foo() === globalObject); // true
```

 

Arrow functions create a closure over the `this` value of its surrounding scope, which means arrow functions behave as if they are "auto-bound" — no matter how it's invoked, `this` is bound to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their `this` remains that of the enclosing lexical context. See example below .

Furthermore, when invoking arrow functions using `call()`, `bind()`, or `apply()`, the `thisArg` parameter is ignored. You can still pass other arguments using these methods, though.

 js 

```
const obj = { name: "obj" };

// Attempt to set this using call
console.log(foo.call(obj) === globalObject); // true

// Attempt to set this using bind
const boundFoo = foo.bind(obj);
console.log(boundFoo() === globalObject); // true
```

 

#### Constructors

When a function is used as a constructor (with the `new` keyword), its `this` is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of `this` becomes the value of the `new` expression unless the constructor returns another non–primitive value.

 js 

```
function C() {
  this.a = 37;
}

let o = new C();
console.log(o.a); // 37

function C2() {
  this.a = 37;
  return { a: 38 };
}

o = new C2();
console.log(o.a); // 38
```

 

In the second example (`C2`), because an object was returned during construction, the new object that `this` was bound to gets discarded. (This essentially makes the statement `this.a = 37;` dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)

#### super

When a function is invoked in the `super.method()` form, the `this` inside the `method` function is the same value as the `this` value around the `super.method()` call, and is generally not equal to the object that `super` refers to. This is because `super.method` is not an object member access like the ones above — it's a special syntax with different binding rules. For examples, see the `super` reference .

 
 

### Class context 

 
 

A class can be split into two contexts: static and instance. Constructors , methods, and instance field initializers ( public or private ) belong to the instance context. Static methods, static field initializers, and static initialization blocks belong to the static context. The `this` value is different in each context.

Class constructors are always called with `new`, so their behavior is the same as function constructors : the `this` value is the new instance being created. Class methods behave like methods in object literals — the `this` value is the object that the method was accessed on. If the method is not transferred to another object, `this` is generally an instance of the class.

Static methods are not properties of `this`. They are properties of the class itself. Therefore, they are generally accessed on the class, and `this` is the value of the class (or a subclass). Static initialization blocks are also evaluated with `this` set to the current class.

Field initializers are also evaluated in the context of the class. Instance fields are evaluated with `this` set to the instance being constructed. Static fields are evaluated with `this` set to the current class. This is why arrow functions in field initializers are bound to the instance for instance fields and to the class for static fields .

 js 

```
class C {
  instanceField = this;
  static staticField = this;
}

const c = new C();
console.log(c.instanceField === c); // true
console.log(C.staticField === C); // true
```

 

#### Derived class constructors

Unlike base class constructors, derived constructors have no initial `this` binding. Calling `super()` creates a `this` binding within the constructor and essentially has the effect of evaluating the following line of code, where `Base` is the base class:

 js 

```
this = new Base();
```

 
 

 Warning: 
Referring to `this` before calling `super()` will throw an error.

 

Derived classes must not return before calling `super()`, unless the constructor returns an object (so the `this` value is overridden) or the class has no constructor at all.

 js 

```
class Base {}
class Good extends Base {}
class AlsoGood extends Base {
  constructor() {
    return { a: 5 };
  }
}
class Bad extends Base {
  constructor() {}
}

new Good();
new AlsoGood();
new Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
```

 
 
 

### Global context 

 
 

In the global execution context (outside of any functions or classes; may be inside blocks or arrow functions defined in the global scope), the `this` value depends on what execution context the script runs in. Like callbacks , the `this` value is determined by the runtime environment (the caller).

At the top level of a script, `this` refers to `globalThis` whether in strict mode or not. This is generally the same as the global object — for example, if the source is put inside an HTML ` ` element and executed as a script, `this === window`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 js 

```
// In web browsers, the window object is also the global object:
console.log(this === window); // true

this.b = "MDN";
console.log(window.b); // "MDN"
console.log(b); // "MDN"
```

 

If the source is loaded as a module (for HTML, this means adding `type="module"` to the ` ` tag), `this` is always `undefined` at the top level.

If the source is executed with `eval()` , `this` is the same as the enclosing context for direct eval , or `globalThis` (as if it's run in a separate global script) for indirect eval.

 js 

```
function test() {
  // Direct eval
  console.log(eval("this") === this);
  // Indirect eval, non-strict
  console.log(eval?.("this") === globalThis);
  // Indirect eval, strict
  console.log(eval?.("'use strict'; this") === globalThis);
}

test.call({ name: "obj" }); // Logs 3 "true"
```

 

Note that some source code, while looking like the global scope, is actually wrapped in a function when executed. For example, Node.js CommonJS modules are wrapped in a function and executed with the `this` value set to `module.exports`. Event handler attributes are executed with `this` set to the element they are attached to.

Object literals don't create a `this` scope — only functions (methods) defined within the object do. Using `this` in an object literal inherits the value from the surrounding scope.

 js 

```
const obj = {
  a: this,
};

console.log(obj.a === window); // true
```

 
 
 

## Examples 

 
 
 
 

### this in function contexts 

 
 

The value of the `this` parameter depends on how the function is called, not on how it's defined.

 js 

```
// An object can be passed as the first argument to 'call'
// or 'apply' and 'this' will be bound to it.
const obj = { a: "Custom" };

// Variables declared with var become properties of 'globalThis'.
var a = "Global";

function whatsThis() {
  return this.a; // 'this' depends on how the function is called
}

whatsThis(); // 'Global'; the 'this' parameter defaults to 'globalThis' in non–strict mode
obj.whatsThis = whatsThis;
obj.whatsThis(); // 'Custom'; the 'this' parameter is bound to obj
```

 

Using `call()` and `apply()`, you can pass the value of `this` as if it's an explicit parameter.

 js 

```
function add(c, d) {
  return this.a + this.b + c + d;
}

const o = { a: 1, b: 3 };

// The first argument is bound to the implicit 'this' parameter; the remaining
// arguments are bound to the named parameters.
add.call(o, 5, 7); // 16

// The first argument is bound to the implicit 'this' parameter; the second
// argument is an array whose members are bound to the named parameters.
add.apply(o, [10, 20]); // 34
```

 
 
 

### this and object conversion 

 
 

In non–strict mode, if a function is called with a `this` value that's not an object, the `this` value is substituted with an object. `null` and `undefined` become `globalThis`. Primitives like `7` or `'foo'` are converted to an object using the related constructor, so the primitive number `7` is converted to a `Number` wrapper class and the string `'foo'` to a `String` wrapper class.

 js 

```
function bar() {
  console.log(Object.prototype.toString.call(this));
}

bar.call(7); // [object Number]
bar.call("foo"); // [object String]
bar.call(undefined); // [object Window]
```

 
 
 

### The bind() method 

 
 

Calling `f.bind(someObject)` creates a new function with the same body and scope as `f`, but the value of `this` is permanently bound to the first argument of `bind`, regardless of how the function is being called.

 js 

```
function f() {
  return this.a;
}

const g = f.bind({ a: "azerty" });
console.log(g()); // azerty

const h = g.bind({ a: "yoo" }); // bind only works once!
console.log(h()); // azerty

const o = { a: 37, f, g, h };
console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty
```

 
 
 

### this in arrow functions 

 
 

Arrow functions create closures over the `this` value of the enclosing execution context. In the following example, we create `obj` with a method `getThisGetter` that returns a function that returns the value of `this`. The returned function is created as an arrow function, so its `this` is permanently bound to the `this` of its enclosing function. The value of `this` inside `getThisGetter` can be set in the call, which in turn sets the return value of the returned function. We will assume that `getThisGetter` is a non-strict function, which means it's contained in a non-strict script and not further nested in a class or strict function.

 js 

```
const obj = {
  getThisGetter() {
    const getter = () => this;
    return getter;
  },
};
```

 

We can call `getThisGetter` as a method of `obj`, which binds `this` to `obj` inside its body. The returned function is assigned to a variable `fn`. Now, when calling `fn`, the value of `this` returned is still the one set by the call to `getThisGetter`, which is `obj`. If the returned function was not an arrow function, such calls would cause the `this` value to be `globalThis`, because `getThisGetter` is non-strict.

 js 

```
const fn = obj.getThisGetter();
console.log(fn() === obj); // true
```

 

But be careful if you unbind the method of `obj` without calling it, because `getThisGetter` is still a method that has a varying `this` value. Calling `fn2()()` in the following example returns `globalThis`, because it follows the `this` from `fn2()`, which is `globalThis` since it's called without being attached to any object.

 js 

```
const fn2 = obj.getThisGetter;
console.log(fn2()() === globalThis); // true in non-strict mode
```

 

This behavior is very useful when defining callbacks. Usually, each function expression creates its own `this` binding, which shadows the `this` value of the upper scope. Now, you can define functions as arrow functions if you don't care about the `this` value, and only create `this` bindings where you do (e.g., in class methods). See example with `setTimeout()` .

 
 

### this with a getter or setter 

 
 

`this` in getters and setters is based on which object the property is accessed on, not which object the property is defined on. A function used as getter or setter has its `this` bound to the object from which the property is being set or gotten.

 js 

```
function sum() {
  return this.a + this.b + this.c;
}

const o = {
  a: 1,
  b: 2,
  c: 3,
  get average() {
    return (this.a + this.b + this.c) / 3;
  },
};

Object.defineProperty(o, "sum", {
  get: sum,
  enumerable: true,
  configurable: true,
});

console.log(o.average, o.sum); // 2 6
```

 
 
 

### this in DOM event handlers 

 
 

When a function is used as an event handler, its `this` parameter is bound to the DOM element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than `addEventListener()` ).

 js 

```
// When called as a listener, turns the related element blue
function bluify(e) {
  // Always true
  console.log(this === e.currentTarget);
  // true when currentTarget and target are the same object
  console.log(this === e.target);
  this.style.backgroundColor = "#A5D9F3";
}

// Get a list of every element in the document
const elements = document.getElementsByTagName("*");

// Add bluify as a click listener so when the
// element is clicked on, it turns blue
for (const element of elements) {
  element.addEventListener("click", bluify);
}
```

 
 
 

### this in inline event handlers 

 
 

When the code is called from an inline event handler attribute , its `this` is bound to the DOM element on which the listener is placed:

 html 

```
<button onclick="alert(this.tagName.toLowerCase());">Show this</button>
```

 

The above alert shows `button`. Note, however, that only the outer scope has its `this` bound this way:

 html 

```
<button onclick="alert((function () { return this; })());">
  Show inner this
</button>
```

 

In this case, the `this` parameter of the inner function is bound to `globalThis` (i.e., the default object in non–strict mode where `this` isn't passed in the call).

 
 

### Bound methods in classes 

 
 

Just like with regular functions, the value of `this` within methods depends on how they are called. Sometimes it is useful to override this behavior so that `this` within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:

 js 

```
class Car {
  constructor() {
    // Bind sayBye but not sayHi to show the difference
    this.sayBye = this.sayBye.bind(this);
  }

  sayHi() {
    console.log(`Hello from ${this.name}`);
  }

  sayBye() {
    console.log(`Bye from ${this.name}`);
  }

  get name() {
    return "Ferrari";
  }
}

class Bird {
  get name() {
    return "Tweety";
  }
}

const car = new Car();
const bird = new Bird();

// The value of 'this' in methods depends on their caller
car.sayHi(); // Hello from Ferrari
bird.sayHi = car.sayHi;
bird.sayHi(); // Hello from Tweety

// For bound methods, 'this' doesn't depend on the caller
bird.sayBye = car.sayBye;
bird.sayBye(); // Bye from Ferrari
```

 
 

 Note: 
Classes are always in strict mode. Calling methods with an undefined `this` will throw an error if the method tries to access properties on `this`.

 js 

```
const carSayHi = car.sayHi;
carSayHi(); // TypeError because the 'sayHi' method tries to access 'this.name', but 'this' is undefined in strict mode.
```

 
 

Note, however, that auto-bound methods suffer from the same problem as using arrow functions for class properties : each instance of the class will have its own copy of the method, which increases memory usage. Only use it where absolutely necessary. You can also mimic the implementation of `Intl.NumberFormat.prototype.format()` : define the property as a getter that returns a bound function when accessed and saves it, so that the function is only created once and only created when necessary.

 
 

### this in with statements 

 
 

Although `with` statements are deprecated and not available in strict mode, they still serve as an exception to the normal `this` binding rules. If a function is called within a `with` statement and that function is a property of the scope object, the `this` value is bound to the scope object, as if the `obj.` prefix exists.

 js 

```
const obj = {
  foo() {
    return this;
  },
};

with (obj) {
  console.log(foo() === obj); // true
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-this-keyword 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Strict mode 

- `globalThis` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 18, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#try_it

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#value

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#description

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### globalThis - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#examples

globalThis - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# globalThis

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨January 2020⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `globalThis` global property contains the global `this` value, which is usually akin to the global object .

 
 
 
 
 
 

## Try it 

 
 
 

```
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === "function";
}

console.log(canMakeHTTPRequest());
// Expected output (in a browser): true
```

 
 
 

## Value 

 
 

The global `this` object.

 Property attributes of `globalThis` Writable yes Enumerable no Configurable yes 
 

 Note: 
The `globalThis` property is configurable and writable so that code authors can hide it when executing untrusted code and prevent exposing the global object.

 
 
 

## Description 

 
 

Historically, accessing the global object has required different syntax in different JavaScript environments. On the web you can use `window` , `self` , or `frames` - but in Web Workers only `self` will work. In Node.js none of these work, and you must instead use `global`. The `this` keyword could be used inside functions running in non–strict mode, but `this` will be `undefined` in modules and inside functions running in strict mode. You can also use `Function('return this')()`, but environments that disable `eval()` , like CSP in browsers, prevent use of `Function` in this way.

The `globalThis` property provides a standard way of accessing the global `this` value (and hence the global object itself) across environments. Unlike similar properties such as `window` and `self`, it's guaranteed to work in window and non-window contexts. In this way, you can access the global object in a consistent manner without having to know which environment the code is being run in. To help you remember the name, just remember that in global scope the `this` value is `globalThis`.

 

 Note: 
`globalThis` is generally the same concept as the global object (i.e., adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.

 
 
 

### HTML and the WindowProxy 

 
 

In many engines `globalThis` will be a reference to the actual global object, but in web browsers, due to iframe and cross-window security considerations, it references a `Proxy` around the actual global object (which you can't directly access). This distinction is rarely relevant in common usage, but important to be aware of.

 
 

### Naming 

 
 

Several other popular name choices such as `self` and `global` were removed from consideration because of their potential to break compatibility with existing code. See the language proposal's "naming" document for more details.

`globalThis` is, quite literally, the global `this` value. It's the same value as the `this` value in a non-strict function called without an object. It's also the value of `this` in the global scope of a script.

 
 

## Examples 

 
 
 
 

### Search for the global across environments 

 
 

Usually, the global object does not need to be explicitly specified — its properties are automatically accessible as global variables.

 js 

```
console.log(window.Math === Math); // true
```

 

However, one case where one needs to explicitly access the global object is when writing to it, usually for the purpose of polyfills .

Prior to `globalThis`, the only reliable cross-platform way to get the global object for an environment was `Function('return this')()`. However, this causes CSP violations in some settings, so authors would use a piecewise definition like this (slightly adapted from the original core-js source ):

 js 

```
function check(it) {
  // Math is known to exist as a global in every environment.
  return it && it.Math === Math && it;
}

const globalObject =
  check(typeof window === "object" && window) ||
  check(typeof self === "object" && self) ||
  check(typeof global === "object" && global) ||
  // This returns undefined when running in strict mode
  (function () {
    return this;
  })() ||
  Function("return this")();
```

 

After obtaining the global object, we can define new globals on it. For example, adding an implementation for `Intl` :

 js 

```
if (typeof globalObject.Intl === "undefined") {
  // No Intl in this environment; define our own on the global scope
  Object.defineProperty(globalObject, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 

With `globalThis` available, the additional search for the global across environments is not necessary anymore:

 js 

```
if (typeof globalThis.Intl === "undefined") {
  Object.defineProperty(globalThis, "Intl", {
    value: {
      // Our Intl implementation
    },
    enumerable: false,
    configurable: true,
    writable: true,
  });
}
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-globalthis 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Polyfill of `globalThis` in `core-js` 

- es-shims polyfill of `globalThis` 

- `this` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Lexical grammar - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#literals

Lexical grammar - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Lexical grammar

 
 
 

This page describes JavaScript's lexical grammar. JavaScript source text is just a sequence of characters — in order for the interpreter to understand it, the string has to be parsed to a more structured representation. The initial step of parsing is called lexical analysis , in which the text gets scanned from left to right and is converted into a sequence of individual, atomic input elements. Some input elements are insignificant to the interpreter, and will be stripped after this step — they include white space and comments . The others, including identifiers , keywords , literals , and punctuators (mostly operators ), will be used for further syntax analysis. Line terminators and multiline comments are also syntactically insignificant, but they guide the process for automatic semicolons insertion to make certain invalid token sequences become valid.

 
 
 
 
 
 

## Format-control characters 

 
 

Format-control characters have no visual representation but are used to control the interpretation of the text.

 
 
 
 Code point 
 Name 
 Abbreviation 
 Description 
 
 
 
 
 U+200C 
 Zero width non-joiner 
 <ZWNJ> 
 Placed between characters to prevent being connected into ligatures in certain languages ( Wikipedia ). 
 
 
 U+200D 
 Zero width joiner 
 <ZWJ> 
 Placed between characters that would not normally be connected in order to cause the characters to be rendered using their connected form in certain languages ( Wikipedia ). 
 
 
 U+FEFF 
 Byte order mark 
 <BOM> 
 Used at the start of the script to mark it as Unicode and to allow detection of the text's encoding and byte order ( Wikipedia ). 
 
 
 

In JavaScript source text, <ZWNJ> and <ZWJ> are treated as identifier parts, while <BOM> (also called a zero-width no-break space <ZWNBSP> when not at the start of text) is treated as white space .

 
 

## White space 

 
 

 White space characters improve the readability of source text and separate tokens from each other. These characters are usually unnecessary for the functionality of the code. Minification tools are often used to remove whitespace in order to reduce the amount of data that needs to be transferred.

 
 
 
 Code point 
 Name 
 Abbreviation 
 Description 
 Escape sequence 
 
 
 
 
 U+0009 
 Character tabulation 
 <TAB> 
 Horizontal tabulation 
 \t 
 
 
 U+000B 
 Line tabulation 
 <VT> 
 Vertical tabulation 
 \v 
 
 
 U+000C 
 Form feed 
 <FF> 
 Page breaking control character ( Wikipedia ). 
 \f 
 
 
 U+0020 
 Space 
 <SP> 
 Normal space 
 
 
 
 U+00A0 
 No-break space 
 <NBSP> 
 Normal space, but no point at which a line may break 
 
 
 
 U+FEFF 
 Zero-width no-break space 
 <ZWNBSP> 
 When not at the start of a script, the BOM marker is a normal whitespace character. 
 
 
 
 Others 
 Other Unicode space characters 
 <USP> 
 Characters in the "Space_Separator" general category 
 
 
 
 
 

 Note: 
Of those characters with the "White_Space" property but are not in the "Space_Separator" general category , U+0009, U+000B, and U+000C are still treated as white space in JavaScript; U+0085 NEXT LINE has no special role; others become the set of line terminators .

 
 

 Note: 
Changes to the Unicode standard used by the JavaScript engine may affect programs' behavior. For example, ES2016 upgraded the reference Unicode standard from 5.1 to 8.0.0, which caused U+180E MONGOLIAN VOWEL SEPARATOR to be moved from the "Space_Separator" category to the "Format (Cf)" category, and made it a non-whitespace. Subsequently, the result of `"\u180E".trim().length` changed from `0` to `1`.

 
 
 

## Line terminators 

 
 

In addition to white space characters, line terminator characters are used to improve the readability of the source text. However, in some cases, line terminators can influence the execution of JavaScript code as there are a few places where they are forbidden. Line terminators also affect the process of automatic semicolon insertion .

Outside the context of lexical grammar, white space and line terminators are often conflated. For example, `String.prototype.trim()` removes all white space and line terminators from the beginning and end of a string. The `\s` character class escape in regular expressions matches all white space and line terminators.

Only the following Unicode code points are treated as line terminators in ECMAScript, other line breaking characters are treated as white space (for example, Next Line, NEL, U+0085 is considered as white space).

 
 
 
 Code point 
 Name 
 Abbreviation 
 Description 
 Escape sequence 
 
 
 
 
 U+000A 
 Line Feed 
 <LF> 
 New line character in UNIX systems. 
 \n 
 
 
 U+000D 
 Carriage Return 
 <CR> 
 New line character in Commodore and early Mac systems. 
 \r 
 
 
 U+2028 
 Line Separator 
 <LS> 
 Wikipedia 
 
 
 
 U+2029 
 Paragraph Separator 
 <PS> 
 Wikipedia 
 
 
 
 
 
 

## Comments 

 
 

Comments are used to add hints, notes, suggestions, or warnings to JavaScript code. This can make it easier to read and understand. They can also be used to disable code to prevent it from being executed; this can be a valuable debugging tool.

JavaScript has two long-standing ways to add comments to code: line comments and block comments. In addition, there's a special hashbang comment syntax.

 
 

### Line comments 

 
 

The first way is the `//` comment; this makes all text following it on the same line into a comment. For example:

 js 

```
function comment() {
  // This is a one line JavaScript comment
  console.log("Hello world!");
}
comment();
```

 
 
 

### Block comments 

 
 

The second way is the `/* */` style, which is much more flexible.

For example, you can use it on a single line:

 js 

```
function comment() {
  /* This is a one line JavaScript comment */
  console.log("Hello world!");
}
comment();
```

 

You can also make multiple-line comments, like this:

 js 

```
function comment() {
  /* This comment spans multiple lines. Notice
     that we don't need to end the comment until we're done. */
  console.log("Hello world!");
}
comment();
```

 

You can also use it in the middle of a line, if you wish, although this can make your code harder to read so it should be used with caution:

 js 

```
function comment(x) {
  console.log("Hello " + x /* insert the value of x */ + " !");
}
comment("world");
```

 

In addition, you can use it to disable code to prevent it from running, by wrapping code in a comment, like this:

 js 

```
function comment() {
  /* console.log("Hello world!"); */
}
comment();
```

 

In this case, the `console.log()` call is never issued, since it's inside a comment. Any number of lines of code can be disabled this way.

Block comments that contain at least one line terminator behave like line terminators in automatic semicolon insertion .

 
 

### Hashbang comments 

 
 

There's a special third comment syntax, the hashbang comment . A hashbang comment behaves exactly like a single line-only (`//`) comment, except that it begins with `#!` and is only valid at the absolute start of a script or module . Note also that no whitespace of any kind is permitted before the `#!`. The comment consists of all the characters after `#!` up to the end of the first line; only one such comment is permitted.

Hashbang comments in JavaScript resemble shebangs in Unix which provide the path to a specific JavaScript interpreter that you want to use to execute the script. Before the hashbang comment became standardized, it had already been de-facto implemented in non-browser hosts like Node.js, where it was stripped from the source text before being passed to the engine. An example is as follows:

 js 

```
#!/usr/bin/env node

console.log("Hello world");
```

 

The JavaScript interpreter will treat it as a normal comment — it only has semantic meaning to the shell if the script is directly run in a shell.

 

 Warning: 
If you want scripts to be runnable directly in a shell environment, encode them in UTF-8 without a BOM . Although a BOM will not cause any problems for code running in a browser — because it's stripped during UTF-8 decoding, before the source text is analyzed — a Unix/Linux shell will not recognize the hashbang if it's preceded by a BOM character.

 

You must only use the `#!` comment style to specify a JavaScript interpreter. In all other cases just use a `//` comment (or multiline comment).

 
 

## Identifiers 

 
 

An identifier is used to link a value with a name. Identifiers can be used in various places:

 js 

```
const decl = 1; // Variable declaration (may also be `let` or `var`)
function fn() {} // Function declaration
const obj = { key: "value" }; // Object keys
// Class declaration
class C {
  #priv = "value"; // Private field
}
lbl: console.log(1); // Label
```

 

In JavaScript, identifiers are commonly made of alphanumeric characters, underscores (`_`), and dollar signs (`$`). Identifiers are not allowed to start with numbers. However, JavaScript identifiers are not only limited to ASCII — many Unicode code points are allowed as well. Namely:

- Start characters can be any character in the ID_Start category plus `_` and `$`.

- After the first character, you can use any character in the ID_Continue category plus U+200C (ZWNJ) and U+200D (ZWJ).

 

 Note: 
If, for some reason, you need to parse some JavaScript source yourself, do not assume all identifiers follow the pattern `/[A-Za-z_$][\w$]*/` (i.e., ASCII-only)! The range of identifiers can be described by the regex `/[$_\p{ID_Start}][$\p{ID_Continue}]*/u` (excluding unicode escape sequences).

 

In addition, JavaScript allows using Unicode escape sequences in the form of `\u0000` or `\u{000000}` in identifiers, which encode the same string value as the actual Unicode characters. For example, `你好` and `\u4f60\u597d` are the same identifiers:

 js 

```
const 你好 = "Hello";
console.log(\u4f60\u597d); // Hello
```

 

Not all places accept the full range of identifiers. Certain syntaxes, such as function declarations, function expressions, and variable declarations require using identifiers names that are not reserved words .

 js 

```
function import() {} // Illegal: import is a reserved word.
```

 

Most notably, private elements and object properties allow reserved words.

 js 

```
const obj = { import: "value" }; // Legal despite `import` being reserved
class C {
  #import = "value";
}
```

 
 
 

## Keywords 

 
 

 Keywords are tokens that look like identifiers but have special meanings in JavaScript. For example, the keyword `async` before a function declaration indicates that the function is asynchronous.

Some keywords are reserved , meaning that they cannot be used as an identifier for variable declarations, function declarations, etc. They are often called reserved words . A list of these reserved words is provided below. Not all keywords are reserved — for example, `async` can be used as an identifier anywhere. Some keywords are only contextually reserved — for example, `await` is only reserved within the body of an async function, and `let` is only reserved in strict mode code, or `const` and `let` declarations.

Identifiers are always compared by string value , so escape sequences are interpreted. For example, this is still a syntax error:

 js 

```
const els\u{65} = 1;
// `els\u{65}` encodes the same identifier as `else`
```

 
 
 

### Reserved words 

 
 

These keywords cannot be used as identifiers for variables, functions, classes, etc. anywhere in JavaScript source.

- `break` 

- `case` 

- `catch` 

- `class` 

- `const` 

- `continue` 

- `debugger` 

- `default` 

- `delete` 

- `do` 

- `else` 

- `export` 

- `extends` 

- `false` 

- `finally` 

- `for` 

- `function` 

- `if` 

- `import` 

- `in` 

- `instanceof` 

- `new` 

- `null` 

- `return` 

- `super` 

- `switch` 

- `this` 

- `throw` 

- `true` 

- `try` 

- `typeof` 

- `var` 

- `void` 

- `while` 

- `with` 

The following are only reserved when they are found in strict mode code:

- `let` (also reserved in `const`, `let`, and class declarations)

- `static` 

- `yield` (also reserved in generator function bodies)

The following are only reserved when they are found in module code or async function bodies:

- `await` 

 
 

### Future reserved words 

 
 

The following are reserved as future keywords by the ECMAScript specification. They have no special functionality at present, but they might at some future time, so they cannot be used as identifiers.

These are always reserved:

- `enum`

The following are only reserved when they are found in strict mode code:

- `implements`

- `interface`

- `package`

- `private`

- `protected`

- `public`

#### Future reserved words in older standards

The following are reserved as future keywords by older ECMAScript specifications (ECMAScript 1 till 3).

- `abstract`

- `boolean`

- `byte`

- `char`

- `double`

- `final`

- `float`

- `goto`

- `int`

- `long`

- `native`

- `short`

- `synchronized`

- `throws`

- `transient`

- `volatile`

 
 

### Identifiers with special meanings 

 
 

A few identifiers have a special meaning in some contexts without being reserved words of any kind. They include:

- `arguments` (not a keyword, but cannot be declared as identifier in strict mode)

- `as` ( `import * as ns from "mod"` )

- `async` 

- `eval` (not a keyword, but cannot be declared as identifier in strict mode)

- `from` ( `import x from "mod"` )

- `get` 

- `of` 

- `set` 

 
 

## Literals 

 
 

 Note: 
This section discusses literals that are atomic tokens. Object literals and array literals are expressions that consist of a series of tokens.

 
 
 

### Null literal 

 
 

See also `null` for more information.

 js 

```
null
```

 
 
 

### Boolean literal 

 
 

See also boolean type for more information.

 js 

```
true
false
```

 
 
 

### Numeric literals 

 
 

The Number and BigInt types use numeric literals.

#### Decimal

 js 

```
1234567890
42
```

 

Decimal literals can start with a zero (`0`) followed by another decimal digit, but if all digits after the leading `0` are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with `0`, whether interpreted as octal or decimal, cause a syntax error in strict mode — so, use the `0o` prefix instead.

 js 

```
0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal
```

 
 Exponential 

The decimal exponential literal is specified by the following format: `beN`; where `b` is a base number (integer or floating), followed by an `E` or `e` character (which serves as separator or exponent indicator ) and `N`, which is exponent or power number – a signed integer.

 js 

```
0e-5   // 0
0e+5   // 0
5e1    // 50
175e-2 // 1.75
1e3    // 1000
1e-3   // 0.001
1E3    // 1000
```

 

#### Binary

Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (`0b` or `0B`). Any character after the `0b` that is not 0 or 1 will terminate the literal sequence.

 js 

```
0b10000000000000000000000000000000 // 2147483648
0b01111111100000000000000000000000 // 2139095040
0B00000000011111111111111111111111 // 8388607
```

 

#### Octal

Octal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "O" (`0o` or `0O)`. Any character after the `0o` that is outside the range (01234567) will terminate the literal sequence.

 js 

```
0O755 // 493
0o644 // 420
```

 

#### Hexadecimal

Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (`0x` or `0X`). Any character after the `0x` that is outside the range (0123456789ABCDEF) will terminate the literal sequence.

 js 

```
0xFFFFFFFFFFFFF // 4503599627370495
0xabcdef123456  // 188900967593046
0XA             // 10
```

 

#### BigInt literal

The BigInt type is a numeric primitive in JavaScript that can represent integers with arbitrary precision. BigInt literals are created by appending `n` to the end of an integer.

 js 

```
123456789123456789n     // 123456789123456789
0o777777777777n         // 68719476735
0x123456789ABCDEFn      // 81985529216486895
0b11101001010101010101n // 955733
```

 

BigInt literals cannot start with `0` to avoid confusion with legacy octal literals.

 js 

```
0755n; // SyntaxError: invalid BigInt syntax
```

 

For octal `BigInt` numbers, always use zero followed by the letter "o" (uppercase or lowercase):

 js 

```
0o755n;
```

 

For more information about `BigInt`, see also JavaScript data structures .

#### Numeric separators

To improve readability for numeric literals, underscores (`_`, `U+005F`) can be used as separators:

 js 

```
1_000_000_000_000
1_050.95
0b1010_0001_1000_0101
0o2_2_5_6
0xA0_B0_C0
1_000_000_000_000_000_000_000n
```

 

Note these limitations:

 js 

```
// More than one underscore in a row is not allowed
100__000; // SyntaxError

// Not allowed at the end of numeric literals
100_; // SyntaxError

// Can not be used after leading 0
0_1; // SyntaxError
```

 
 
 

### String literals 

 
 

A string literal is zero or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for these code points:

- U+005C \ (backslash)

- U+000D <CR>

- U+000A <LF>

- The same kind of quote that begins the string literal

Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded.

 js 

```
'foo'
"bar"
```

 

The following subsections describe various escape sequences (`\` followed by one or more characters) available in string literals. Any escape sequence not listed below becomes an "identity escape" that becomes the code point itself. For example, `\z` is the same as `z`. There's a deprecated octal escape sequence syntax described in the Deprecated and obsolete features page. Many of these escape sequences are also valid in regular expressions — see Character escape .

#### Escape sequences

Special characters can be encoded using escape sequences:

 
 
 
 Escape sequence 
 Unicode code point 
 
 
 
 
 `\0` 
 null character (U+0000 NULL) 
 
 
 `\'` 
 single quote (U+0027 APOSTROPHE) 
 
 
 `\"` 
 double quote (U+0022 QUOTATION MARK) 
 
 
 `\\` 
 backslash (U+005C REVERSE SOLIDUS) 
 
 
 `\n` 
 newline (U+000A LINE FEED; LF) 
 
 
 `\r` 
 carriage return (U+000D CARRIAGE RETURN; CR) 
 
 
 `\v` 
 vertical tab (U+000B LINE TABULATION) 
 
 
 `\t` 
 tab (U+0009 CHARACTER TABULATION) 
 
 
 `\b` 
 backspace (U+0008 BACKSPACE) 
 
 
 `\f` 
 form feed (U+000C FORM FEED) 
 
 
 `\` followed by a line terminator 
 empty string 
 
 
 

The last escape sequence, `\` followed by a line terminator, is useful for splitting a string literal across multiple lines without changing its meaning.

 js 

```
const longString =
  "This is a very long string which needs \
to wrap across multiple lines because \
otherwise my code is unreadable.";
```

 

Make sure there is no space or any other character after the backslash (except for a line break), otherwise it will not work. If the next line is indented, the extra spaces will also be present in the string's value.

You can also use the `+` operator to append multiple strings together, like this:

 js 

```
const longString =
  "This is a very long string which needs " +
  "to wrap across multiple lines because " +
  "otherwise my code is unreadable.";
```

 

Both of the above methods result in identical strings.

#### Hexadecimal escape sequences

Hexadecimal escape sequences consist of `\x` followed by exactly two hexadecimal digits representing a code unit or code point in the range 0x0000 to 0x00FF.

 js 

```
"\xA9"; // "©"
```

 

#### Unicode escape sequences

A Unicode escape sequence consists of exactly four hexadecimal digits following `\u`. It represents a code unit in the UTF-16 encoding. For code points U+0000 to U+FFFF, the code unit is equal to the code point. Code points U+10000 to U+10FFFF require two escape sequences representing the two code units (a surrogate pair) used to encode the character; the surrogate pair is distinct from the code point.

See also `String.fromCharCode()` and `String.prototype.charCodeAt()` .

 js 

```
"\u00A9"; // "©" (U+A9)
```

 

#### Unicode code point escapes

A Unicode code point escape consists of `\u{`, followed by a code point in hexadecimal base, followed by `}`. The value of the hexadecimal digits must be in the range 0 and 0x10FFFF inclusive. Code points in the range U+10000 to U+10FFFF do not need to be represented as a surrogate pair.

See also `String.fromCodePoint()` and `String.prototype.codePointAt()` .

 js 

```
"\u{2F804}"; // CJK COMPATIBILITY IDEOGRAPH-2F804 (U+2F804)

// the same character represented as a surrogate pair
"\uD87E\uDC04";
```

 
 
 

### Regular expression literals 

 
 

Regular expression literals are enclosed by two forward slashes (`/`). The lexer consumes all characters up to the next unescaped forward slash or the end of the line, unless the forward slash appears within a character class (`[]`). Some characters (namely, those that are identifier parts ) can appear after the closing slash, denoting flags.

The lexical grammar is very lenient: not all regular expression literals that get identified as one token are valid regular expressions.

See also `RegExp` for more information.

 js 

```
/ab+c/g;
/[/]/;
```

 

A regular expression literal cannot start with two forward slashes (`//`), because that would be a line comment. To specify an empty regular expression, use `/(?:)/`.

 
 

### Template literals 

 
 

One template literal consists of several tokens: ``xxx${` (template head), `}xxx${` (template middle), and `}xxx`` (template tail) are individual tokens, while any expression may come between them.

See also template literals for more information.

 js 

```
`string text`;

`string text line 1
 string text line 2`;

`string text ${expression} string text`;

tag`string text ${expression} string text`;
```

 
 
 

## Automatic semicolon insertion 

 
 

Some JavaScript statements ' syntax definitions require semicolons (`;`) at the end. They include:

- `var` , `let` , `const` , `using` , `await using` 

- Expression statements 

- `do...while` 

- `continue` , `break` , `return` , `throw` 

- `debugger` 

- Class field declarations ( public or private )

- `import` , `export` 

However, to make the language more approachable and convenient, JavaScript is able to automatically insert semicolons when consuming the token stream, so that some invalid token sequences can be "fixed" to valid syntax. This step happens after the program text has been parsed to tokens according to the lexical grammar. There are three cases when semicolons are automatically inserted:

1. When a token not allowed by the grammar is encountered, and it's separated from the previous token by at least one line terminator (including a block comment that includes at least one line terminator), or the token is "}", then a semicolon is inserted before the token.

 js 

```
{ 1
2 } 3

// is transformed by ASI into:

{ 1
;2 ;} 3;

// Which is valid grammar encoding three statements,
// each consisting of a number literal
```

 

The ending ")" of `do...while` is taken care of as a special case by this rule as well.

 js 

```
do {
  // …
} while (condition) /* ; */ // ASI here
const a = 1
```

 

However, semicolons are not inserted if the semicolon would then become the separator in the `for` statement's head.

 js 

```
for (
  let a = 1 // No ASI here
  a < 10 // No ASI here
  a++
) {}
```

 

Semicolons are also never inserted as empty statements . For example, in the code below, if a semicolon is inserted after ")", then the code would be valid, with an empty statement as the `if` body and the `const` declaration being a separate statement. However, because automatically inserted semicolons cannot become empty statements, this causes a declaration to become the body of the `if` statement, which is not valid.

 js 

```
if (Math.random() > 0.5)
const x = 1 // SyntaxError: Unexpected token 'const'
```

 

2. When the end of the input stream of tokens is reached, and the parser is unable to parse the single input stream as a complete program, a semicolon is inserted at the end.

 js 

```
const a = 1 /* ; */ // ASI here
```

 

This rule is a complement to the previous rule, specifically for the case where there's no "offending token" but the end of input stream.

3. When the grammar forbids line terminators in some place but a line terminator is found, a semicolon is inserted. These places include:

- `expr ++`, `expr --`

- `continue lbl`

- `break lbl`

- `return expr`

- `throw expr`

- `yield expr`

- `yield * expr`

- `(param) => {}`

- `async function`, `async prop()`, `async function*`, `async *prop()`, `async (param) => {}`

- `using id`, `await using id`

Here `++` is not treated as a postfix operator applying to variable `b`, because a line terminator occurs between `b` and `++`.

 js 

```
a = b
++c

// is transformed by ASI into

a = b;
++c;
```

 

Here, the `return` statement returns `undefined`, and the `a + b` becomes an unreachable statement.

 js 

```
return
a + b

// is transformed by ASI into

return;
a + b;
```

 

Note that ASI would only be triggered if a line break separates tokens that would otherwise produce invalid syntax. If the next token can be parsed as part of a valid structure, semicolons would not be inserted. For example:

 js 

```
const a = 1
(1).toString()

const b = 1
[1, 2, 3].forEach(console.log)
```

 

Because `()` can be seen as a function call, it would usually not trigger ASI. Similarly, `[]` may be a member access. The code above is equivalent to:

 js 

```
const a = 1(1).toString();

const b = 1[1, 2, 3].forEach(console.log);
```

 

This happens to be valid syntax. `1[1, 2, 3]` is a property accessor with a comma -joined expression. Therefore, you would get errors like "1 is not a function" and "Cannot read properties of undefined (reading 'forEach')" when running the code.

Within classes, class fields and generator methods can be a pitfall as well.

 js 

```
class A {
  a = 1
  *gen() {}
}
```

 

It is seen as:

 js 

```
class A {
  a = 1 * gen() {}
}
```

 

And therefore will be a syntax error around `{`.

There are the following rules-of-thumb for dealing with ASI, if you want to enforce semicolon-less style:

- 

Write postfix `++` and `--` on the same line as their operands.

 js 

```
const a = b
++
console.log(a) // ReferenceError: Invalid left-hand side expression in prefix operation
```

 
 js 

```
const a = b++
console.log(a)
```

 

- 

The expressions after `return`, `throw`, or `yield` should be on the same line as the keyword.

 js 

```
function foo() {
  return
    1 + 1 // Returns undefined; 1 + 1 is ignored
}
```

 
 js 

```
function foo() {
  return 1 + 1
}

function foo() {
  return (
    1 + 1
  )
}
```

 

- 

Similarly, the label identifier after `break` or `continue` should be on the same line as the keyword.

 js 

```
outerBlock: {
  innerBlock: {
    break
      outerBlock // SyntaxError: Illegal break statement
  }
}
```

 
 js 

```
outerBlock: {
  innerBlock: {
    break outerBlock
  }
}
```

 

- 

The `=>` of an arrow function should be on the same line as the end of its parameters.

 js 

```
const foo = (a, b)
  => a + b
```

 
 js 

```
const foo = (a, b) =>
  a + b
```

 

- 

The `async` of async functions, methods, etc. cannot be directly followed by a line terminator.

 js 

```
async
function foo() {}
```

 
 js 

```
async function
foo() {}
```

 

- 

The `using` keyword in `using` and `await using` statements should be on the same line as the first identifier it declares.

 js 

```
using
resource = acquireResource()
```

 
 js 

```
using resource
  = acquireResource()
```

 

- 

If a line starts with one of `(`, `[`, ```, `+`, `-`, `/` (as in regex literals), prefix it with a semicolon, or end the previous line with a semicolon.

 js 

```
// The () may be merged with the previous line as a function call
(() => {
  // …
})()

// The [ may be merged with the previous line as a property access
[1, 2, 3].forEach(console.log)

// The ` may be merged with the previous line as a tagged template literal
`string text ${data}`.match(pattern).forEach(console.log)

// The + may be merged with the previous line as a binary + expression
+a.toString()

// The - may be merged with the previous line as a binary - expression
-a.toString()

// The / may be merged with the previous line as a division expression
/pattern/.exec(str).forEach(console.log)
```

 
 js 

```
;(() => {
  // …
})()
;[1, 2, 3].forEach(console.log)
;`string text ${data}`.match(pattern).forEach(console.log)
;+a.toString()
;-a.toString()
;/pattern/.exec(str).forEach(console.log)
```

 

- 

Class fields should preferably always be ended with semicolons — in addition to the previous rule (which includes a field declaration followed by a computed property , since the latter starts with `[`), semicolons are also required between a field declaration and a generator method.

 js 

```
class A {
  a = 1
  [b] = 2
  *gen() {} // Seen as a = 1[b] = 2 * gen() {}
}
```

 
 js 

```
class A {
  a = 1;
  [b] = 2;
  *gen() {}
}
```

 

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Grammar and types guide

- Micro-feature from ES6, now in Firefox Aurora and Nightly: binary and octal numbers by Jeff Walden (2013)

- JavaScript character escape sequences by Mathias Bynens (2011)

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 29, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### Array - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array

Array - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# Array

 
 
 
 
 
 Baseline
 
 Widely available
 
 *
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 

* Some parts of this feature may have varying levels of support.

 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `Array` object, as with arrays in other programming languages, enables storing a collection of multiple items under a single variable name , and has members for performing common array operations .

 
 
 
 
 
 

## Description 

 
 

In JavaScript, arrays aren't primitives but are instead `Array` objects with the following core characteristics:

- JavaScript arrays are resizable and can contain a mix of different data types . (When those characteristics are undesirable, use typed arrays instead.)

- JavaScript arrays are not associative arrays and so, array elements cannot be accessed using arbitrary strings as indexes, but must be accessed using nonnegative integers (or their respective string form) as indexes.

- JavaScript arrays are zero-indexed : the first element of an array is at index `0`, the second is at index `1`, and so on — and the last element is at the value of the array's `length` property minus `1`.

- JavaScript array-copy operations create shallow copies . (All standard built-in copy operations with any JavaScript objects create shallow copies, rather than deep copies ).

 
 

### Array indices 

 
 

`Array` objects cannot use arbitrary strings as element indexes (as in an associative array ) but must use nonnegative integers (or their respective string form). Setting or accessing via non-integers will not set or retrieve an element from the array list itself, but will set or access a variable associated with that array's object property collection . The array's object properties and list of array elements are separate, and the array's traversal and mutation operations cannot be applied to these named properties.

Array elements are object properties in the same way that `toString` is a property (to be specific, however, `toString()` is a method). Nevertheless, trying to access an element of an array as follows throws a syntax error because the property name is not valid:

 js 

```
arr.0; // a syntax error
```

 

JavaScript syntax requires properties beginning with a digit to be accessed using bracket notation instead of dot notation . It's also possible to quote the array indices (e.g., `years['2']` instead of `years[2]`), although usually not necessary.

The `2` in `years[2]` is coerced into a string by the JavaScript engine through an implicit `toString` conversion. As a result, `'2'` and `'02'` would refer to two different slots on the `years` object, and the following example could be `true`:

 js 

```
console.log(years["2"] !== years["02"]);
```

 

Only `years['2']` is an actual array index. `years['02']` is an arbitrary string property that will not be visited in array iteration.

 
 

### Relationship between length and numerical properties 

 
 

A JavaScript array's `length` property and numerical properties are connected.

Several of the built-in array methods (e.g., `join()` , `slice()` , `indexOf()` , etc.) take into account the value of an array's `length` property when they're called.

Other methods (e.g., `push()` , `splice()` , etc.) also result in updates to an array's `length` property.

 js 

```
const fruits = [];
fruits.push("banana", "apple", "peach");
console.log(fruits.length); // 3
```

 

When setting a property on a JavaScript array when the property is a valid array index and that index is outside the current bounds of the array, the engine will update the array's `length` property accordingly:

 js 

```
fruits[5] = "mango";
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6
```

 

Increasing the `length` extends the array by adding empty slots without creating any new elements — not even `undefined`.

 js 

```
fruits.length = 10;
console.log(fruits); // ['banana', 'apple', 'peach', empty x 2, 'mango', empty x 4]
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
console.log(fruits[8]); // undefined
```

 

Decreasing the `length` property does, however, delete elements.

 js 

```
fruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2
```

 

This is explained further on the `length` page.

 
 

### Array methods and empty slots 

 
 

Array methods have different behaviors when encountering empty slots in sparse arrays . In general, older methods (e.g., `forEach`) treat empty slots differently from indices that contain `undefined`.

Methods that have special treatment for empty slots include the following: `concat()` , `copyWithin()` , `every()` , `filter()` , `flat()` , `flatMap()` , `forEach()` , `indexOf()` , `lastIndexOf()` , `map()` , `reduce()` , `reduceRight()` , `reverse()` , `slice()` , `some()` , `sort()` , and `splice()` . Iteration methods such as `forEach` don't visit empty slots at all. Other methods, such as `concat`, `copyWithin`, etc., preserve empty slots when doing the copying, so in the end the array is still sparse.

 js 

```
const colors = ["red", "yellow", "blue"];
colors[5] = "purple";
colors.forEach((item, index) => {
  console.log(`${index}: ${item}`);
});
// Output:
// 0: red
// 1: yellow
// 2: blue
// 5: purple

colors.reverse(); // ['purple', empty × 2, 'blue', 'yellow', 'red']
```

 

Newer methods (e.g., `keys`) do not treat empty slots specially and treat them as if they contain `undefined`. Methods that conflate empty slots with `undefined` elements include the following: `entries()` , `fill()` , `find()` , `findIndex()` , `findLast()` , `findLastIndex()` , `includes()` , `join()` , `keys()` , `toLocaleString()` , `toReversed()` , `toSorted()` , `toSpliced()` , `values()` , and `with()` .

 js 

```
const colors = ["red", "yellow", "blue"];
colors[5] = "purple";
const iterator = colors.keys();
for (const key of iterator) {
  console.log(`${key}: ${colors[key]}`);
}
// Output
// 0: red
// 1: yellow
// 2: blue
// 3: undefined
// 4: undefined
// 5: purple

const newColors = colors.toReversed(); // ['purple', undefined, undefined, 'blue', 'yellow', 'red']
```

 
 
 

### Copying methods and mutating methods 

 
 

Some methods do not mutate the existing array that the method was called on, but instead return a new array. They do so by first constructing a new array and then populating it with elements. The copy always happens shallowly — the method never copies anything beyond the initially created array. Elements of the original array(s) are copied into the new array as follows:

- Objects: the object reference is copied into the new array. Both the original and new array refer to the same object. That is, if a referenced object is modified, the changes are visible to both the new and original arrays.

- Primitive types such as strings, numbers and booleans (not `String` , `Number` , and `Boolean` objects): their values are copied into the new array.

Other methods mutate the array that the method was called on, in which case their return value differs depending on the method: sometimes a reference to the same array, sometimes the length of the new array.

The following methods create new arrays by accessing `this.constructor[Symbol.species]` to determine the constructor to use: `concat()` , `filter()` , `flat()` , `flatMap()` , `map()` , `slice()` , and `splice()` (to construct the array of removed elements that's returned).

The following methods always create new arrays with the `Array` base constructor: `toReversed()` , `toSorted()` , `toSpliced()` , and `with()` .

The following table lists the methods that mutate the original array, and the corresponding non-mutating alternative:

 
 
 
 Mutating method 
 Non-mutating alternative 
 
 
 
 
 `copyWithin()` 
 No one-method alternative 
 
 
 `fill()` 
 No one-method alternative 
 
 
 `pop()` 
 `slice(0, -1)` 
 
 
 `push(v1, v2)` 
 `concat([v1, v2])` 
 
 
 `reverse()` 
 `toReversed()` 
 
 
 `shift()` 
 `slice(1)` 
 
 
 `sort()` 
 `toSorted()` 
 
 
 `splice()` 
 `toSpliced()` 
 
 
 `unshift(v1, v2)` 
 `toSpliced(0, 0, v1, v2)` 
 
 
 

An easy way to change a mutating method into a non-mutating alternative is to use the spread syntax or `slice()` to create a copy first:

 js 

```
arr.copyWithin(0, 1, 2); // mutates arr
const arr2 = arr.slice().copyWithin(0, 1, 2); // does not mutate arr
const arr3 = [...arr].copyWithin(0, 1, 2); // does not mutate arr
```

 
 
 

### Iterative methods 

 
 

Many array methods take a callback function as an argument. The callback function is called sequentially and at most once for each element in the array, and the return value of the callback function is used to determine the return value of the method. They all share the same signature:

 js 

```
method(callbackFn, thisArg)
```

 

Where `callbackFn` takes three arguments:

 
 `element` 
 

The current element being processed in the array.

 
 `index` 
 

The index of the current element being processed in the array.

 
 `array` 
 

The array that the method was called upon.

 
 

What `callbackFn` is expected to return depends on the array method that was called.

The `thisArg` argument (defaults to `undefined`) will be used as the `this` value when calling `callbackFn`. The `this` value ultimately observable by `callbackFn` is determined according to the usual rules : if `callbackFn` is non-strict , primitive `this` values are wrapped into objects, and `undefined`/`null` is substituted with `globalThis` . The `thisArg` argument is irrelevant for any `callbackFn` defined with an arrow function , as arrow functions don't have their own `this` binding .

The `array` argument passed to `callbackFn` is most useful if you want to read another index during iteration, because you may not always have an existing variable that refers to the current array. You should generally not mutate the array during iteration (see mutating initial array in iterative methods ), but you can also use this argument to do so. The `array` argument is not the array that is being built, in the case of methods like `map()`, `filter()`, and `flatMap()` — there is no way to access the array being built from the callback function.

All iterative methods are copying and generic , although they behave differently with empty slots .

The following methods are iterative: `every()` , `filter()` , `find()` , `findIndex()` , `findLast()` , `findLastIndex()` , `flatMap()` , `forEach()` , `map()` , and `some()` .

In particular, `every()` , `find()` , `findIndex()` , `findLast()` , `findLastIndex()` , and `some()` do not always invoke `callbackFn` on every element — they stop iteration as soon as the return value is determined.

The `reduce()` and `reduceRight()` methods also take a callback function and run it at most once for each element in the array, but they have slightly different signatures from typical iterative methods (for example, they don't accept `thisArg`).

The `sort()` method also takes a callback function, but it is not an iterative method. It mutates the array in-place, doesn't accept `thisArg`, and may invoke the callback multiple times on an index.

Iterative methods iterate the array like the following (with a lot of technical details omitted):

 js 

```
function method(callbackFn, thisArg) {
  const length = this.length;
  for (let i = 0; i < length; i++) {
    if (i in this) {
      const result = callbackFn.call(thisArg, this[i], i, this);
      // Do something with result; maybe return early
    }
  }
}
```

 

Note the following:

- Not all methods do the `i in this` test. The `find`, `findIndex`, `findLast`, and `findLastIndex` methods do not, but other methods do.

- The `length` is memorized before the loop starts. This affects how insertions and deletions during iteration are handled (see mutating initial array in iterative methods ).

- The method doesn't memorize the array contents, so if any index is modified during iteration, the new value might be observed.

- The code above iterates the array in ascending order of index. Some methods iterate in descending order of index (`for (let i = length - 1; i >= 0; i--)`): `reduceRight()`, `findLast()`, and `findLastIndex()`.

- `reduce` and `reduceRight` have slightly different signatures and do not always start at the first/last element.

 
 

### Generic array methods 

 
 

Array methods are always generic — they don't access any internal data of the array object. They only access the array elements through the `length` property and the indexed elements. This means that they can be called on array-like objects as well.

 js 

```
const arrayLike = {
  0: "a",
  1: "b",
  length: 2,
};
console.log(Array.prototype.join.call(arrayLike, "+")); // 'a+b'
```

 

#### Normalization of the length property

The `length` property is converted to an integer and then clamped to the range between 0 and 2 53 - 1. `NaN` becomes `0`, so even when `length` is not present or is `undefined`, it behaves as if it has value `0`.

The language avoids setting `length` to an unsafe integer . All built-in methods will throw a `TypeError` if `length` will be set to a number greater than 2 53 - 1. However, because the `length` property of arrays throws an error if it's set to greater than 2 32 - 1, the safe integer threshold is usually not reached unless the method is called on a non-array object.

 js 

```
Array.prototype.flat.call({}); // []
```

 

Some array methods set the `length` property of the array object. They always set the value after normalization, so `length` always ends as an integer.

 js 

```
const a = { length: 0.7 };
Array.prototype.push.call(a);
console.log(a.length); // 0
```

 

#### Array-like objects

The term array-like object refers to any object that doesn't throw during the `length` conversion process described above. In practice, such object is expected to actually have a `length` property and to have indexed elements in the range `0` to `length - 1`. (If it doesn't have all indices, it will be functionally equivalent to a sparse array .) Any integer index less than zero or greater than `length - 1` is ignored when an array method operates on an array-like object.

Many DOM objects are array-like — for example, `NodeList` and `HTMLCollection` . The `arguments` object is also array-like. You can call array methods on them even if they don't have these methods themselves.

 js 

```
function f() {
  console.log(Array.prototype.join.call(arguments, "+"));
}

f("a", "b"); // 'a+b'
```

 
 
 

## Constructor 

 
 
 `Array()` 
 

Creates a new `Array` object.

 
 
 
 

## Static properties 

 
 
 `Array[Symbol.species]` 
 

Returns the `Array` constructor.

 
 
 
 

## Static methods 

 
 
 `Array.from()` 
 

Creates a new `Array` instance from an iterable or array-like object.

 
 `Array.fromAsync()` 
 

Creates a new `Array` instance from an async iterable, iterable, or array-like object.

 
 `Array.isArray()` 
 

Returns `true` if the argument is an array, or `false` otherwise.

 
 `Array.of()` 
 

Creates a new `Array` instance with a variable number of arguments, regardless of number or type of the arguments.

 
 
 
 

## Instance properties 

 
 

These properties are defined on `Array.prototype` and shared by all `Array` instances.

 
 `Array.prototype.constructor` 
 

The constructor function that created the instance object. For `Array` instances, the initial value is the `Array` constructor.

 
 `Array.prototype[Symbol.unscopables]` 
 

Contains property names that were not included in the ECMAScript standard prior to the ES2015 version and that are ignored for `with` statement-binding purposes.

 
 

These properties are own properties of each `Array` instance.

 
 `length` 
 

Reflects the number of elements in an array.

 
 
 
 

## Instance methods 

 
 
 `Array.prototype.at()` 
 

Returns the array item at the given index. Accepts negative integers, which count back from the last item.

 
 `Array.prototype.concat()` 
 

Returns a new array that is the calling array joined with other array(s) and/or value(s).

 
 `Array.prototype.copyWithin()` 
 

Copies a sequence of array elements within an array.

 
 `Array.prototype.entries()` 
 

Returns a new array iterator object that contains the key/value pairs for each index in an array.

 
 `Array.prototype.every()` 
 

Returns `false` if it finds one element in the array that does not satisfy the provided testing function. Otherwise, it returns `true`.

 
 `Array.prototype.fill()` 
 

Fills all the elements of an array from a start index to an end index with a static value.

 
 `Array.prototype.filter()` 
 

Returns a new array containing all elements of the calling array for which the provided filtering function returns `true`.

 
 `Array.prototype.find()` 
 

Returns the value of the first element in the array that satisfies the provided testing function, or `undefined` if no appropriate element is found.

 
 `Array.prototype.findIndex()` 
 

Returns the index of the first element in the array that satisfies the provided testing function, or `-1` if no appropriate element was found.

 
 `Array.prototype.findLast()` 
 

Returns the value of the last element in the array that satisfies the provided testing function, or `undefined` if no appropriate element is found.

 
 `Array.prototype.findLastIndex()` 
 

Returns the index of the last element in the array that satisfies the provided testing function, or `-1` if no appropriate element was found.

 
 `Array.prototype.flat()` 
 

Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth.

 
 `Array.prototype.flatMap()` 
 

Returns a new array formed by applying a given callback function to each element of the calling array, and then flattening the result by one level.

 
 `Array.prototype.forEach()` 
 

Calls a function for each element in the calling array.

 
 `Array.prototype.includes()` 
 

Determines whether the calling array contains a value, returning `true` or `false` as appropriate.

 
 `Array.prototype.indexOf()` 
 

Returns the first (least) index at which a given element can be found in the calling array.

 
 `Array.prototype.join()` 
 

Joins all elements of an array into a string.

 
 `Array.prototype.keys()` 
 

Returns a new array iterator that contains the keys for each index in the calling array.

 
 `Array.prototype.lastIndexOf()` 
 

Returns the last (greatest) index at which a given element can be found in the calling array, or `-1` if none is found.

 
 `Array.prototype.map()` 
 

Returns a new array containing the results of invoking a function on every element in the calling array.

 
 `Array.prototype.pop()` 
 

Removes the last element from an array and returns that element.

 
 `Array.prototype.push()` 
 

Adds one or more elements to the end of an array, and returns the new `length` of the array.

 
 `Array.prototype.reduce()` 
 

Executes a user-supplied "reducer" callback function on each element of the array (from left to right), to reduce it to a single value.

 
 `Array.prototype.reduceRight()` 
 

Executes a user-supplied "reducer" callback function on each element of the array (from right to left), to reduce it to a single value.

 
 `Array.prototype.reverse()` 
 

Reverses the order of the elements of an array in place . (First becomes the last, last becomes first.)

 
 `Array.prototype.shift()` 
 

Removes the first element from an array and returns that element.

 
 `Array.prototype.slice()` 
 

Extracts a section of the calling array and returns a new array.

 
 `Array.prototype.some()` 
 

Returns `true` if it finds one element in the array that satisfies the provided testing function. Otherwise, it returns `false`.

 
 `Array.prototype.sort()` 
 

Sorts the elements of an array in place and returns the array.

 
 `Array.prototype.splice()` 
 

Adds and/or removes elements from an array.

 
 `Array.prototype.toLocaleString()` 
 

Returns a localized string representing the calling array and its elements. Overrides the `Object.prototype.toLocaleString()` method.

 
 `Array.prototype.toReversed()` 
 

Returns a new array with the elements in reversed order, without modifying the original array.

 
 `Array.prototype.toSorted()` 
 

Returns a new array with the elements sorted in ascending order, without modifying the original array.

 
 `Array.prototype.toSpliced()` 
 

Returns a new array with some elements removed and/or replaced at a given index, without modifying the original array.

 
 `Array.prototype.toString()` 
 

Returns a string representing the calling array and its elements. Overrides the `Object.prototype.toString()` method.

 
 `Array.prototype.unshift()` 
 

Adds one or more elements to the front of an array, and returns the new `length` of the array.

 
 `Array.prototype.values()` 
 

Returns a new array iterator object that contains the values for each index in the array.

 
 `Array.prototype.with()` 
 

Returns a new array with the element at the given index replaced with the given value, without modifying the original array.

 
 `Array.prototype[Symbol.iterator]()` 
 

An alias for the `values()` method by default.

 
 
 
 

## Examples 

 
 

This section provides some examples of common array operations in JavaScript.

 

 Note: 
If you're not yet familiar with array basics, consider first reading JavaScript First Steps: Arrays , which explains what arrays are , and includes other examples of common array operations.

 
 
 

### Create an array 

 
 

This example shows three ways to create new array: first using array literal notation , then using the `Array()` constructor, and finally using `String.prototype.split()` to build the array from a string.

 js 

```
// 'fruits' array created using array literal notation.
const fruits = ["Apple", "Banana"];
console.log(fruits.length);
// 2

// 'fruits2' array created using the Array() constructor.
const fruits2 = new Array("Apple", "Banana");
console.log(fruits2.length);
// 2

// 'fruits3' array created using String.prototype.split().
const fruits3 = "Apple, Banana".split(", ");
console.log(fruits3.length);
// 2
```

 
 
 

### Create a string from an array 

 
 

This example uses the `join()` method to create a string from the `fruits` array.

 js 

```
const fruits = ["Apple", "Banana"];
const fruitsString = fruits.join(", ");
console.log(fruitsString);
// "Apple, Banana"
```

 
 
 

### Access an array item by its index 

 
 

This example shows how to access items in the `fruits` array by specifying the index number of their position in the array.

 js 

```
const fruits = ["Apple", "Banana"];

// The index of an array's first element is always 0.
fruits[0]; // Apple

// The index of an array's second element is always 1.
fruits[1]; // Banana

// The index of an array's last element is always one
// less than the length of the array.
fruits[fruits.length - 1]; // Banana

// Using an index number larger than the array's length
// returns 'undefined'.
fruits[99]; // undefined
```

 
 
 

### Find the index of an item in an array 

 
 

This example uses the `indexOf()` method to find the position (index) of the string `"Banana"` in the `fruits` array.

 js 

```
const fruits = ["Apple", "Banana"];
console.log(fruits.indexOf("Banana"));
// 1
```

 
 
 

### Check if an array contains a certain item 

 
 

This example shows two ways to check if the `fruits` array contains `"Banana"` and `"Cherry"`: first with the `includes()` method, and then with the `indexOf()` method to test for an index value that's not `-1`.

 js 

```
const fruits = ["Apple", "Banana"];

fruits.includes("Banana"); // true
fruits.includes("Cherry"); // false

// If indexOf() doesn't return -1, the array contains the given item.
fruits.indexOf("Banana") !== -1; // true
fruits.indexOf("Cherry") !== -1; // false
```

 
 
 

### Append an item to an array 

 
 

This example uses the `push()` method to append a new string to the `fruits` array.

 js 

```
const fruits = ["Apple", "Banana"];
const newLength = fruits.push("Orange");
console.log(fruits);
// ["Apple", "Banana", "Orange"]
console.log(newLength);
// 3
```

 
 
 

### Remove the last item from an array 

 
 

This example uses the `pop()` method to remove the last item from the `fruits` array.

 js 

```
const fruits = ["Apple", "Banana", "Orange"];
const removedItem = fruits.pop();
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItem);
// Orange
```

 
 

 Note: 
`pop()` can only be used to remove the last item from an array. To remove multiple items from the end of an array, see the next example.

 
 
 

### Remove multiple items from the end of an array 

 
 

This example uses the `splice()` method to remove the last 3 items from the `fruits` array.

 js 

```
const fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = -3;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
```

 
 
 

### Truncate an array down to just its first N items 

 
 

This example uses the `splice()` method to truncate the `fruits` array down to just its first 2 items.

 js 

```
const fruits = ["Apple", "Banana", "Strawberry", "Mango", "Cherry"];
const start = 2;
const removedItems = fruits.splice(start);
console.log(fruits);
// ["Apple", "Banana"]
console.log(removedItems);
// ["Strawberry", "Mango", "Cherry"]
```

 
 
 

### Remove the first item from an array 

 
 

This example uses the `shift()` method to remove the first item from the `fruits` array.

 js 

```
const fruits = ["Apple", "Banana"];
const removedItem = fruits.shift();
console.log(fruits);
// ["Banana"]
console.log(removedItem);
// Apple
```

 
 

 Note: 
`shift()` can only be used to remove the first item from an array. To remove multiple items from the beginning of an array, see the next example.

 
 
 

### Remove multiple items from the beginning of an array 

 
 

This example uses the `splice()` method to remove the first 3 items from the `fruits` array.

 js 

```
const fruits = ["Apple", "Strawberry", "Cherry", "Banana", "Mango"];
const start = 0;
const deleteCount = 3;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Banana", "Mango"]
console.log(removedItems);
// ["Apple", "Strawberry", "Cherry"]
```

 
 
 

### Add a new first item to an array 

 
 

This example uses the `unshift()` method to add, at index `0`, a new item to the `fruits` array — making it the new first item in the array.

 js 

```
const fruits = ["Banana", "Mango"];
const newLength = fruits.unshift("Strawberry");
console.log(fruits);
// ["Strawberry", "Banana", "Mango"]
console.log(newLength);
// 3
```

 
 
 

### Remove a single item by index 

 
 

This example uses the `splice()` method to remove the string `"Banana"` from the `fruits` array — by specifying the index position of `"Banana"`.

 js 

```
const fruits = ["Strawberry", "Banana", "Mango"];
const start = fruits.indexOf("Banana");
const deleteCount = 1;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Strawberry", "Mango"]
console.log(removedItems);
// ["Banana"]
```

 
 
 

### Remove multiple items by index 

 
 

This example uses the `splice()` method to remove the strings `"Banana"` and `"Strawberry"` from the `fruits` array — by specifying the index position of `"Banana"`, along with a count of the number of total items to remove.

 js 

```
const fruits = ["Apple", "Banana", "Strawberry", "Mango"];
const start = 1;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount);
console.log(fruits);
// ["Apple", "Mango"]
console.log(removedItems);
// ["Banana", "Strawberry"]
```

 
 
 

### Replace multiple items in an array 

 
 

This example uses the `splice()` method to replace the last 2 items in the `fruits` array with new items.

 js 

```
const fruits = ["Apple", "Banana", "Strawberry"];
const start = -2;
const deleteCount = 2;
const removedItems = fruits.splice(start, deleteCount, "Mango", "Cherry");
console.log(fruits);
// ["Apple", "Mango", "Cherry"]
console.log(removedItems);
// ["Banana", "Strawberry"]
```

 
 
 

### Iterate over an array 

 
 

This example uses a `for...of` loop to iterate over the `fruits` array, logging each item to the console.

 js 

```
const fruits = ["Apple", "Mango", "Cherry"];
for (const fruit of fruits) {
  console.log(fruit);
}
// Apple
// Mango
// Cherry
```

 

But `for...of` is just one of many ways to iterate over any array; for more ways, see Loops and iteration , and see the documentation for the `every()` , `filter()` , `flatMap()` , `map()` , `reduce()` , and `reduceRight()` methods — and see the next example, which uses the `forEach()` method.

 
 

### Call a function on each element in an array 

 
 

This example uses the `forEach()` method to call a function on each element in the `fruits` array; the function causes each item to be logged to the console, along with the item's index number.

 js 

```
const fruits = ["Apple", "Mango", "Cherry"];
fruits.forEach((item, index, array) => {
  console.log(item, index);
});
// Apple 0
// Mango 1
// Cherry 2
```

 
 
 

### Merge multiple arrays together 

 
 

This example uses the `concat()` method to merge the `fruits` array with a `moreFruits` array, to produce a new `combinedFruits` array. Notice that `fruits` and `moreFruits` remain unchanged.

 js 

```
const fruits = ["Apple", "Banana", "Strawberry"];
const moreFruits = ["Mango", "Cherry"];
const combinedFruits = fruits.concat(moreFruits);
console.log(combinedFruits);
// ["Apple", "Banana", "Strawberry", "Mango", "Cherry"]

// The 'fruits' array remains unchanged.
console.log(fruits);
// ["Apple", "Banana", "Strawberry"]

// The 'moreFruits' array also remains unchanged.
console.log(moreFruits);
// ["Mango", "Cherry"]
```

 
 
 

### Copy an array 

 
 

This example shows three ways to create a new array from the existing `fruits` array: first by using spread syntax , then by using the `from()` method, and then by using the `slice()` method.

 js 

```
const fruits = ["Strawberry", "Mango"];

// Create a copy using spread syntax.
const fruitsCopy = [...fruits];
// ["Strawberry", "Mango"]

// Create a copy using the from() method.
const fruitsCopy2 = Array.from(fruits);
// ["Strawberry", "Mango"]

// Create a copy using the slice() method.
const fruitsCopy3 = fruits.slice();
// ["Strawberry", "Mango"]
```

 

All built-in array-copy operations ( spread syntax , `Array.from()` , `Array.prototype.slice()` , and `Array.prototype.concat()` ) create shallow copies . If you instead want a deep copy of an array, you can use `JSON.stringify()` to convert the array to a JSON string, and then `JSON.parse()` to convert the string back into a new array that's completely independent from the original array.

 js 

```
const fruitsDeepCopy = JSON.parse(JSON.stringify(fruits));
```

 

You can also create deep copies using the `structuredClone()` method, which has the advantage of allowing transferable objects in the source to be transferred to the new copy, rather than just cloned.

Finally, it's important to understand that assigning an existing array to a new variable doesn't create a copy of either the array or its elements. Instead the new variable is just a reference, or alias, to the original array; that is, the original array's name and the new variable name are just two names for the exact same object (and so will always evaluate as strictly equivalent ). Therefore, if you make any changes at all either to the value of the original array or to the value of the new variable, the other will change, too:

 js 

```
const fruits = ["Strawberry", "Mango"];
const fruitsAlias = fruits;
// 'fruits' and 'fruitsAlias' are the same object, strictly equivalent.
fruits === fruitsAlias; // true
// Any changes to the 'fruits' array change 'fruitsAlias' too.
fruits.unshift("Apple", "Banana");
console.log(fruits);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
console.log(fruitsAlias);
// ['Apple', 'Banana', 'Strawberry', 'Mango']
```

 
 
 

### Creating a two-dimensional array 

 
 

The following creates a chessboard as a two-dimensional array of strings. The first move is made by copying the `'p'` in `board[6][4]` to `board[4][4]`. The old position at `[6][4]` is made blank.

 js 

```
const board = [
  ["R", "N", "B", "Q", "K", "B", "N", "R"],
  ["P", "P", "P", "P", "P", "P", "P", "P"],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  [" ", " ", " ", " ", " ", " ", " ", " "],
  ["p", "p", "p", "p", "p", "p", "p", "p"],
  ["r", "n", "b", "q", "k", "b", "n", "r"],
];

console.log(`${board.join("\n")}\n\n`);

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = " ";
console.log(board.join("\n"));
```

 

Here is the output:



```
R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
 , , , , , , ,
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , ,
 , , , , , , ,
 , , , ,p, , ,
 , , , , , , ,
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
```


 
 

### Using an array to tabulate a set of values 

 
 js 

```
const values = [];
for (let x = 0; x < 10; x++) {
  values.push([2 ** x, 2 * x ** 2]);
}
console.table(values);
```

 

Results in



```
// The first column is the index
0  1    0
1  2    2
2  4    8
3  8    18
4  16   32
5  32   50
6  64   72
7  128  98
8  256  128
9  512  162
```


 
 

### Creating an array using the result of a match 

 
 

The result of a match between a `RegExp` and a string can create a JavaScript array that has properties and elements which provide information about the match. Such an array is returned by `RegExp.prototype.exec()` and `String.prototype.match()` .

For example:

 js 

```
// Match one d followed by one or more b's followed by one d
// Remember matched b's and the following d
// Ignore case

const myRe = /d(b+)(d)/i;
const execResult = myRe.exec("cdbBdbsbz");

console.log(execResult.input); // 'cdbBdbsbz'
console.log(execResult.index); // 1
console.log(execResult); // [ "dbBd", "bB", "d" ]
```

 

For more information about the result of a match, see the `RegExp.prototype.exec()` and `String.prototype.match()` pages.

 
 

### Mutating initial array in iterative methods 

 
 

 Iterative methods do not mutate the array on which it is called, but the function provided as `callbackFn` can. The key principle to remember is that only indexes between 0 and `arrayLength - 1` are visited, where `arrayLength` is the length of the array at the time the array method was first called, but the element passed to the callback is the value at the time the index is visited. Therefore:

- `callbackFn` will not visit any elements added beyond the array's initial length when the call to the iterative method began.

- Changes to already-visited indexes do not cause `callbackFn` to be invoked on them again.

- If an existing, yet-unvisited element of the array is changed by `callbackFn`, its value passed to the `callbackFn` will be the value at the time that element gets visited. Removed elements are not visited.

 

 Warning: 
Concurrent modifications of the kind described above frequently lead to hard-to-understand code and are generally to be avoided (except in special cases).

 

The following examples use the `forEach` method as an example, but other methods that visit indexes in ascending order work in the same way. We will first define a helper function:

 js 

```
function testSideEffect(effect) {
  const arr = ["e1", "e2", "e3", "e4"];
  arr.forEach((elem, index, arr) => {
    console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
    effect(arr, index);
  });
  console.log(`Final array: [${arr.join(", ")}]`);
}
```

 

Modification to indexes not visited yet will be visible once the index is reached:

 js 

```
testSideEffect((arr, index) => {
  if (index + 1 < arr.length) arr[index + 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2*, e3, e4], index: 1, elem: e2*
// array: [e1, e2*, e3*, e4], index: 2, elem: e3*
// array: [e1, e2*, e3*, e4*], index: 3, elem: e4*
// Final array: [e1, e2*, e3*, e4*]
```

 

Modification to already visited indexes does not change iteration behavior, although the array will be different afterwards:

 js 

```
testSideEffect((arr, index) => {
  if (index > 0) arr[index - 1] += "*";
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1*, e2, e3, e4], index: 2, elem: e3
// array: [e1*, e2*, e3, e4], index: 3, elem: e4
// Final array: [e1*, e2*, e3*, e4]
```

 

Inserting n elements at unvisited indexes that are less than the initial array length will make them be visited. The last n elements in the original array that now have index greater than the initial array length will not be visited:

 js 

```
testSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 0, "new");
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, new, e3, e4], index: 2, elem: new
// array: [e1, e2, new, e3, e4], index: 3, elem: e3
// Final array: [e1, e2, new, e3, e4]
// e4 is not visited because it now has index 4
```

 

Inserting n elements with index greater than the initial array length will not make them be visited:

 js 

```
testSideEffect((arr) => arr.push("new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4, new], index: 1, elem: e2
// array: [e1, e2, e3, e4, new, new], index: 2, elem: e3
// array: [e1, e2, e3, e4, new, new, new], index: 3, elem: e4
// Final array: [e1, e2, e3, e4, new, new, new, new]
```

 

Inserting n elements at already visited indexes will not make them be visited, but it shifts remaining elements back by n , so the current index and the n - 1 elements before it are visited again:

 js 

```
testSideEffect((arr, index) => arr.splice(index, 0, "new"));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [new, e1, e2, e3, e4], index: 1, elem: e1
// array: [new, new, e1, e2, e3, e4], index: 2, elem: e1
// array: [new, new, new, e1, e2, e3, e4], index: 3, elem: e1
// Final array: [new, new, new, new, e1, e2, e3, e4]
// e1 keeps getting visited because it keeps getting shifted back
```

 

Deleting n elements at unvisited indexes will make them not be visited anymore. Because the array has shrunk, the last n iterations will visit out-of-bounds indexes. If the method ignores non-existent indexes (see array methods and empty slots ), the last n iterations will be skipped; otherwise, they will receive `undefined`:

 js 

```
testSideEffect((arr, index) => {
  if (index === 1) arr.splice(2, 1);
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// Final array: [e1, e2, e4]
// Does not visit index 3 because it's out-of-bounds

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  if (index === 1) arr.splice(2, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e1, e2, e3, e4], index: 1, elem: e2
// array: [e1, e2, e4], index: 2, elem: e4
// array: [e1, e2, e4], index: 3, elem: undefined
```

 

Deleting n elements at already visited indexes does not change the fact that they were visited before they get deleted. Because the array has shrunk, the next n elements after the current index are skipped. If the method ignores non-existent indexes, the last n iterations will be skipped; otherwise, they will receive `undefined`:

 js 

```
testSideEffect((arr, index) => arr.splice(index, 1));
// array: [e1, e2, e3, e4], index: 0, elem: e1
// Does not visit e2 because e2 now has index 0, which has already been visited
// array: [e2, e3, e4], index: 1, elem: e3
// Does not visit e4 because e4 now has index 1, which has already been visited
// Final array: [e2, e4]
// Index 2 is out-of-bounds, so it's not visited

// Compare this with find(), which treats nonexistent indexes as undefined:
const arr2 = ["e1", "e2", "e3", "e4"];
arr2.find((elem, index, arr) => {
  console.log(`array: [${arr.join(", ")}], index: ${index}, elem: ${elem}`);
  arr.splice(index, 1);
  return false;
});
// array: [e1, e2, e3, e4], index: 0, elem: e1
// array: [e2, e3, e4], index: 1, elem: e3
// array: [e2, e4], index: 2, elem: undefined
// array: [e2, e4], index: 3, elem: undefined
```

 

For methods that iterate in descending order of index, insertion causes elements to be skipped, and deletion causes elements to be visited multiple times. Adjust the code above yourself to see the effects.

 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-array-objects 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Indexed collections guide

- `TypedArray` 

- `ArrayBuffer` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Sep 28, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### function expression - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function

function expression - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# function expression

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨July 2015⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `function` keyword can be used to define a function inside an expression.

You can also define functions using the `function` declaration or the arrow syntax .

 
 
 
 
 
 

## Try it 

 
 
 

```
const getRectArea = function (width, height) {
  return width * height;
};

console.log(getRectArea(3, 4));
// Expected output: 12
```

 
 
 

## Syntax 

 
 js 

```
function (param0) {
  statements
}
function (param0, param1) {
  statements
}
function (param0, param1, /* …, */ paramN) {
  statements
}

function name(param0) {
  statements
}
function name(param0, param1) {
  statements
}
function name(param0, param1, /* …, */ paramN) {
  statements
}
```

 
 

 Note: 
An expression statement cannot begin with the keyword `function` to avoid ambiguity with a `function` declaration . The `function` keyword only begins an expression when it appears in a context that cannot accept statements.

 
 
 

### Parameters 

 
 
 `name` Optional 
 

The function name. Can be omitted, in which case the function is anonymous . The name is only local to the function body.

 
 `paramN` Optional 
 

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference .

 
 `statements` Optional 
 

The statements which comprise the body of the function.

 
 
 
 

## Description 

 
 

A `function` expression is very similar to, and has almost the same syntax as, a `function` declaration . The main difference between a `function` expression and a `function` declaration is the function name , which can be omitted in `function` expressions to create anonymous functions. A `function` expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined. See also the chapter about functions for more information.

 
 

### Function expression hoisting 

 
 

Function expressions in JavaScript are not hoisted, unlike function declarations . You can't use function expressions before you create them:

 js 

```
console.log(notHoisted); // undefined
// Even though the variable name is hoisted,
// the definition isn't. so it's undefined.
notHoisted(); // TypeError: notHoisted is not a function

var notHoisted = function () {
  console.log("bar");
};
```

 
 
 

### Named function expression 

 
 

If you want to refer to the current function inside the function body, you need to create a named function expression. This name is then local only to the function body (scope). This avoids using the deprecated `arguments.callee` property to call the function recursively.

 js 

```
const math = {
  factorial: function factorial(n) {
    console.log(n);
    if (n <= 1) {
      return 1;
    }
    return n * factorial(n - 1);
  },
};

math.factorial(3); // 3;2;1;
```

 

If a function expression is named, the `name` property of the function is set to that name, instead of the implicit name inferred from syntax (such as the variable the function is assigned to).

Unlike declarations, the name of the function expressions is read-only.

 js 

```
"use strict";

function foo() {
  foo = 1;
}
foo();
console.log(foo); // 1
(function foo() {
  foo = 1; // TypeError: Assignment to constant variable.
})();
```

 
 
 

## Examples 

 
 
 
 

### Using function expression 

 
 

The following example defines an unnamed function and assigns it to `x`. The function returns the square of its argument:

 js 

```
const x = function (y) {
  return y * y;
};
```

 
 
 

### Using a function as a callback 

 
 

More commonly it is used as a callback :

 js 

```
button.addEventListener("click", function (event) {
  console.log("button is clicked!");
});
```

 
 
 

### Using an Immediately Invoked Function Expression (IIFE) 

 
 

 IIFEs are a common pattern used to execute arbitrarily many statements in their own scope (and possibly return a value), in a location that requires a single expression. Many traditional use cases of IIFEs have been obsoleted by new syntax features such as modules and block-scoped declarations . IIFEs themselves are more commonly written with arrow functions now, but the idea remains the same. In general, IIFEs look like this:

 js 

```
// standard IIFE
(function () {
  // statements…
})();

// IIFE with arguments
(function (a, b) {
  console.log(a + b);
})(1, 2); // logs 3

// IIFE being used to initialize a variable
const value = (() => {
  const randomValue = Math.random();
  if (randomValue > 0.5) {
    return "heads";
  }
  return "tails";
})();
```

 

Here, we introduce several use cases with examples.

 
 

### Avoid polluting the global namespace in script code 

 
 

The top-level scope of all scripts are shared, which could include many functions and global variables from different files, so to avoid name conflicts, it's important to limit the number of globally declared names (this is greatly mitigated in modules , but sometimes limiting the scope of temporary variables is still useful, especially when the file is very long). If we have some initialization code that we don't need to use again, we could use the IIFE pattern, which is better than using a function declaration or a function expression because it ensures that the code is only run here and once.

 js 

```
// top-level of a script (not a module)

var globalVariable = (() => {
  // some initialization code
  let firstVariable = something();
  let secondVariable = somethingElse();
  return firstVariable + secondVariable;
})();

// firstVariable and secondVariable cannot be accessed outside of the function body.
```

 
 
 

### The module pattern 

 
 

We would also use IIFE to create private and public variables and methods. For a more sophisticated use of the module
pattern and other use of IIFE, you could see the book Learning JavaScript Design Patterns by Addy Osmani.

 js 

```
const makeWithdraw = (balance) =>
  ((copyBalance) => {
    let balance = copyBalance; // This variable is private
    const doBadThings = () => {
      console.log("I will do bad things with your money");
    };
    doBadThings();
    return {
      withdraw(amount) {
        if (balance >= amount) {
          balance -= amount;
          return balance;
        }
        return "Insufficient money";
      },
    };
  })(balance);

const firstAccount = makeWithdraw(100); // "I will do bad things with your money"
console.log(firstAccount.balance); // undefined
console.log(firstAccount.withdraw(20)); // 80
console.log(firstAccount.withdraw(30)); // 50
console.log(firstAccount.doBadThings); // undefined; this method is private
const secondAccount = makeWithdraw(20); // "I will do bad things with your money"
console.log(secondAccount.withdraw(30)); // "Insufficient money"
console.log(secondAccount.withdraw(20)); // 0
```

 
 
 

### For loop with var before ES6 

 
 

We could see the following use of IIFE in some old code, before the introduction of the block-scoped `let` and `const` declarations. With the statement `var`, we have only function scopes and the global scope.
Suppose we want to create 2 buttons with the texts Button 0 and Button 1 and when we click
them, we would like them to alert 0 and 1. The following code doesn't work:

 js 

```
for (var i = 0; i < 2; i++) {
  const button = document.createElement("button");
  button.innerText = `Button ${i}`;
  button.onclick = function () {
    console.log(i);
  };
  document.body.appendChild(button);
}
console.log(i); // 2
```

 

When clicked, both Button 0 and Button 1 alert 2 because `i` is global,
with the last value 2. To fix this problem before ES6, we could use the IIFE pattern:

 js 

```
for (var i = 0; i < 2; i++) {
  const button = document.createElement("button");
  button.innerText = `Button ${i}`;
  button.onclick = (function (copyOfI) {
    return function () {
      console.log(copyOfI);
    };
  })(i);
  document.body.appendChild(button);
}
console.log(i); // 2
```

 

When clicked, Buttons 0 and 1 alert 0 and 1. The variable `i` is globally defined. Using the statement `let`, we could simply do:

 js 

```
for (let i = 0; i < 2; i++) {
  const button = document.createElement("button");
  button.innerText = `Button ${i}`;
  button.onclick = function () {
    console.log(i);
  };
  document.body.appendChild(button);
}
console.log(i); // Uncaught ReferenceError: i is not defined.
```

 

When clicked, these buttons alert 0 and 1.

 
 

### Control flow statements in expression positions 

 
 

IIFEs enable us to use language constructs such as `switch` in an expression.

 js 

```
someObject.property = (() => {
  switch (someVariable) {
    case 0:
      return "zero";
    case 1:
      return "one";
    default:
      return "unknown";
  }
})();
```

 

This approach can be especially useful in scenarios where you want to make a variable `const`, but
are forced to use `let` or `var` during initialization:

 js 

```
let onlyAssignedOnce;
try {
  onlyAssignedOnce = someFunctionThatMightThrow();
} catch (e) {
  onlyAssignedOnce = null;
}
```

 

Using IIFEs, we can make the variable `const`:

 js 

```
const onlyAssignedOnce = (() => {
  try {
    return someFunctionThatMightThrow();
  } catch (e) {
    return null;
  }
})();
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Functions 

- `function` 

- `Function` 

- Arrow functions 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### class expression - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class

class expression - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# class expression

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨March 2016⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `class` keyword can be used to define a class inside an expression.

You can also define classes using the `class` declaration .

 
 
 
 
 
 

## Try it 

 
 
 

```
const Rectangle = class {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
  area() {
    return this.height * this.width;
  }
};

console.log(new Rectangle(5, 8).area());
// Expected output: 40
```

 
 
 

## Syntax 

 
 js 

```
class {
  // class body
}
class name {
  // class body
}
```

 
 

 Note: 
An expression statement cannot begin with the keyword `class` to avoid ambiguity with a `class` declaration . The `class` keyword only begins an expression when it appears in a context that cannot accept statements.

 
 
 

## Description 

 
 

A `class` expression is very similar to, and has almost the same syntax as, a `class` declaration . As with `class` declarations, the body of a `class` expression is executed in strict mode . The main difference between a `class` expression and a `class` declaration is the class name , which can be omitted in `class` expressions to create anonymous classes. Class expressions allow you to redefine classes, while redeclaring a class using `class` declarations throws a `SyntaxError` . See also the chapter about classes for more information.

 
 

## Examples 

 
 
 
 

### A basic class expression 

 
 

This is just an anonymous class expression which you can refer to using the variable `Foo`.

 js 

```
const Foo = class {
  constructor() {}
  bar() {
    return "Hello World!";
  }
};

const instance = new Foo();
instance.bar(); // "Hello World!"
Foo.name; // "Foo"
```

 
 
 

### Named class expressions 

 
 

If you want to refer to the current class inside the class body, you can create a named class expression . The name is only visible within the scope of the class expression itself.

 js 

```
const Foo = class NamedFoo {
  constructor() {}
  whoIsThere() {
    return NamedFoo.name;
  }
};
const bar = new Foo();
bar.whoIsThere(); // "NamedFoo"
NamedFoo.name; // ReferenceError: NamedFoo is not defined
Foo.name; // "NamedFoo"
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-class-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- `class` 

- Classes 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

### function* expression - JavaScript | MDN

**Source:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function*

function* expression - JavaScript | MDN 
 
 
 - 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 Skip to main content 

 - Skip to search 

 

 
 
 
 
 
 
 
 
 
 
 
 

# function* expression

 
 
 
 
 
 Baseline
 
 Widely available
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 This feature is well established and works across many devices and browser versions. It’s been available across browsers since ⁨September 2016⁩.
 

 
 

 - 
 
 Learn more
 
 

 - 
 
 See full compatibility
 
 

 - 
 
 Report feedback
 
 

 

 
 
 
 

The `function*` keyword can be used to define a generator function inside an expression.

You can also define generator functions using the `function*` declaration .

 
 
 
 
 
 

## Try it 

 
 
 

```
const foo = function* () {
  yield "a";
  yield "b";
  yield "c";
};

let str = "";
for (const val of foo()) {
  str += val;
}

console.log(str);
// Expected output: "abc"
```

 
 
 

## Syntax 

 
 js 

```
function* (param0) {
  statements
}
function* (param0, param1) {
  statements
}
function* (param0, param1, /* …, */ paramN) {
  statements
}

function* name(param0) {
  statements
}
function* name(param0, param1) {
  statements
}
function* name(param0, param1, /* …, */ paramN) {
  statements
}
```

 
 

 Note: 
An expression statement cannot begin with the keyword `function` to avoid ambiguity with a `function*` declaration . The `function` keyword only begins an expression when it appears in a context that cannot accept statements.

 
 
 

### Parameters 

 
 
 `name` Optional 
 

The function name. Can be omitted, in which case the function is anonymous . The name is only local to the function body.

 
 `paramN` Optional 
 

The name of a formal parameter for the function. For the parameters' syntax, see the Functions reference .

 
 `statements` Optional 
 

The statements which comprise the body of the function.

 
 
 
 

## Description 

 
 

A `function*` expression is very similar to, and has almost the same syntax as, a `function*` declaration . The main difference between a `function*` expression and a `function*` declaration is the function name , which can be omitted in `function*` expressions to create anonymous functions. A `function*` expression can be used as an IIFE (Immediately Invoked Function Expression) which runs as soon as it is defined, allowing you to create an ad-hoc iterable iterator object . See also the chapter about functions for more information.

 
 

## Examples 

 
 
 
 

### Using function* expression 

 
 

The following example defines an unnamed generator function and assigns it to `x`. The function yields the square of its argument:

 js 

```
const x = function* (y) {
  yield y * y;
};
```

 
 
 

## Specifications 

 
 
 
 
 Specification 
 
 
 
 
 ECMAScript® 2026 Language Specification 
 # sec-generator-function-definitions 
 
 
 
 
 

## Browser compatibility 

 
 

 Enable JavaScript to view this browser compatibility table. 

 
 
 

## See also 

 
 

- Functions guide

- Functions 

- `function*` 

- `GeneratorFunction` 

- Iteration protocols 

- `yield` 

- `yield*` 

 
 
 
 
 

## Help improve MDN

 
 Was this page helpful to you? 
 
 
 
 
 
 Yes 
 
 
 
 
 No 
 
 
 
 Learn how to contribute 

 This page was last modified on ⁨Jul 8, 2025⁩ by MDN contributors .
 

 
 View this page on GitHub • Report a problem with this content

---

